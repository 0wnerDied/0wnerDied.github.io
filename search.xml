<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>浅析 eBPF</title>
    <url>/kernel/50584.html</url>
    <content><![CDATA[<h2 id="ebpf-工作原理总览">eBPF 工作原理总览</h2>
<p>eBPF，一个源于 Linux
内核的革命性技术，允许我们在内核这个特权环境中安全地运行沙盒程序。值得一提的是，BPF
最初是 “伯克利数据包过滤器” 的缩写，但如今它的能力已远超网络领域，因此
“BPF” 已成为一个独立术语，而其前身则被称为 <strong>cBPF (classic
BPF)</strong>。</p>
<p>eBPF 程序并非直接在 CPU
上运行，而是在一个位于内核中的、高度安全和高效的<strong> BPF
虚拟机</strong> 上执行。我们可以将该虚拟机理解为一个沙盒，确保 eBPF
代码不会导致 kernel panic。</p>
<img src="/kernel/50584/kernel_panic.jpg" class="" title="panic">
<p>为了让这个虚拟机正常运行，我们需要给它一套指令，这就是 <strong>BPF
指令集</strong>。我们用 C 语言等高级语言写好的逻辑，通过编译器（如
LLVM / Clang）翻译成 BPF 指令集字节码，然后才能交给虚拟机执行。</p>
<p>但光有代码执行是不够的，eBPF
程序经常需要和用户空间程序或者内核的其他部分交换数据，这时就需要用到
<strong>BPF Maps</strong>。这是一种高效的键值对存储，是 eBPF
程序与外界沟通的桥梁。</p>
<p>此外，为了让 eBPF 程序能与内核交互（比如获取当前进程
ID），内核提供了一组固定的<strong>辅助函数 (Helper
Functions)</strong>。eBPF
程序只能调用这些预设的、安全的函数，从而在获得强大能力的同时，保证了内核稳定。</p>
<p>最后，编译好的 BPF 字节码在通过 <code>bpf()</code>
系统调用加载到内核时，会经过一个严格的<strong>校验器 (Verifier)</strong>
检查，确保代码无害。通过后，字节码可以被<strong>即时编译器
(JIT)</strong> 翻译成原生机器码，以接近本地代码的速度执行。</p>
<img src="/kernel/50584/%E6%80%BB%E8%A7%88.png" class="" title="总览">
<p>接下来，我们将逐一拆解这些核心组件。</p>
<h2 id="bpf-虚拟机与指令集">BPF 虚拟机与指令集</h2>
<p>BPF
程序运行在一个小巧而高效的虚拟机上。这个虚拟机有自己的一套寄存器和指令集，就像一个微型的
CPU。</p>
<ul>
<li><strong>寄存器</strong>: BPF 虚拟机有 11 个 64 位寄存器。
<ul>
<li><code>R0</code> - <code>R9</code>:
通用寄存器，用于计算、存储数据和传递参数。</li>
<li><code>R10</code>: 只读的帧指针寄存器，用于访问栈空间。</li>
</ul></li>
</ul>
<img src="/kernel/50584/%E8%99%9A%E6%8B%9F%E6%9C%BA.png" class="" title="vm">
<ul>
<li><strong>指令集</strong>: BPF
指令集中，所有指令都是固定长度的，运行更加简单高效。</li>
</ul>
<h3 id="指令格式">指令格式</h3>
<p>BPF 指令集官方说明可以参考 Linux 内核文档：<a href="https://web.git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/bpf/standardization/instruction-set.rst">BPF
Instruction Set</a></p>
<p>BPF 指令有两种格式：</p>
<ol type="1">
<li><strong>基本指令 (64-bit)</strong>:
这是最常见的格式，由操作码、寄存器、偏移量和立即数组成。所有未使用的字段都必须为零。
<ul>
<li><code>opcode</code>: 8 bit (操作码)</li>
<li><code>regs</code>: 8 bit (目标寄存器: 4 bit, 源寄存器: 4
bit)，在大端序和小端序主机上，这两个 4-bit 字段的顺序是相反的。</li>
<li><code>offset</code>: 16 bit (偏移量)</li>
<li><code>imm</code>: 32 bit (立即数)</li>
</ul></li>
<li><strong>宽指令 (128-bit)</strong>: 专用于加载一个 64
位的立即数（ld_imm64）。它由两个连续的 64 位指令构成。
<ul>
<li>第一个 64 位指令：正常的基本指令格式，其中 imm 字段存放 64
位立即数的低 32 位</li>
<li>第二个 64 位指令：前 32 位（opcode + regs + offset）必须全部为
0，imm 字段存放 64 位立即数的高 32 位</li>
</ul></li>
</ol>
<h3 id="操作码-opcode">操作码 (Opcode)</h3>
<p><code>opcode</code> 决定了一条指令做什么。它的最后 3
位定义了指令的<strong>类别 (Class)</strong>。</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">value</th>
<th style="text-align: left;">class</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0x00</td>
<td style="text-align: left;">LD</td>
<td style="text-align: left;"><strong>加载
(Load)</strong>，非标准加载操作，主要用于 <code>ld_imm64</code>
宽指令。</td>
</tr>
<tr class="even">
<td style="text-align: left;">0x01</td>
<td style="text-align: left;">LDX</td>
<td style="text-align: left;"><strong>加载
(Load)</strong>，从内存读取数据到寄存器。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">0x02</td>
<td style="text-align: left;">ST</td>
<td style="text-align: left;"><strong>存储
(Store)</strong>，将立即数写入内存。</td>
</tr>
<tr class="even">
<td style="text-align: left;">0x03</td>
<td style="text-align: left;">STX</td>
<td style="text-align: left;"><strong>存储
(Store)</strong>，将寄存器的值写入内存。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">0x04</td>
<td style="text-align: left;">ALU</td>
<td style="text-align: left;">32 位算术与逻辑运算。</td>
</tr>
<tr class="even">
<td style="text-align: left;">0x05</td>
<td style="text-align: left;">JMP</td>
<td style="text-align: left;"><strong>跳转
(Jump)</strong>，64 位操作数的条件或无条件跳转。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">0x06</td>
<td style="text-align: left;">JMP32</td>
<td style="text-align: left;"><strong>跳转
(Jump)</strong>，32 位操作数的条件或无条件跳转。</td>
</tr>
<tr class="even">
<td style="text-align: left;">0x07</td>
<td style="text-align: left;">ALU64</td>
<td style="text-align: left;">64 位算术与逻辑运算。</td>
</tr>
</tbody>
</table>
<h3 id="存取指令-ldldx-ststx">存取指令 (LD/LDX, ST/STX)</h3>
<p>这类指令负责在寄存器和内存之间搬运数据。它的 <code>opcode</code>
除了类别外，还包含了<strong>寻址模式 (Mode)</strong> 和<strong>数据大小
(Size)</strong>。</p>
<p><strong>寻址模式 (Mode)</strong></p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">value</th>
<th style="text-align: left;">mode modifier</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">IMM</td>
<td style="text-align: left;"><strong>立即数 (Immediate)</strong>，用于
<code>ld_imm64</code> 指令加载 64 位立即数。</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">ABS</td>
<td style="text-align: left;"><strong>绝对寻址
(Absolute)</strong>，用于传统 cBPF，已废弃。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">IND</td>
<td style="text-align: left;"><strong>间接寻址
(Indirect)</strong>，用于传统 cBPF，已废弃。</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">MEM</td>
<td style="text-align: left;"><strong>常规内存操作
(Memory)</strong>，最常见的加载和存储模式。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">MEMSX</td>
<td style="text-align: left;"><strong>符号扩展加载 (Sign-extending
load)</strong>，加载时将有符号小整数正确扩展到 64 位。</td>
</tr>
<tr class="even">
<td style="text-align: left;">6</td>
<td style="text-align: left;">ATOMIC</td>
<td style="text-align: left;"><strong>原子操作
(Atomic)</strong>，用于实现安全的并发数据修改。</td>
</tr>
</tbody>
</table>
<p><strong>数据大小 (Size)</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">value</th>
<th style="text-align: left;">size</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">W</td>
<td style="text-align: left;"><strong>字 (Word)</strong>, 4 字节</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">H</td>
<td style="text-align: left;"><strong>半字 (Half-word)</strong>, 2
字节</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2</td>
<td style="text-align: left;">B</td>
<td style="text-align: left;"><strong>字节 (Byte)</strong>, 1 字节</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">DW</td>
<td style="text-align: left;"><strong>双字 (Double-word)</strong>, 8
字节</td>
</tr>
</tbody>
</table>
<h4 id="位立即数加载-ld_imm64">64 位立即数加载 (ld_imm64)</h4>
<p><code>ld_imm64</code> (Class <code>0x00</code>, Mode
<code>0x00</code>, Size <code>0x03</code>) 是一条非常特殊的指令，使用
128 位的宽格式。它不仅能加载一个 64 位的常量，还能通过
<code>src_reg</code> 字段的不同取值，实现加载 Map 地址等高级功能，是连接
BPF 程序和外部资源的关键。</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><code>src_reg</code></th>
<th style="text-align: left;">伪代码</th>
<th style="text-align: left;"><code>imm</code> 类型</th>
<th style="text-align: left;">目标寄存器类型</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0x0</td>
<td style="text-align: left;"><code>dst = (next_imm &lt;&lt; 32) \| imm</code></td>
<td style="text-align: left;">整数</td>
<td style="text-align: left;">整数</td>
</tr>
<tr class="even">
<td style="text-align: left;">0x1</td>
<td style="text-align: left;"><code>dst = map_by_fd(imm)</code></td>
<td style="text-align: left;">Map 文件描述符</td>
<td style="text-align: left;">Map 地址</td>
</tr>
<tr class="odd">
<td style="text-align: left;">0x2</td>
<td style="text-align: left;"><code>dst = map_val(map_by_fd(imm)) + next_imm</code></td>
<td style="text-align: left;">Map 文件描述符</td>
<td style="text-align: left;">Map 值地址</td>
</tr>
<tr class="even">
<td style="text-align: left;">0x5</td>
<td style="text-align: left;"><code>dst = map_by_idx(imm)</code></td>
<td style="text-align: left;">Map 程序内索引</td>
<td style="text-align: left;">Map 地址</td>
</tr>
<tr class="odd">
<td style="text-align: left;">0x6</td>
<td style="text-align: left;"><code>dst = map_val(map_by_idx(imm)) + next_imm</code></td>
<td style="text-align: left;">Map 程序内索引</td>
<td style="text-align: left;">Map 值地址</td>
</tr>
</tbody>
</table>
<p>上面的表格就解释了在 BPF C 代码中，表面上直接引用的 Map
变量，在底层是如何通过 <code>ld_imm64</code>
指令被解析成实际内存地址的。</p>
<h4 id="常规与符号扩展加载存储">常规与符号扩展加载 / 存储</h4>
<ul>
<li><strong>常规加载 / 存储 (<code>MEM</code>)</strong>:
<ul>
<li><code>*(size *) (dst_reg + offset) = src_reg</code> (STX)</li>
<li><code>*(size *) (dst_reg + offset) = imm</code> (ST)</li>
<li><code>dst_reg = *(unsigned size *) (src_reg + offset)</code>
(LDX)</li>
</ul></li>
<li><strong>符号扩展加载 (<code>MEMSX</code>)</strong>:
<ul>
<li><code>dst_reg = *(signed size *) (src_reg + offset)</code>
(LDX)</li>
<li>用于从内存加载一个有符号的小整数（如 <code>s8</code>,
<code>s16</code>）到 64
位寄存器时，能正确地将符号位扩展到高位，保持数值不变。</li>
</ul></li>
</ul>
<h4 id="原子操作-atomic">原子操作 (Atomic)</h4>
<p>原子操作通过 <code>STX</code> 指令实现，使用 <code>ATOMIC</code>
寻址模式，支持 32 位 (<code>W</code>) 和 64 位 (<code>DW</code>)
操作。<code>imm</code> 字段用于编码具体的操作。</p>
<ul>
<li><strong>简单原子操作</strong>: <code>imm</code>
字段的值与算术指令类似。
<ul>
<li><code>ADD (0x00)</code>:
<code>*(size *)(dst + offset) += src</code></li>
<li><code>OR (0x40)</code>, <code>AND (0x50)</code>,
<code>XOR (0xa0)</code></li>
</ul></li>
<li><strong>复杂原子操作</strong>:
<ul>
<li><code>XCHG (0xe1)</code>: 原子地交换 <code>src</code> 和
<code>*(dst + offset)</code> 的值。</li>
<li><code>CMPXCHG (0xf1)</code>: 原子地比较 <code>*(dst + offset)</code>
和 <code>R0</code>，如果相等，则将 <code>src</code> 写入
<code>*(dst + offset)</code>。无论如何，都将内存旧值加载回
<code>R0</code>。</li>
</ul></li>
<li><strong>FETCH 修饰符</strong>: 如果 <code>imm</code> 中包含
<code>FETCH (0x01)</code>
标志，操作会在执行后，将内存中的<strong>旧值</strong>返回到
<code>src_reg</code>。<code>XCHG</code> 和 <code>CMPXCHG</code>
总是隐式包含 <code>FETCH</code>。</li>
</ul>
<h3 id="算术与跳转指令-alujmp">算术与跳转指令 (ALU / JMP)</h3>
<p>这类指令的 <code>opcode</code> 除了类别，还包含<strong>操作码
(Code)</strong> 和<strong>源 (Source)</strong>。</p>
<p><strong>操作数来源 (Source)</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">value</th>
<th style="text-align: left;">source</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">K</td>
<td style="text-align: left;">操作数是一个 32 位立即数
<code>imm</code>。</td>
</tr>
<tr class="even">
<td style="text-align: left;">1</td>
<td style="text-align: left;">X</td>
<td style="text-align: left;">操作数是另一个寄存器
<code>src_reg</code>。</td>
</tr>
</tbody>
</table>
<h4 id="算术指令-alualu64">算术指令 (ALU / ALU64)</h4>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">name</th>
<th style="text-align: left;">code</th>
<th style="text-align: left;">描述与边界情况</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">ADD/SUB</td>
<td style="text-align: left;">0x0/0x1</td>
<td style="text-align: left;">加 / 减法，允许溢出回绕。</td>
</tr>
<tr class="even">
<td style="text-align: left;">MUL/DIV</td>
<td style="text-align: left;">0x2/0x3</td>
<td style="text-align: left;">乘 / 除法。<strong>除以零时，结果为
0</strong>。有符号除法 <code>SDIV</code> 中，<code>LLONG_MIN / -1</code>
结果仍为 <code>LLONG_MIN</code>。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MOD</td>
<td style="text-align: left;">0x9</td>
<td style="text-align: left;">取模。<strong>对零取模时，ALU64 下 dst
不变，ALU32 下 dst 高 32 位清零</strong>。有符号取模 <code>SMOD</code>
中，<code>LLONG_MIN % -1</code> 结果为 0。</td>
</tr>
<tr class="even">
<td style="text-align: left;">OR/AND/XOR</td>
<td style="text-align: left;">0x4/0x5/0xa</td>
<td style="text-align: left;">按位或/与/异或。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LSH/RSH</td>
<td style="text-align: left;">0x6/0x7</td>
<td style="text-align: left;">逻辑左 / 右移。移动位数会被
<code>&amp; 63</code> (64 位) 或 <code>&amp; 31</code> (32 位) 屏蔽。</td>
</tr>
<tr class="even">
<td style="text-align: left;">ARSH</td>
<td style="text-align: left;">0xc</td>
<td style="text-align: left;">算术右移（带符号扩展）。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">NEG</td>
<td style="text-align: left;">0x8</td>
<td style="text-align: left;">取负。</td>
</tr>
<tr class="even">
<td style="text-align: left;">MOV</td>
<td style="text-align: left;">0xb</td>
<td style="text-align: left;">移动。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MOVSX</td>
<td style="text-align: left;">0xb</td>
<td style="text-align: left;"><strong>符号扩展移动</strong>。从
<code>src</code> 移动 <code>s8</code>, <code>s16</code> 或
<code>s32</code> 到 <code>dst</code> 并进行符号扩展。</td>
</tr>
<tr class="even">
<td style="text-align: left;">END</td>
<td style="text-align: left;">0xd</td>
<td style="text-align: left;"><strong>字节序转换</strong>。<code>ALU</code>
模式下，<code>source</code> 位决定是转为小端 (<code>LE</code>) 还是大端
(<code>BE</code>)。<code>ALU64</code> 模式下，进行无条件的大小端翻转
(<code>bswap</code>)。<code>imm</code> 决定宽度 (16/32/64)。</td>
</tr>
</tbody>
</table>
<h4 id="跳转指令-jmpjmp32">跳转指令 (JMP / JMP32)</h4>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">code</th>
<th style="text-align: left;">value</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">JA</td>
<td style="text-align: left;">0x0</td>
<td style="text-align: left;">无条件跳转。<code>JMP</code> 版用
<code>offset</code> (16 位)，<code>JMP32</code> 版用 <code>imm</code>
(32 位)。</td>
</tr>
<tr class="even">
<td style="text-align: left;">JEQ/JNE</td>
<td style="text-align: left;">0x1/0x5</td>
<td style="text-align: left;">等于 / 不等于则跳转。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">JGT/JGE</td>
<td style="text-align: left;">0x2/0x3</td>
<td style="text-align: left;"><strong>无符号</strong>大于 / 大于等于则跳转。</td>
</tr>
<tr class="even">
<td style="text-align: left;">JLT/JLE</td>
<td style="text-align: left;">0xa/0xb</td>
<td style="text-align: left;"><strong>无符号</strong>小于 / 小于等于则跳转。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">JSGT/JSGE</td>
<td style="text-align: left;">0x6/0x7</td>
<td style="text-align: left;"><strong>有符号</strong>大于 / 大于等于则跳转。</td>
</tr>
<tr class="even">
<td style="text-align: left;">JSLT/JSLE</td>
<td style="text-align: left;">0xc/0xd</td>
<td style="text-align: left;"><strong>有符号</strong>小于 / 小于等于则跳转。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">JSET</td>
<td style="text-align: left;">0x4</td>
<td style="text-align: left;">按位与结果非零则跳转。</td>
</tr>
<tr class="even">
<td style="text-align: left;">CALL</td>
<td style="text-align: left;">0x8</td>
<td style="text-align: left;"><strong>函数调用</strong>。这是 eBPF
能力扩展的核心。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">EXIT</td>
<td style="text-align: left;">0x9</td>
<td style="text-align: left;"><strong>程序返回</strong>，终止执行。在子函数中调用则返回到调用点。</td>
</tr>
</tbody>
</table>
<p><code>CALL</code> 指令有几种不同的用法，通过 <code>src_reg</code>
区分：</p>
<ul>
<li><code>src_reg = 0</code>: 调用由 <code>imm</code> 指定 ID
的<strong>内核辅助函数</strong>。</li>
<li><code>src_reg = 1</code>:
调用<strong>程序内本地函数</strong>，<code>imm</code>
是相对于当前指令的偏移量。</li>
<li><code>src_reg = 2</code>: 通过 <code>imm</code> 指定的 <strong>BTF
ID</strong> 来调用内核辅助函数。</li>
</ul>
<h2 id="核心组件bpf-maps">核心组件：BPF Maps</h2>
<p>如果说 BPF 程序是处理数据的 “工人”，那 <strong>BPF Maps</strong>
就是工人们存放工具、交换半成品的 “仓库”。前面我们已经看到，<code>ld_imm64</code>
指令是如何在底层将 Map 翻译成地址的。</p>
<p>BPF Maps
是一种通用的、存在于内核中的键值对存储。它有以下几个关键作用：</p>
<ol type="1">
<li><strong>状态保持</strong>: BPF
程序本身是无状态的，一次事件触发执行完所有信息就丢失了。Maps
可以在多次执行之间保存状态，比如，用来统计某个网络包出现的次数。</li>
<li><strong>内外通信</strong>: 用户空间的控制程序可以通过读写 Maps，向
BPF 程序传递配置，或者从 BPF 程序中获取采集到的数据。</li>
<li><strong>程序间通信</strong>: 一个 BPF 程序可以将数据写入 Map，另一个
BPF 程序可以从中读取，实现程序间的协作。</li>
</ol>
<p>内核提供了多种 Map 类型，以适应不同场景，例如：</p>
<ul>
<li><code>BPF_MAP_TYPE_HASH</code>: 高效哈希表。</li>
<li><code>BPF_MAP_TYPE_ARRAY</code>: 高效数组。</li>
<li><code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>:
用于向用户空间发送性能事件数据。</li>
<li><code>BPF_MAP_TYPE_RINGBUF</code>:
高性能的环形缓冲区，向用户空间传递数据。</li>
<li><code>BPF_MAP_TYPE_LRU_HASH</code>: 带 LRU
淘汰的哈希表，适合连接追踪。<br>
</li>
<li><code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code> /
<code>BPF_MAP_TYPE_HASH_OF_MAPS</code>: Map 嵌套，用于多 namespace
或多租户隔离。</li>
</ul>
<h2 id="能力扩展内核辅助函数">能力扩展：内核辅助函数</h2>
<p>为了安全，BPF
虚拟机是一个完全隔离的沙盒，它不能随意调用内核里的任意函数。那它如何与内核交互呢？答案是
<strong>内核辅助函数 (Helper Functions)</strong>。</p>
<p>正如我们在 <code>CALL</code> 指令中看到的，BPF
程序可以通过特定指令调用一份内核提供的 “白名单” 函数。这些函数就是辅助函数，它们是
eBPF 程序能力的源泉，提供了诸如：</p>
<ul>
<li><strong>访问 Maps</strong>:
<code>bpf_map_lookup_elem()</code>、<code>bpf_map_update_elem()</code></li>
<li><strong>获取上下文信息</strong>:
<code>bpf_get_current_pid_tgid()</code>、<code>bpf_ktime_get_ns()</code></li>
<li><strong>网络包处理</strong>: <code>bpf_skb_store_bytes()</code></li>
<li><strong>打印调试</strong>: <code>bpf_printk()</code></li>
</ul>
<p>eBPF
程序只能调用这个固定的函数集合，这既赋予了它强大的能力，也从根本上保证了内核的安全。</p>
<h2 id="bpf-程序类型">BPF 程序类型</h2>
<p>eBPF
程序不是随便挂在内核里就能运行的，它必须附着在内核的特定<strong>挂载点
(Hook Point)</strong> 上。<strong>BPF 程序类型 (Program Type)</strong>
就定义了程序可以挂载在哪里，以及它能做什么。</p>
<p>不同的程序类型，决定了 eBPF 的应用场景。例如：</p>
<ul>
<li><strong>Kprobes / Tracepoints</strong>:
用于内核态函数追踪和性能分析，是可观测性工具（如
<code>bcc</code>、<code>bpftrace</code>）的根本。</li>
<li><strong>XDP (eXpress Data Path)</strong>:
挂载在网卡驱动层，能在网络包进入协议栈前进行处理，实现超高性能的防火墙、负载均衡等。</li>
<li><strong>TC (Traffic Control)</strong>:
挂载在内核网络协议栈的队列规则上，用于实现复杂的网络包过滤和流量整形。</li>
<li><strong>LSM (Linux Security Modules)</strong>:
用于实现更灵活、更细粒度的安全策略。</li>
</ul>
<p>程序类型决定了 BPF 程序被调用时，<code>R1</code>
寄存器中传入的<strong>上下文 (Context)</strong>
类型（比如对于网络程序是网络包
<code>sk_buff</code>），以及它能调用的辅助函数集合。</p>
<h2 id="编译加载与校验">编译、加载与校验</h2>
<p>正常来说通常使用 C 语言的一个子集来编写 BPF 程序，然后用
<code>LLVM/Clang</code> 将其编译成 BPF 字节码。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">clang -O2 -target bpf -c bpf_program.c -o bpf.o</span><br></pre></td></tr></tbody></table></figure>
<p>编译出的字节码需要通过 <code>bpf()</code>
系统调用加载到内核中。现代开发通常使用 <code>libbpf</code>
这样的库来简化加载、挂载和与 Maps 交互的过程。</p>
<p>在程序运行前，内核的<strong>校验器 (Verifier)</strong>
会对字节码进行极其严格的静态分析，确保其安全性。校验器是 eBPF
安全模型的基石，它会检查：</p>
<ol type="1">
<li><strong>程序必须能终止</strong>:
禁止无限循环，通过有向无环图检查确保程序不会永远执行下去。</li>
<li><strong>内存访问安全</strong>:
确保不会访问越界的内存地址，不会读取未初始化的栈内存或寄存器。</li>
<li><strong>类型安全</strong>:
检查函数调用的参数类型是否正确，对上下文的访问是否合规。</li>
</ol>
<p>只有通过校验的 BPF 程序才被认为是安全的，并被允许加载到内核中。</p>
<details>
<summary>
Verifier 常见拒绝示例
</summary>
<table>
<thead>
<tr class="header">
<th>报错片段</th>
<th>触发原因</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>invalid indirect read from stack</td>
<td>读到未初始化栈空间</td>
</tr>
<tr class="even">
<td>possible pointer arithmetic on ctx</td>
<td>对只读 ctx 指针做算术</td>
</tr>
<tr class="odd">
<td>jump out of range</td>
<td>分支过深 / offset 溢出</td>
</tr>
</tbody>
</table>
</details>
<h3 id="co-recompile-once-run-everywhere">CO-RE（Compile Once – Run
Everywhere）</h3>
<p>如果目标机器内核启用了 <a href="https://www.kernel.org/doc/html/latest/bpf/btf.html">BTF</a>，建议在编译时打开
CO - RE：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">clang -g -O2 -target bpf -D__TARGET_ARCH_$(<span class="built_in">uname</span> -m) \</span><br><span class="line">      -c prog.c -o prog.o</span><br></pre></td></tr></tbody></table></figure>
<p>同一个 <code>.o</code> 文件可跨 5.x / 6.x
内核直接重定位字段，无需重编译。</p>
<h2 id="执行解释器与-jit-编译器">执行：解释器与 JIT 编译器</h2>
<p>通过校验后，BPF 字节码终于可以执行了。内核提供了两种执行方式：</p>
<h3 id="解释器-interpreter">解释器 (Interpreter)</h3>
<p>解释器会逐条读取 BPF
字节码并模拟执行。它非常安全，但效率相对较低，因为每条指令都需要软件模拟。</p>
<h3 id="jit-编译器-just-in-time">JIT 编译器 (Just-In-Time)</h3>
<p>为了追求极致性能，eBPF 支持<strong>即时编译
(JIT)</strong>。在程序加载时，JIT 编译器会将整个 BPF
字节码动态地翻译成目标机器（如 x86-64, ARM64）的原生指令。</p>
<p>这样，当事件触发 BPF 程序时，CPU
可以直接执行这些编译好的原生指令，省去了逐条解释的开销，从而大大提高了执行效率，性能几乎与原生内核模块无异。</p>
<p>每个支持的 CPU 架构都有自己的 JIT 编译器实现，例如内核源码中的
<code>bpf_jit_comp.c</code>。</p>
<h2 id="运行-demo">运行 Demo</h2>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/libbpf/libbpf-bootstrap.git</span><br><span class="line"><span class="built_in">cd</span> libbpf-bootstrap/examples/c/minimal</span><br><span class="line">make minimal</span><br><span class="line"><span class="built_in">sudo</span> ./minimal</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /sys/kernel/debug/tracing/trace_pipe</span><br><span class="line">           &lt;...&gt;-3840345 [010] d... 3220701.101143: bpf_trace_printk: BPF triggered from PID 3840345.</span><br><span class="line">           &lt;...&gt;-3840345 [010] d... 3220702.101265: bpf_trace_printk: BPF triggered from PID 3840345.</span><br></pre></td></tr></tbody></table></figure>
<p>详细使用方法可以查看项目的 README 文件。</p>
<blockquote>
<p><strong>Takeaway</strong>: eBPF = 事件驱动 + 沙盒字节码 + Map +
Helper + Verifier + JIT</p>
</blockquote>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>ebpf</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages + cloudflare DNS 托管避坑</title>
    <url>/issue-resolve/49265.html</url>
    <content><![CDATA[<h2 id="问题描述">问题描述</h2>
<p>今天听同学说腾讯云的域名很便宜，十年才 230 CNY，非常心动，遂入手域名
<a href="https://0b1t.tech">0b1t.tech</a>，买完想把原本托管在 github
上的博客重定向到新的域名上的，没想到迁移出了问题。</p>
<p>一开始都很顺利，但是发现腾讯云自带的 dnspod 服务只能添加两条 DNS
记录，怎么能受这气？直接登上我的 cloudflare，把 DNS 服务改成
cloudflare。没想到就是 cloudflare DNS
默认打开的代理让我折腾了一个晚上。一开始没有发现这个问题，试了 A 记录和
CNAME 记录，结果一直不行，提示</p>
<blockquote>
<p>unavailable for your site because your domain is not properly
configured to support https</p>
</blockquote>
<p>这不是恶心人吗？https
打勾的框一直都是灰色的，无法勾选，受不了了，到网上去找相似的
issue，还真给我找到了解决方法。</p>
<h2 id="解决方案">解决方案</h2>
<p>社区很多讨论中都说要检查下面的几步：</p>
<blockquote>
<p>Check SSL Certificate Installation: Make sure that your SSL
certificate is properly installed for the domain. If you’re using a
certificate provider, ensure that the certificate is correctly
configured for your domain and is not expired.</p>
<p>Verify DNS Settings: Confirm that your domain’s DNS settings point to
the correct server where your site is hosted, and make sure the CNAME or
A records are set up correctly. You should also make sure that any DNS
propagation has fully completed. DNS changes can take some time (up to
48 hours), so double-check that your records are pointing to the right
place.</p>
<p>Check Server Configuration: Ensure that your server is configured to
accept HTTPS requests on port 443. Sometimes web servers require
specific configuration changes to allow HTTPS traffic. For example, in
Apache or Nginx, make sure the SSL configuration in your site’s server
block or virtual host is correctly set.</p>
<p>Redirect HTTP to HTTPS: Add HTTP to HTTPS redirects in your server
configuration. This ensures that users who try to visit your site using
HTTP will automatically be redirected to the secure HTTPS version of the
site.</p>
</blockquote>
<p>但是经过我实测，如果你跟着一般教程走的话上面这些问题都不会碰到的，直到我看到下面这个讨论贴：<a href="https://github.com/orgs/community/discussions/23049">How to enable
https support on custom domains
#23049</a>，可以看到有很多回复，我一个个翻下去，还真有人提到了
cloudflare proxy 的问题 <a href="https://github.com/orgs/community/discussions/23049#discussioncomment-3573123">“If
you’re using Cloudflare you need to disable their proxy feature”</a></p>
<p>确实啊，我还没试过关掉 cloudflare 的代理！直接切换到 cloudflare
控制台，把代理关掉，配置如下图 <img src="/issue-resolve/49265/1-DNS.png" class="" title="DNS"> 然后我使用<a href="https://www.nslookup.io/">在线 DNS 检查网站</a>来查看我域名的
DNS， <img src="/issue-resolve/49265/2-check.png" class="" title="check"> 这不就对味了吗！ 再把 github page
在设置页静置一下，没想到过一会儿它自己就跑完了，也能勾选 https
了，好耶！ <img src="/issue-resolve/49265/3-HTTPS.png" class="" title="https"></p>
]]></content>
      <categories>
        <category>issue resolve</category>
      </categories>
      <tags>
        <tag>domain configure</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的神经网络学习 (一)：浅析神经网络</title>
    <url>/Machine-learning/36604.html</url>
    <content><![CDATA[<h2 id="神经网络的概念">神经网络的概念</h2>
<p>想象一下，我们想教计算机识别图片中的猫，但是我们不能为它编写一套硬性的规则（“如果它有尖耳朵、胡须和毛茸茸的尾巴，那它就是一只猫”），因为现实世界中的猫品种各异，<del>而且猫娘也符合上面的规则</del>。</p>
<p>神经网络采用了一种不同的方法：<strong>从样本中学习</strong>。就像我们通过看到真实的各种猫之后才知道这种动物叫 “猫” 一样，神经网络也会处理成千上万张标记好的图片（“这是猫”，“这不是猫”），并通过这种方法逐渐 “学会” 识别猫的视觉模式。</p>
<p>从技术上讲，神经网络是一种受人脑结构启发的计算模型。它由许多简单的处理单元 ——<strong> 神经元
(Neuron)</strong> 组成，这些神经元组织在不同的<strong>层
(Layer)</strong> 中。</p>
<p>一个经典的神经网络有三层：</p>
<ul>
<li><strong>输入层 (Input Layer)</strong>:
负责接收最原始的数据。例如，对于一张图片，每个神经元可能对应图片中的一个像素值。</li>
<li><strong>隐藏层 (Hidden Layers)</strong>:
位于输入层和输出层之间。这些是网络进行大部分 “思考” 的地方。一个神经网络可以没有隐藏层，也可以有很多个。层数越多，网络通常越 “深”。</li>
<li><strong>输出层 (Output Layer)</strong>:
产生最终的结果。例如，在猫识别任务中，输出层可能只有一个神经元，其输出值在 0 到 1 之间，表示图片是猫的概率。</li>
</ul>
<img src="/Machine-learning/36604/1-NN.png" class="" title="NN">
<h2 id="前向传播">前向传播</h2>
<p>数据在网络中流动并最终得到一个预测结果的过程就被称为<strong>前向传播
(Forward Propagation)</strong>。</p>
<h3 id="神经元和激活值">神经元和激活值</h3>
<p>简单来说，神经元就是持有一个数的简单单元，这个数称为<strong>激活值
(Activation)</strong>。输入层的神经元激活值就是我们输入的数据本身。对于其他层的神经元，它的激活值需要通过计算得出。</p>
<h3 id="连接和权重">连接和权重</h3>
<p>不同层的神经元之间通过连接进行通信。每个连接都有一个<strong>权重
(Weight)</strong>，这个数代表了连接的强度和重要性。</p>
<ul>
<li>一个较大的正权重意味着前一个神经元的激活会对后一个神经元产生强烈的 “兴奋” 作用。</li>
<li>一个较大的负权重则相反，表示会产生强烈的 “抑制” 作用。</li>
<li>接近于零的权重意味着前一个神经元对后一个神经元几乎没有影响。</li>
</ul>
<p><strong>训练神经网络的本质，就是调整这些权重的值。</strong></p>
<img src="/Machine-learning/36604/3-weights.png" class="" title="weights">
<h3 id="计算激活值">计算激活值</h3>
<p>一个神经元激活值的计算分两步：</p>
<ul>
<li><p><strong>计算加权和 (Weighted Sum)</strong>:
神经元接收来自前一层所有神经元的输入。它将每个输入的激活值乘以它们之间连接的权重，然后将所有结果相加。</p>
<img src="/Machine-learning/36604/4-weightedSum.png" class="" title="wSum">
<p>在加权和以外，我们还会加上一个额外的数字，叫做<strong>偏置
(Bias)</strong>。偏置的作用是提供一个可调的 “基础激活水平”。你可以把它看作是，在没有任何输入的情况下，一个神经元有多容易被激活。比如，一个高的偏置使得神经元更容易被激活。</p>
<p>所以，一个神经元的 “预激活值”（我们称之为
<code>z</code>）的完整公式是：</p>
<p><span class="math display">$$ z = \sum_{i=1}^{n}(w_i a_i) + bias
$$</span></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">inputs = [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>]</span><br><span class="line">weights = [<span class="number">0.2</span>, <span class="number">0.8</span>, -<span class="number">0.5</span>]</span><br><span class="line">bias = <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line">z = inputs[<span class="number">0</span>] * weights[<span class="number">0</span>] + inputs[<span class="number">1</span>] * weights[<span class="number">1</span>] + inputs[<span class="number">2</span>] * weights[<span class="number">2</span>] + bias</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line"><span class="comment"># z = 2.3</span></span><br></pre></td></tr></tbody></table></figure>
<img src="/Machine-learning/36604/5-weightsAndBias.png" class="" title="wBias"></li>
<li><p><strong>应用激活函数</strong>:
如果我们只用加权和，那么无论网络有多少层，它本质上都只是在做一个简单的线性变换。这限制了它学习复杂模式的能力。</p>
<p>为了引入<strong>非线性
(non-linearity)</strong>，我们需要一个<strong>激活函数</strong>。它接收上一步计算出的
<code>z</code> 值，并输出最终的激活值 <code>a</code>。</p>
<p>常见的激活函数有很多，这里我们介绍 <strong>ReLU (Rectified Linear
Unit，修正线性单元)</strong>。它的规则非常简单：</p>
<ul>
<li>如果输入 <code>z</code> 大于 0，输出就是 <code>z</code> 本身。</li>
<li>如果输入 <code>z</code> 小于或等于 0，输出就是 0。</li>
</ul>
<p>其数学表达式为：</p>
<p><span class="math display"><em>f</em>(<em>z</em>) = max (0, <em>z</em>)</span></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="keyword">return</span> np.maximum(<span class="number">0</span>, z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">activation = relu(<span class="number">2.3</span>)</span><br><span class="line">activation_neg = relu(-<span class="number">1.2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"ReLU(2.3) = <span class="subst">{activation}</span>, ReLU(-1.2) = <span class="subst">{activation_neg}</span>"</span>)</span><br><span class="line"><span class="comment"># ReLU(2.3) = 2.3, ReLU(-1.2) = 0.0</span></span><br></pre></td></tr></tbody></table></figure>
<p>ReLU
之所以受欢迎，是因为它在计算上很高效，并且在实践中能帮助网络更有效地学习。</p></li>
</ul>
<h3 id="矩阵运算">矩阵运算</h3>
<p>当神经网络变得很大时，逐个计算每个神经元的加权和会非常慢。幸运的是，我们可以使用线性代数中的矩阵运算来一次性完成一整层神经元的计算。</p>
<blockquote>
<p>注：下文所有涉及的 <code>@</code> 运算符为 Python 3.5+
的矩阵乘法（matmul），推荐用于神经网络等线性代数场景。<code>np.dot</code>
在一维时是内积，二维时是矩阵乘法，但 <code>@</code>
始终表示矩阵乘法，更直观。</p>
</blockquote>
<p>我们可以把：</p>
<ul>
<li>一层的输入激活值看作一个向量 <code>A</code>。</li>
<li>连接到下一层的所有权重组织成一个矩阵 <code>W</code>。</li>
<li>所有偏置组成一个向量 <code>B</code>。</li>
</ul>
<p>那么，下一层所有神经元的预激活值 <code>Z</code>
就可以通过一个简单的公式计算出来：</p>
<p><code>Z = A @ W + B</code></p>
<p>其中 <code>@</code> 代表矩阵乘法。</p>
<p>假设我们有一个包含 2 个样本的批次（batch），每个样本有 3 个特征（输入），我们要将其传入一个有 4 个神经元的隐藏层。</p>
<ul>
<li><code>A</code> (激活值矩阵) 的形状是 <code>(2, 3)</code></li>
<li><code>W</code> (权重矩阵) 的形状是 <code>(3, 4)</code></li>
<li><code>B</code> (偏置向量) 的形状是 <code>(1, 4)</code> (它会被广播到
<code>(2, 4)</code>)</li>
<li><code>Z</code> (输出预激活矩阵) 的形状将是 <code>(2, 4)</code></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">activations = np.array([[<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>], [<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>]])</span><br><span class="line">weights = np.random.rand(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"权重: "</span>, weights)</span><br><span class="line">biases = np.random.rand(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"偏置: "</span>, biases)</span><br><span class="line"></span><br><span class="line">Z = activations @ weights + biases</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Z 的形状:"</span>, Z.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Z 的值:\n"</span>, Z)</span><br><span class="line"><span class="comment"># 权重:  [[0.08746301 0.34148947 0.2321176  0.49574324]</span></span><br><span class="line"><span class="comment">#  [0.69313075 0.77251665 0.48220435 0.38541945]</span></span><br><span class="line"><span class="comment">#  [0.48551131 0.84943177 0.05167356 0.03890675]]</span></span><br><span class="line"><span class="comment"># 偏置:  [[0.05122642 0.2860902  0.75485931 0.75830747]]</span></span><br><span class="line"><span class="comment"># Z 的形状: (2, 4)</span></span><br><span class="line"><span class="comment"># Z 的值:</span></span><br><span class="line"><span class="comment">#  [[ 2.98148486  4.72090828  2.1064063   2.14160985]</span></span><br><span class="line"><span class="comment">#  [ 6.77980008 10.61122193  4.40439285  4.90181816]]</span></span><br></pre></td></tr></tbody></table></figure>
<p>这正是现代深度学习框架 (如 TensorFlow 和
PyTorch) 在底层所做的事情，它能极大地利用 GPU 的并行计算能力。</p>
<h4 id="深入理解偏置和广播-a-deeper-look-at-bias-and-broadcasting">深入理解偏置和广播
(A Deeper Look at Bias and Broadcasting)</h4>
<p>在上面 <a href="#矩阵运算">2.4</a> 节中，你可能会问：“为什么偏置
<code>B</code> 的形状是 <code>(1, 4)</code>，却能和形状为
<code>(2, 4)</code> 的矩阵 <code>A · W</code> 相加呢？”</p>
<p>这要归功于 NumPy 的一个强大特性：<strong>广播
(Broadcasting)</strong>。</p>
<p>我们的隐藏层有 4 个神经元，所以我们有 4 个对应的偏置值（存储在
<code>B</code> 中）。当我们一次性处理一个包含 2 个样本的批次
(batch) 时，这 4 个偏置值需要被分别应用到<strong>每一个</strong>样本的计算结果上。当
NumPy 看到你要将一个 <code>(2, 4)</code> 矩阵和一个 <code>(1, 4)</code>
向量相加时，它会自动将这个 <code>(1, 4)</code>
的行向量 “拉伸” 或 “复制” 成一个 <code>(2, 4)</code>
的矩阵，使其形状匹配，然后再执行元素间的加法。NumPy
并不会真的创建这个大矩阵的副本，而是通过一种更巧妙的内部机制来完成计算，节省了大量内存和计算时间。</p>
<p>简单来说，广播机制让我们能用简洁的代码，将同一组偏置高效地应用到一批数据中的所有样本上。</p>
<p>我们可以通过一个具体的代码示例来观察广播是如何工作的:</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A_dot_W = np.array([[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>], [<span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>]])</span><br><span class="line"></span><br><span class="line">B = np.array([[<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"A · W 的形状:"</span>, A_dot_W.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"B 的形状:"</span>, B.shape)</span><br><span class="line"></span><br><span class="line">Z = A_dot_W + B</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n--- 执行 A_dot_W + B ---"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"在广播后，B 表现得像下面这个 (2, 4) 的矩阵:"</span>)</span><br><span class="line"></span><br><span class="line">broadcasted_B_for_demo = np.tile(B, (<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(broadcasted_B_for_demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n最终结果 Z 的形状:"</span>, Z.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"最终结果 Z 的值:\n"</span>, Z)</span><br><span class="line"><span class="comment"># A · W 的形状: (2, 4)</span></span><br><span class="line"><span class="comment"># B 的形状: (1, 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 执行 A_dot_W + B ---</span></span><br><span class="line"><span class="comment"># 在广播后，B 表现得像下面这个 (2, 4) 的矩阵:</span></span><br><span class="line"><span class="comment"># [[0.1 0.2 0.3 0.4]</span></span><br><span class="line"><span class="comment">#  [0.1 0.2 0.3 0.4]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终结果 Z 的形状: (2, 4)</span></span><br><span class="line"><span class="comment"># 最终结果 Z 的值:</span></span><br><span class="line"><span class="comment">#  [[10.1 20.2 30.3 40.4]</span></span><br><span class="line"><span class="comment">#  [50.1 60.2 70.3 80.4]]</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们可以清晰地看到 <code>B</code> 是如何被 “拉伸” 以匹配
<code>A_dot_W</code> 的形状，从而完成加法运算的。</p>
<img src="/Machine-learning/36604/6-matrices1.png" class="" title="matrices1">
<img src="/Machine-learning/36604/7-matrices2.png" class="" title="matrices2">
<h2 id="训练过程">训练过程</h2>
<p>我们已经知道数据是如何在网络中流动的 (前向传播)，但网络是如何 “学习”
—— 也就是如何找到正确的权重和偏置的呢？这个过程叫做<strong>训练
(Training)</strong>。</p>
<p>训练就像一个反馈循环：</p>
<ul>
<li><strong>预测</strong>：让网络根据当前的权重和偏置进行一次前向传播，得到一个预测结果。</li>
<li><strong>评估</strong>：将预测结果与真实的答案进行比较，计算出 “误差” 有多大。</li>
<li><strong>学习</strong>：根据误差，反向调整网络中的所有权重和偏置，目标是让下一次的误差变得更小。</li>
</ul>
<h3 id="损失函数">损失函数</h3>
<p>为了评估网络的表现，我们需要一个<strong>损失函数 (Loss
Function)</strong>。这会量化预测值和真实值之间的差距。</p>
<p>一个常用的损失函数是<strong>均方误差 (Mean Squared Error,
MSE)</strong>：</p>
<ul>
<li>计算每个输出神经元的预测值与真实值之差。</li>
<li>将这个差值平方（这样可以确保结果是正数，并且对较大的误差给予更大的 “惩罚”）。</li>
<li>将所有输出神经元的平方差加起来，并取平均值。</li>
</ul>
<p>即 <code>loss = mean((pred - true)²)</code></p>
<p>其数学公式为 (<span class="math inline"><em>k</em></span>
是输出神经元的数量):</p>
<p><span class="math display">$$ C = \frac{1}{m} \sum_{i=1}^{m}
\sum_{j=1}^{k} (y_{pred, ij} - y_{true, ij})^2 $$</span></p>
<p>用代码实现： </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">y_true = np.array([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">y_pred = np.array([[<span class="number">0.1</span>, <span class="number">0.9</span>], [<span class="number">0.8</span>, <span class="number">0.2</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mse_loss</span>(<span class="params">y_true, y_pred</span>):</span><br><span class="line">    <span class="keyword">return</span> np.mean((y_pred - y_true) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loss = mse_loss(y_true, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"loss = "</span>, loss)</span><br><span class="line"><span class="comment"># loss = 0.024999999999999994</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>我们的目标就是通过调整权重和偏置，让这个损失值<strong>尽可能小</strong>。</p>
<blockquote>
<p>实际上，对于分类任务，更常用的是 softmax
激活配合交叉熵损失（cross-entropy loss）。这里以 MSE
为例只是因为演示方便，后续章节会详细介绍分类场景的常用方法。</p>
</blockquote>
<img src="/Machine-learning/36604/8-cost.png" class="" title="cost">
<h3 id="梯度下降">梯度下降</h3>
<p>想象一下，你正站在一座大山 (损失函数)
上，蒙着眼睛，你的目标是走到山谷的最低点 (最小损失)。你会怎么做？
你可能会伸出脚，感受一下哪个方向是下坡最陡峭的，然后朝那个方向迈一小步。重复这个过程，你最终会到达谷底。</p>
<p>这就是<strong>梯度下降 (Gradient
Descent)</strong> 算法的核心思想。</p>
<ul>
<li><strong>梯度
(Gradient)</strong> 在数学上指向了函数值增长最快的方向 (也就是上坡最陡的方向)。</li>
<li>因此，我们只需要沿着<strong>负梯度</strong> (梯度的反方向) 前进，就能最快地降低损失值。
<img src="/Machine-learning/36604/9-gradientDescent.png" class="" title="gradientDescent"></li>
</ul>
<p>我们还需要一个<strong>学习率 (Learning
Rate)</strong>，它决定了我们沿着下坡方向 “迈出的步子有多大”。</p>
<ul>
<li><strong>学习率太小</strong>：下山速度会非常慢。</li>
<li><strong>学习率太大</strong>：我们可能会在谷底来回 “跨过”，永远无法到达最低点。</li>
</ul>
<p>选择一个合适的学习率是训练神经网络中的一个重要技巧。</p>
<p>参数更新的规则可以表示为： <span class="math display">$$ w_{new} =
w_{old} - \eta \frac{\partial C}{\partial w} $$</span> 其中
<code>η</code> 是学习率，<code>∂C/∂w</code> 是损失对权重 <code>w</code>
的梯度。</p>
<h3 id="反向传播">反向传播</h3>
<p>梯度下降告诉了我们要下山，但没有告诉我们网络中成千上万个权重和偏置具体要如何改变才能实现下山。</p>
<p><strong>反向传播
(Backpropagation)</strong> 就是解决这个问题的算法。它的核心思想是 “分配责任”。</p>
<p>在一次预测后，我们得到了总的误差。反向传播会从输出层开始，反向地通过网络，计算出每个权重和偏置对这个总误差 “贡献” 了多少责任。</p>
<h4 id="单个权重的的链式法则责任推导">单个权重的的链式法则责任推导</h4>
<p>这个过程依赖于微积分中的<strong>链式法则</strong>。我们想知道改变一个权重
<code>w</code> 会如何影响最终的损失 <code>C</code> (即梯度
<code>∂C/∂w</code>)。这个梯度可以被分解为几个部分的乘积：</p>
<p><span class="math display">$$ \frac{\partial C}{\partial w} =
\frac{\partial C}{\partial a} \times \frac{\partial a}{\partial z}
\times \frac{\partial z}{\partial w} $$</span></p>
<p>下面我们将拆解这个公式，把它想象成一个 “责任追踪” 的过程。我们的目标
<code>∂C/∂w</code> 是要算出权重 <code>w</code> 应该为最终的误差
<code>C</code> 负多少责任。</p>
<p>链式法则告诉我们，这个总责任可以分解为一连串局部责任的乘积：</p>
<ol type="1">
<li><strong><code>∂z/∂w</code>：权重 <code>w</code> 对神经元输入
<code>z</code> 的责任。</strong>
<ul>
<li>回顾公式 <code>z = w * a_prev + ...</code>，<code>w</code>
的影响大小，完全取决于它所乘的那个输入值 <code>a_prev</code>。如果
<code>a_prev</code> 很大，<code>w</code> 的一点小变化就会被放大；如果
<code>a_prev</code> 是 0，<code>w</code> 再怎么变也影响不了
<code>z</code>。<strong>所以，这部分的责任就是
<code>a_prev</code>。</strong></li>
</ul></li>
<li><strong><code>∂a/∂z</code>：神经元输入 <code>z</code> 对其输出
<code>a</code> 的责任。</strong>
<ul>
<li>对于 ReLU 函数，如果 <code>z</code> 本来就大于 0，那 <code>z</code>
的变化会直接通过，责任是 1。如果 <code>z</code> 小于等于 0，那
<code>z</code> 再怎么变，输出 <code>a</code>
都是 0，没有变化，那么责任是 0。<strong>所以，这部分的责任是激活函数的导数，它决定了梯度能否继续向后流动。</strong></li>
</ul></li>
<li><strong><code>∂C/∂a</code>：神经元输出 <code>a</code> 对最终总误差
<code>C</code> 的责任。</strong>
<ul>
<li>这是最关键的一步，也是 “反向传播” 中 “传播” 的体现。一个神经元的输出
<code>a</code>
会影响到下一层所有与它相连的神经元，进而通过整个网络，最终影响到总误差
<code>C</code>。我们无法直接计算这个责任。<strong>所以，这个责任值必须从下一层 “传播” 回来。</strong>
它代表了所有来自 “前方”（更靠近输出层）的误差信号汇集到 <code>a</code>
这一点上的总和。</li>
</ul></li>
</ol>
<p>综上，为了计算一个权重的梯度（<code>∂C/∂w</code>），我们把这三份 “责任” 相乘：(来自前一层的输入
<code>a_prev</code>) × (激活函数的导数) ×
(从后一层传回来的误差)。这就是反向传播的核心计算。</p>
<h4 id="多层神经网络的链式法则责任传递">多层神经网络的链式法则责任传递</h4>
<p>上述推导是针对单个权重的梯度，便于理解本质。而在实际代码实现中，一般用矩阵运算一次性计算整层的所有权重和偏置的梯度，这样程序的运算效率更高。代码中的
<code>dC_da</code>、<code>da_dz</code>、<code>dC_dz</code>、<code>dC_dw</code>、<code>dC_db</code>、<code>dC_da_prev</code>
等变量，都是批量（矩阵 / 向量）形式的 “责任” 传递，和理论推导一一对应，只是用矩阵方式高效实现。</p>
<p>在多层神经网络中，反向传播的 “责任” 会一层层传递。我们以第 <span class="math inline"><em>l</em></span> 层为例，假设：</p>
<ul>
<li><span class="math inline"><em>a</em><sup>[<em>l</em>]</sup></span>：第 <span class="math inline"><em>l</em></span> 层的输出（激活值）</li>
<li><span class="math inline"><em>z</em><sup>[<em>l</em>]</sup></span>：第 <span class="math inline"><em>l</em></span> 层的加权和</li>
<li><span class="math inline"><em>W</em><sup>[<em>l</em>]</sup></span>、<span class="math inline"><em>b</em><sup>[<em>l</em>]</sup></span>：第 <span class="math inline"><em>l</em></span> 层的权重和偏置</li>
</ul>
<p>前向传播： <span class="math display">$$
\begin{align}
z^{[l]} &amp;= W^{[l]} a^{[l-1]} + b^{[l]} \\
a^{[l]} &amp;= f(z^{[l]})
\end{align}
$$</span></p>
<p>反向传播：</p>
<p>第一个 “误差信号” <span class="math inline">$\frac{\partial
C}{\partial
a^{[L]}}$</span>（损失对输出层激活的梯度）是直接由损失函数和真实标签计算得到。例如对于均方误差（MSE）损失
<span class="math inline">$C = \frac{1}{2}(a^{[L]} - y)^2$</span>，有
<span class="math inline">$\frac{\partial C}{\partial a^{[L]}} = a^{[L]}
- y$</span>。</p>
<p>“真实标签” 指的是训练数据中每个样本的正确答案，也叫 “目标值” 或 “ground
truth”。比如：</p>
<ul>
<li>图像分类任务中，真实标签就是图片实际对应的类别（如 “猫” 或 “狗”）。</li>
<li>回归任务中，真实标签就是希望模型预测出来的那个数值。</li>
</ul>
<p>在反向传播时，假设我们已经得到了 <span class="math inline">$\frac{\partial C}{\partial
a^{[l]}}$</span>，则：</p>
<ol type="1">
<li><p>计算 <span class="math inline">$\frac{\partial C}{\partial
z^{[l]}}$</span>。其中，符号 <span class="math inline">⊙</span>
表示逐元素乘法： <span class="math display">$$
\delta^{[l]} = \frac{\partial C}{\partial z^{[l]}} = \frac{\partial
C}{\partial a^{[l]}} \odot f'(z^{[l]})
$$</span></p></li>
<li><p>计算本层参数的梯度，这里的 <span class="math inline"><em>m</em></span> 是 batch size： <span class="math display">$$
\begin{align}
\frac{\partial C}{\partial W^{[l]}} &amp;= \delta^{[l]} (a^{[l-1]})^T \\
\frac{\partial C}{\partial b^{[l]}} &amp;= \sum_{i=1}^m \delta^{[l]}_i
\end{align}
$$</span></p></li>
<li><p>计算传递给前一层的 “责任”： <span class="math display">$$
\frac{\partial C}{\partial a^{[l-1]}} = (W^{[l]})^T \delta^{[l]}
$$</span></p></li>
</ol>
<p>这样，误差信号 <span class="math inline"><em>δ</em></span>
就一层层地传递回去。</p>
<img src="/Machine-learning/36604/10-backpropagation.png" class="" title="backpropagation">
<p><strong>变量对应关系</strong>：</p>
<table>
<colgroup>
<col style="width: 39%">
<col style="width: 19%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">公式符号</th>
<th style="text-align: left;">代码变量名</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">$\frac{\partial
C}{\partial a^{[l]}}$</span></td>
<td style="text-align: left;"><code>dC_da</code></td>
<td style="text-align: left;">损失对本层激活的梯度 (来自 <span class="math inline"><em>l</em> + 1</span> 层)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline"><em>f</em>′(<em>z</em><sup>[<em>l</em>]</sup>)</span></td>
<td style="text-align: left;"><code>da_dz</code></td>
<td style="text-align: left;">激活函数对加权和的导数</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline"><em>δ</em><sup>[<em>l</em>]</sup></span></td>
<td style="text-align: left;"><code>dC_dz</code></td>
<td style="text-align: left;">损失对本层加权和的梯度</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">$\frac{\partial
C}{\partial W^{[l]}}$</span></td>
<td style="text-align: left;"><code>dC_dw</code></td>
<td style="text-align: left;">损失对本层权重的梯度</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">$\frac{\partial
C}{\partial b^{[l]}}$</span></td>
<td style="text-align: left;"><code>dC_db</code></td>
<td style="text-align: left;">损失对本层偏置的梯度</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">$\frac{\partial
C}{\partial a^{[l-1]}}$</span></td>
<td style="text-align: left;"><code>dC_da_prev</code></td>
<td style="text-align: left;">损失对前一层激活的梯度 (传递回 <span class="math inline"><em>l</em> − 1</span> 层)</td>
</tr>
</tbody>
</table>
<p>下面的代码段详细解释了每个变量的含义和它与理论公式的对应关系。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dC_da, learning_rate</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    执行反向传播，计算并应用梯度。</span></span><br><span class="line"><span class="string">    dC_da: 损失函数对本神经元输出 a 的梯度 (从下一层传来)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1. 计算 da/dz (激活函数对z的梯度)</span></span><br><span class="line">    <span class="comment"># 对应链式法则中的 ∂a/∂z，形状与 z 相同</span></span><br><span class="line">    da_dz = <span class="variable language_">self</span>.relu_derivative(<span class="variable language_">self</span>.last_z)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 计算 dC/dz (损失对z的梯度) = dC/da * da/dz</span></span><br><span class="line">    <span class="comment"># 对应链式法则中的 ∂C/∂a × ∂a/∂z，形状与 z 相同</span></span><br><span class="line">    dC_dz = dC_da * da_dz</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 计算 dC/dw (损失对权重的梯度) = dC/dz * dz/dw</span></span><br><span class="line">    <span class="comment"># dz/dw = a_prev，dC/dw = a_prev.T @ dC/dz</span></span><br><span class="line">    <span class="comment"># 这里 a_prev 是输入，dC/dz 是“误差信号”，矩阵乘法一次性算出所有权重的梯度</span></span><br><span class="line">    dC_dw = <span class="variable language_">self</span>.last_input.T @ dC_dz</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 计算 dC/db (损失对偏置的梯度) = dC/dz * dz/db</span></span><br><span class="line">    <span class="comment"># dz/db = 1，dC/db = sum(dC/dz)</span></span><br><span class="line">    dC_db = np.<span class="built_in">sum</span>(dC_dz, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 计算 dC/da_prev (损失对前一层激活值的梯度)，用于传给前一层</span></span><br><span class="line">    <span class="comment"># dC/da_prev = dC/dz * dz/da_prev，dz/da_prev = weights</span></span><br><span class="line">    dC_da_prev = dC_dz @ <span class="variable language_">self</span>.weights.T</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6. 根据梯度更新权重和偏置</span></span><br><span class="line">    <span class="variable language_">self</span>.weights -= learning_rate * dC_dw</span><br><span class="line">    <span class="variable language_">self</span>.bias -= learning_rate * dC_db</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回 dC/da_prev，传递给前一层继续反向传播</span></span><br><span class="line">    <span class="keyword">return</span> dC_da_prev</span><br></pre></td></tr></tbody></table></figure>
<h3 id="总结训练循环">总结训练循环</h3>
<p>于是，我们可以完整地描述训练过程了，这个过程会重复很多次 (称为
<strong>Epochs</strong>):</p>
<ol type="1">
<li><strong>前向传播</strong>：将一批训练数据输入网络，计算出预测值。</li>
<li><strong>计算损失</strong>：使用损失函数，比较预测值和真实值，得到损失。</li>
<li><strong>反向传播</strong>：从损失出发，反向计算出网络中每个权重和偏置的梯度。</li>
<li><strong>更新参数</strong>：使用梯度下降，根据梯度和学习率，对所有权重和偏置进行一次微小的更新。</li>
</ol>
<p>经过成千上万次的迭代，网络的权重和偏置会逐渐收敛到一组能够很好地完成任务的值。网络就 “学会” 了辨认猫猫。</p>
<h2 id="一个简单的-python-实现">一个简单的 Python 实现</h2>
<p>下面是一个用 Python 和 NumPy 从零开始实现的简单神经网络。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Neuron</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    单个神经元。管理自己的权重、偏置，并执行前向和后向计算。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_inputs</span>):</span><br><span class="line">        <span class="comment"># 随机初始化权重，乘以一个小数以防止初始值过大</span></span><br><span class="line">        <span class="variable language_">self</span>.weights = np.random.randn(num_inputs, <span class="number">1</span>) * <span class="number">0.01</span></span><br><span class="line">        <span class="comment"># 初始化偏置为0</span></span><br><span class="line">        <span class="variable language_">self</span>.bias = np.zeros((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 存储计算过程中的中间值，用于反向传播</span></span><br><span class="line">        <span class="variable language_">self</span>.last_input = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.last_z = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="string">"""ReLU 激活函数"""</span></span><br><span class="line">        <span class="keyword">return</span> np.maximum(<span class="number">0</span>, z)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">relu_derivative</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="string">"""ReLU 激活函数的导数"""</span></span><br><span class="line">        <span class="keyword">return</span> np.where(z &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, activations</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行前向传播：z = a @ w + b, a_out = relu(z)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="variable language_">self</span>.last_input = activations</span><br><span class="line">        <span class="comment"># 计算加权和 z</span></span><br><span class="line">        z = activations @ <span class="variable language_">self</span>.weights + <span class="variable language_">self</span>.bias</span><br><span class="line">        <span class="variable language_">self</span>.last_z = z</span><br><span class="line">        <span class="comment"># 应用激活函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.relu(z)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dC_da, learning_rate</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行反向传播，计算并应用梯度。</span></span><br><span class="line"><span class="string">        dC_da: 损失函数对本神经元输出 a 的梯度 (从下一层传来)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 1. 计算 da/dz (激活函数对z的梯度)</span></span><br><span class="line">        <span class="comment"># 对应链式法则中的 ∂a/∂z，形状与 z 相同</span></span><br><span class="line">        da_dz = <span class="variable language_">self</span>.relu_derivative(<span class="variable language_">self</span>.last_z)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 计算 dC/dz (损失对z的梯度) = dC/da * da/dz</span></span><br><span class="line">        <span class="comment"># 对应链式法则中的 ∂C/∂a × ∂a/∂z，形状与 z 相同</span></span><br><span class="line">        dC_dz = dC_da * da_dz</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 计算 dC/dw (损失对权重的梯度) = dC/dz * dz/dw</span></span><br><span class="line">        <span class="comment"># dz/dw = a_prev，dC/dw = a_prev.T @ dC/dz</span></span><br><span class="line">        <span class="comment"># 这里 a_prev 是输入，dC/dz 是“误差信号”，矩阵乘法一次性算出所有权重的梯度</span></span><br><span class="line">        dC_dw = <span class="variable language_">self</span>.last_input.T @ dC_dz</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 计算 dC/db (损失对偏置的梯度) = dC/dz * dz/db</span></span><br><span class="line">        <span class="comment"># dz/db = 1，dC/db = sum(dC/dz)</span></span><br><span class="line">        dC_db = np.<span class="built_in">sum</span>(dC_dz, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 计算 dC/da_prev (损失对前一层激活值的梯度)，用于传给前一层</span></span><br><span class="line">        <span class="comment"># dC/da_prev = dC/dz * dz/da_prev，dz/da_prev = weights</span></span><br><span class="line">        dC_da_prev = dC_dz @ <span class="variable language_">self</span>.weights.T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 6. 根据梯度更新权重和偏置</span></span><br><span class="line">        <span class="variable language_">self</span>.weights -= learning_rate * dC_dw</span><br><span class="line">        <span class="variable language_">self</span>.bias -= learning_rate * dC_db</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回 dC/da_prev，传递给前一层继续反向传播</span></span><br><span class="line">        <span class="keyword">return</span> dC_da_prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    一层神经元。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_neurons, num_inputs_per_neuron</span>):</span><br><span class="line">        <span class="variable language_">self</span>.neurons = [Neuron(num_inputs_per_neuron) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_neurons)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, activations</span>):</span><br><span class="line">        <span class="string">"""对层中所有神经元执行前向传播"""</span></span><br><span class="line">        <span class="comment"># hstack 用于水平堆叠输出，形成一个 (batch_size, num_neurons) 的矩阵</span></span><br><span class="line">        <span class="keyword">return</span> np.hstack([neuron.forward(activations) <span class="keyword">for</span> neuron <span class="keyword">in</span> <span class="variable language_">self</span>.neurons])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dC_da, learning_rate</span>):</span><br><span class="line">        <span class="string">"""对层中所有神经元执行反向传播"""</span></span><br><span class="line">        <span class="comment"># dC_da 的形状是 (batch_size, num_neurons)</span></span><br><span class="line">        <span class="comment"># 我们需要为每个神经元传入对应的梯度 dC_da[:, [i]]</span></span><br><span class="line">        <span class="comment"># 然后将所有神经元返回的 dC/da_prev 相加，得到传给前一层的总梯度</span></span><br><span class="line">        <span class="keyword">return</span> np.<span class="built_in">sum</span>(</span><br><span class="line">            [</span><br><span class="line">                neuron.backward(dC_da[:, [i]], learning_rate)</span><br><span class="line">                <span class="keyword">for</span> i, neuron <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.neurons)</span><br><span class="line">            ],</span><br><span class="line">            axis=<span class="number">0</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    完整的神经网络模型。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, layer_sizes</span>):</span><br><span class="line">        <span class="comment"># layer_sizes 是一个列表，例如 [784, 128, 10]</span></span><br><span class="line">        <span class="comment"># 表示输入层784个节点，隐藏层128个，输出层10个</span></span><br><span class="line">        <span class="variable language_">self</span>.layers = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(layer_sizes) - <span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.layers.append(Layer(layer_sizes[i + <span class="number">1</span>], layer_sizes[i]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, activations</span>):</span><br><span class="line">        <span class="string">"""对所有层执行前向传播"""</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="variable language_">self</span>.layers:</span><br><span class="line">            activations = layer.forward(activations)</span><br><span class="line">        <span class="keyword">return</span> activations</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mse_loss</span>(<span class="params">self, y_true, y_pred</span>):</span><br><span class="line">        <span class="string">"""均方误差损失函数"""</span></span><br><span class="line">        <span class="keyword">return</span> np.mean((y_pred - y_true) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">derivative_mse_loss</span>(<span class="params">self, y_true, y_pred</span>):</span><br><span class="line">        <span class="string">"""均方误差损失函数的导数"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (y_pred - y_true) / y_true.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, X, y, epochs, learning_rate, batch_size=<span class="number">32</span></span>):</span><br><span class="line">        <span class="string">"""训练神经网络"""</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">            total_loss = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 使用小批量梯度下降</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(X), batch_size):</span><br><span class="line">                X_batch = X[i : i + batch_size]</span><br><span class="line">                y_batch = y[i : i + batch_size]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 1. 前向传播</span></span><br><span class="line">                outputs = <span class="variable language_">self</span>.forward(X_batch)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 2. 计算损失</span></span><br><span class="line">                loss = <span class="variable language_">self</span>.mse_loss(y_batch, outputs)</span><br><span class="line">                total_loss += loss * <span class="built_in">len</span>(X_batch)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 3. 计算输出层的梯度</span></span><br><span class="line">                output_gradient = <span class="variable language_">self</span>.derivative_mse_loss(y_batch, outputs)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 4. 反向传播</span></span><br><span class="line">                <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="variable language_">self</span>.layers):</span><br><span class="line">                    output_gradient = layer.backward(output_gradient, learning_rate)</span><br><span class="line"></span><br><span class="line">            avg_loss = total_loss / <span class="built_in">len</span>(X)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f"Epoch <span class="subst">{epoch+<span class="number">1</span>}</span>/<span class="subst">{epochs}</span>, Loss: <span class="subst">{avg_loss:<span class="number">.6</span>f}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="string">"""用训练好的网络进行预测"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.forward(X)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>Ian Goodfellow, Yoshua Bengio, Aaron Courville. <a href="https://www.deeplearningbook.org/">Deep Learning</a></li>
<li><a href="https://github.com/DorsaRoh/Machine-Learning">Machine
learning - DorsaRoh</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>NN</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的神经网络学习 (二)：实用技巧与进阶</title>
    <url>/Machine-learning/38196.html</url>
    <content><![CDATA[<p>在<a href="https://0wnerdied.github.io/Machine-learning/36604.html">上一篇文章</a>中，我们从零开始构建了一个简单的神经网络，并理解了前向传播、反向传播和梯度下降等核心概念。然而，要让神经网络在现实世界的问题中高效工作，我们还需要掌握更多的工具和技巧。</p>
<p>这篇文章将作为第二部分，专注于第一部分中未能详尽涵盖的几个关键领域：</p>
<ul>
<li>我将用上一篇文章中的代码来训练一个网络，解决一个经典问题，并观察损失函数的变化。</li>
<li>除了 ReLU，我还将介绍 Sigmoid 和 Tanh
等其他常用激活函数，并讨论如何为输出层选择合适的激活函数。</li>
<li>探讨权重初始化的重要性，并介绍批量归一化 (Batch Normalization) 和
Dropout 等强大的技术。</li>
<li>最后，分享一些关于调试神经网络和选择超参数的实用技巧。</li>
</ul>
<h2 id="训练一个-xor-网络">训练一个 XOR 网络</h2>
<p>理论需要实践来检验。让我们使用上一篇文章中定义的
<code>NeuralNetwork</code> 类来解决经典的 XOR 问题。XOR
是一个非线性问题，单个神经元无法解决，因此很适合作为我们神经网络的测试案例。</p>
<p>XOR 的真值表如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">输入 A</th>
<th style="text-align: center;">输入 B</th>
<th style="text-align: center;">输出</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<h3 id="准备数据和网络">准备数据和网络</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># existing codes...</span></span><br><span class="line">            avg_loss = total_loss / <span class="built_in">len</span>(X)</span><br><span class="line">            <span class="comment"># 只在每1/10进度时输出一次</span></span><br><span class="line">            <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="built_in">max</span>(<span class="number">1</span>, epochs // <span class="number">10</span>) == <span class="number">0</span> <span class="keyword">or</span> epoch == <span class="number">0</span> <span class="keyword">or</span> epoch == epochs - <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"Epoch <span class="subst">{epoch+<span class="number">1</span>}</span>/<span class="subst">{epochs}</span>, Loss: <span class="subst">{avg_loss:<span class="number">.6</span>f}</span>"</span>)</span><br><span class="line"><span class="comment"># existing codes...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 定义 XOR 数据集</span></span><br><span class="line">X_train = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">y_train = np.array([[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建神经网络实例</span></span><br><span class="line"><span class="comment"># 2个输入节点，一个有2个节点的隐藏层，1个输出节点</span></span><br><span class="line">nn = NeuralNetwork([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure>
<h3 id="训练并观察损失">训练并观察损失</h3>
<p>我们将使用较小的学习率和足够多的迭代次数来训练网络。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 3. 训练网络</span></span><br><span class="line"><span class="comment"># XOR 是一个非线性问题，需要足够的迭代次数和合适的学习率</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"开始训练XOR网络..."</span>)</span><br><span class="line">nn.train(X_train, y_train, epochs=<span class="number">10000</span>, learning_rate=<span class="number">0.005</span>, batch_size=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"训练完成。"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练XOR网络...</span></span><br><span class="line"><span class="comment"># Epoch 1/10000, Loss: 0.499970</span></span><br><span class="line"><span class="comment"># Epoch 1000/10000, Loss: 0.249839</span></span><br><span class="line"><span class="comment"># Epoch 2000/10000, Loss: 0.249042</span></span><br><span class="line"><span class="comment"># Epoch 3000/10000, Loss: 0.244619</span></span><br><span class="line"><span class="comment"># Epoch 4000/10000, Loss: 0.224387</span></span><br><span class="line"><span class="comment"># Epoch 5000/10000, Loss: 0.177830</span></span><br><span class="line"><span class="comment"># Epoch 6000/10000, Loss: 0.113382</span></span><br><span class="line"><span class="comment"># Epoch 7000/10000, Loss: 0.023213</span></span><br><span class="line"><span class="comment"># Epoch 8000/10000, Loss: 0.001769</span></span><br><span class="line"><span class="comment"># Epoch 9000/10000, Loss: 0.000104</span></span><br><span class="line"><span class="comment"># Epoch 10000/10000, Loss: 0.000006</span></span><br><span class="line"><span class="comment"># 训练完成。</span></span><br></pre></td></tr></tbody></table></figure>
<p>正如我们所见，损失 (Loss)
随着训练的进行而稳步下降，这表明我们的网络确实在学习如何解决 XOR
问题。</p>
<h3 id="查看结果">查看结果</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 4. 进行预测并展示结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n对输入进行预测:"</span>)</span><br><span class="line"><span class="keyword">for</span> x_input <span class="keyword">in</span> X_train:</span><br><span class="line">    prediction = nn.predict(x_input.reshape(<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"输入: <span class="subst">{x_input}</span>, 预测输出: <span class="subst">{prediction[<span class="number">0</span>][<span class="number">0</span>]:<span class="number">.4</span>f}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对输入进行预测:</span></span><br><span class="line"><span class="comment"># 输入: [0 0], 预测输出: 0.0027</span></span><br><span class="line"><span class="comment"># 输入: [0 1], 预测输出: 0.9981</span></span><br><span class="line"><span class="comment"># 输入: [1 0], 预测输出: 0.9981</span></span><br><span class="line"><span class="comment"># 输入: [1 1], 预测输出: 0.0028</span></span><br></pre></td></tr></tbody></table></figure>
<p><del>预测值非常接近真实值，证明这个简单的神经网络框架是有效的。</del>
其实这个结果是我精挑细选，训练了很多很多次才得到的成功预测结果，训练其实是有随机性的，上面的代码在我本地测试中成功率非常低，训练十次都不一定能有一次成功，极大概率会训练失败，可以说这是一个失败的网络实现。这时就要调整参数或者更换合适的激活函数。</p>
<h2 id="其它的激活函数">其它的激活函数</h2>
<p>前面我们只介绍了
ReLU。虽然它非常流行且有效，但了解其他激活函数以及如何为输出层做选择也同样重要。</p>
<h3 id="sigmoid">Sigmoid</h3>
<p>Sigmoid 函数将任意实数压缩到 (0, 1)
区间内，所以它很适合用来表示概率。</p>
<ul>
<li><p><strong>公式</strong>: <span class="math display">$$ \sigma(z) =
\frac{1}{1 + e^{-z}} $$</span></p></li>
<li><p><strong>Python 实现</strong>: </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sigmoid(np.array([-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>])))</span><br><span class="line"><span class="comment"># [0.11920292 0.5        0.88079708]</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><strong>优点</strong>: 输出在 (0, 1)
之间，平滑且易于求导。</p></li>
<li><p><strong>缺点</strong>:</p>
<ul>
<li><strong>梯度消失</strong>:
当输入非常大或非常小时，函数的导数趋近于 0，导致梯度在反向传播时消失，使网络难以训练。</li>
<li><strong>输出不以 0 为中心</strong>:
输出总是正数，这可能导致后续层权重更新时朝同一个方向移动，降低收敛速度。</li>
</ul></li>
</ul>
<h3 id="tanh-双曲正切">Tanh (双曲正切)</h3>
<p>Tanh 函数会将输入压缩到 (-1, 1) 区间。</p>
<ul>
<li><p><strong>公式</strong>: <span class="math display">$$ tanh(z) =
\frac{e^z - e^{-z}}{e^z + e^{-z}} $$</span></p></li>
<li><p><strong>Python 实现</strong>: </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">z</span>):</span><br><span class="line">    <span class="keyword">return</span> np.tanh(z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tanh(np.array([-<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>])))</span><br><span class="line"><span class="comment"># [-0.96402758  0.          0.96402758]</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><strong>优点</strong>:</p>
<ul>
<li><strong>以 0 为中心</strong>: 输出在 -1 和 1 之间，解决了 Sigmoid
的一个主要缺点。</li>
<li>通常比 Sigmoid 收敛更快。</li>
</ul></li>
<li><p><strong>缺点</strong>: 仍然存在梯度消失的问题。</p></li>
</ul>
<h3 id="如何为输出层选择激活函数">如何为输出层选择激活函数？</h3>
<p>输出层的激活函数选择至关重要，因为它决定了网络输出的格式。</p>
<ul>
<li><p><strong>二元分类 (Binary Classification)</strong>:
当你预测两个类别之一时（例如，是猫 / 不是猫），使用
<strong>Sigmoid</strong>
函数。它输出一个 0 到 1 之间的值，可以解释为属于正类的概率。</p></li>
<li><p><strong>多元分类 (Multi-class Classification)</strong>:
当你在多个类别中选择一个时（例如，数字识别 0-9），使用
<strong>Softmax</strong>
函数。它能将一组数字转换成概率分布，所有输出的总和为 1。</p></li>
<li><p><strong>Softmax 实现</strong>: </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">z</span>):</span><br><span class="line">    exp_z = np.exp(z - np.<span class="built_in">max</span>(z, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line">    <span class="keyword">return</span> exp_z / np.<span class="built_in">sum</span>(exp_z, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(softmax(np.array([[<span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">0.1</span>]])))</span><br><span class="line"><span class="comment"># [[0.65900114 0.24243297 0.09856589]]</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><strong>回归 (Regression)</strong>:
当预测一个连续值时（例如，房价），输出层<strong>不使用任何激活函数</strong>。这样，网络就可以输出任意范围的数值。</p></li>
</ul>
<h2 id="优化与正则化技巧">优化与正则化技巧</h2>
<p>为了构建更强大、更稳定的神经网络，我们需要一些高级的优化和正则化技术。</p>
<h3 id="权重初始化的重要性">权重初始化的重要性</h3>
<p>我们在第一部分中用简单的 <code>np.random.randn() * 0.01</code>
来初始化权重。这虽然行得通，但不是最好的解决方案。糟糕的权重初始化可能导致梯度消失或梯度爆炸，即梯度在反向传播过程中变得过小或过大。</p>
<p>现代的初始化方法，如 <strong>Xavier (Glorot) 初始化</strong> 和
<strong>He
初始化</strong>，通过智能地根据上一层的神经元数量来调整初始权重的方差，从而确保信号在网络中更稳定地传播，显著加快训练速度并提高性能。</p>
<ul>
<li><p><strong>Xavier 初始化</strong>: 通常与 Sigmoid 或 Tanh
激活函数配合使用。</p></li>
<li><p><strong>He 初始化</strong>: 专为 ReLU
及其变体设计，是现代深度网络中的首选。</p></li>
<li><p><strong>Xavier / He 初始化示例</strong>: </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Xavier 初始化 (适合Sigmoid/Tanh)</span></span><br><span class="line">fan_in, fan_out = <span class="number">64</span>, <span class="number">32</span></span><br><span class="line">xavier = np.random.randn(fan_in, fan_out) * np.sqrt(<span class="number">1.0</span> / fan_in)</span><br><span class="line"><span class="comment"># He 初始化 (适合ReLU)</span></span><br><span class="line">he = np.random.randn(fan_in, fan_out) * np.sqrt(<span class="number">2.0</span> / fan_in)</span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ul>
<h3 id="批量归一化-batch-normalization">批量归一化 (Batch
Normalization)</h3>
<p>在每个小批量数据通过网络时，对每一层的输入进行归一化（调整为均值为 0，方差为 1），然后再进行缩放和平移。</p>
<p><strong>好处</strong>:</p>
<ul>
<li><p><strong>加速训练</strong>: 允许使用更高的学习率。</p></li>
<li><p><strong>稳定训练</strong>: 减少了对权重初始化的敏感度。</p></li>
<li><p><strong>轻微的正则化效果</strong>:
由于是在小批量上计算均值和方差，引入的噪声可以起到类似 Dropout
的效果。</p></li>
<li><p><strong>BatchNorm 示例</strong>: </p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">batch_norm</span>(<span class="params">x, gamma, beta, eps=<span class="number">1e-5</span></span>):</span><br><span class="line">    mu = np.mean(x, axis=<span class="number">0</span>)</span><br><span class="line">    var = np.var(x, axis=<span class="number">0</span>)</span><br><span class="line">    x_norm = (x - mu) / np.sqrt(var + eps)</span><br><span class="line">    <span class="keyword">return</span> gamma * x_norm + beta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># x: (batch_size, features)</span></span><br><span class="line"><span class="comment"># gamma/beta: 可学习参数，初始为1和0</span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ul>
<h3 id="dropout">Dropout</h3>
<p>Dropout
是一种简单而有效的正则化技术，用于防止网络过拟合。在训练过程中的每一步，它会以一定的概率
<code>p</code> 随机地 “丢弃” 网络中的一部分神经元。</p>
<p>这意味着网络不能依赖于任何一个特定的神经元，迫使它学习到更健壮、更冗余的特征表示。在测试时，所有神经元都会被使用，但它们的输出会按比例
<code>(1-p)</code> 缩小，以平衡训练时的丢弃行为。</p>
<ul>
<li><strong>Dropout 示例</strong>: <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dropout</span>(<span class="params">x, p</span>):</span><br><span class="line">    mask = (np.random.rand(*x.shape) &gt; p).astype(<span class="built_in">float</span>)</span><br><span class="line">    <span class="keyword">return</span> x * mask / (<span class="number">1</span> - p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练时: x = dropout(x, p=0.5)</span></span><br><span class="line"><span class="comment"># 推理时: 不用dropout</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="损失函数的选择">损失函数的选择</h2>
<p>在二元分类任务中，输出层通常用 sigmoid
激活，最合适的损失函数是<strong>二元交叉熵（Binary Cross Entropy,
BCE）</strong>，而不是均方误差（MSE）。</p>
<ul>
<li><p><strong>BCE 公式</strong>，其中 <span class="math inline"><em>y</em></span> 是真实标签（0 或 1），<span class="math inline"><em>p</em></span> 是 sigmoid 输出概率： <span class="math display"><em>L</em> = −[<em>y</em> ⋅ ln <em>p</em> + (1 − <em>y</em>) ⋅ ln (1 − <em>p</em>)]</span></p></li>
<li><p><strong>BCE 导数</strong>： <span class="math display">$$
\frac{\partial L}{\partial p} = -\frac{y}{p} + \frac{1-y}{1-p}
$$</span></p></li>
<li><p><strong>区别</strong>：</p>
<ul>
<li>MSE 在 sigmoid 饱和区间梯度更容易消失，收敛慢。</li>
<li>BCE 更适合概率输出，收敛快。</li>
</ul></li>
</ul>
<h2 id="建议">建议</h2>
<h3 id="调试神经网络的技巧">调试神经网络的技巧</h3>
<p>当神经网络不工作时，调试让人<del>心旷神怡</del>。下面是一些实用的检查步骤：</p>
<ol type="1">
<li>先用一个非常小的网络（例如一个隐藏层，少量神经元）来<strong>过拟合</strong>一小部分训练数据（例如，仅 10-20 个样本）。如果连这一步都做不到，说明模型结构或代码实现有根本性问题。</li>
</ol>
<ul>
<li><strong>过拟合小数据集</strong>: <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># X_small, y_small = 10个样本</span></span><br><span class="line">nn = NeuralNetwork([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">nn.train(X_small, y_small, epochs=<span class="number">5000</span>, learning_rate=<span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># 观察loss是否能降到极低</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<ol start="2" type="1">
<li><p>确保输入数据 <code>X</code> 和标签 <code>y</code>
是正确配对的。可以对数据进行可视化，检查是否存在异常值或错误。确保数据已经正确归一化。</p></li>
<li><p>一个太高的学习率是导致损失爆炸或不收敛的最常见原因。尝试将学习率降低一个数量级（例如从
<code>0.01</code> 到 <code>0.001</code>）。</p></li>
</ol>
<ul>
<li><strong>学习率调参</strong>: <figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> lr <span class="keyword">in</span> [<span class="number">0.1</span>, <span class="number">0.01</span>, <span class="number">0.001</span>]:</span><br><span class="line">    nn.train(X, y, epochs=<span class="number">1000</span>, learning_rate=lr)</span><br><span class="line">    <span class="comment"># 观察loss曲线</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<ol start="4" type="1">
<li>确保选择了正确的损失函数，并且在反向传播时正确计算了对应的导数。</li>
</ol>
<h3 id="超参数的选择">超参数的选择</h3>
<p>超参数是在训练开始前设置的参数，例如学习率、层数等。</p>
<ul>
<li><strong>学习率 (Learning Rate)</strong>:
学习率是最重要的超参数。通常从 <code>0.1</code>, <code>0.01</code>,
<code>0.001</code> 等值开始尝试。可以使用<strong>学习率衰减 (Learning
Rate Decay)</strong>，即在训练过程中逐渐降低学习率。</li>
<li><strong>网络架构 (层数和神经元数量)</strong>:
从一个隐藏层开始。如果网络无法很好地拟合训练数据，再逐步增加层的深度和 / 或宽度。通常，增加深度比增加宽度更有效。</li>
<li><strong>批量大小 (Batch Size)</strong>: 以前通常选择 2 的幂，如 32,
64, 128，但现在的说法是，随便选什么数都行。比如，你可以选 520
训练一个神经网络，送给你的对象（笑
<ul>
<li><strong>小批量</strong>: 训练速度快，引入的噪声可能有助于泛化。</li>
<li><strong>大批量</strong>:
梯度估计更准确，但可能陷入局部最小值，且需要更多内存。</li>
</ul></li>
<li><strong>优化器 (Optimizer)</strong>:
我们只讨论了基本的梯度下降。现代优化器如 <strong>Adam</strong>,
<strong>RMSprop</strong>
通常能提供更快的收敛速度和更好的性能，它们会自动调整学习率。在平常实践中，Adam
是一个非常好的默认选择。</li>
</ul>
<h2 id="优化-xor-网络">优化 XOR 网络</h2>
<p>相信看完上面的内容后，我们对神经网络有了更多的了解。现在对 XOR
网络的代码添加以下优化：</p>
<ul>
<li>Neuron 支持 tanh、sigmoid、relu 三种激活函数。</li>
<li>隐藏层用 tanh，输出层用 sigmoid。</li>
<li>权重初始化方式根据激活函数自动选择（tanh / sigmoid 用 Xavier，relu 用
He）。</li>
<li>训练和预测流程自动适配。</li>
</ul>
<p>下面是优化后的 XOR 神经网络训练完整代码：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Neuron</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    单个神经元。支持多种激活函数。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_inputs, activation=<span class="string">"relu"</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.activation_name = activation</span><br><span class="line">        <span class="comment"># 根据激活函数选择初始化方式</span></span><br><span class="line">        <span class="keyword">if</span> activation == <span class="string">"relu"</span>:</span><br><span class="line">            <span class="variable language_">self</span>.weights = np.random.randn(num_inputs, <span class="number">1</span>) * np.sqrt(<span class="number">2.0</span> / num_inputs)</span><br><span class="line">        <span class="keyword">elif</span> activation <span class="keyword">in</span> (<span class="string">"tanh"</span>, <span class="string">"sigmoid"</span>):</span><br><span class="line">            <span class="variable language_">self</span>.weights = np.random.randn(num_inputs, <span class="number">1</span>) * np.sqrt(<span class="number">1.0</span> / num_inputs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f"不支持的激活函数: <span class="subst">{activation}</span>"</span>)</span><br><span class="line">        <span class="variable language_">self</span>.bias = np.zeros((<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="variable language_">self</span>.last_input = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.last_z = <span class="literal">None</span></span><br><span class="line">        <span class="variable language_">self</span>.last_a = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">relu</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="string">"""ReLU 激活函数"""</span></span><br><span class="line">        <span class="keyword">return</span> np.maximum(<span class="number">0</span>, z)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">relu_derivative</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="string">"""ReLU 激活函数的导数"""</span></span><br><span class="line">        <span class="keyword">return</span> np.where(z &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tanh</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="string">"""Tanh 激活函数"""</span></span><br><span class="line">        <span class="keyword">return</span> np.tanh(z)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tanh_derivative</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="string">"""Tanh 激活函数的导数"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - np.tanh(z) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="string">"""Sigmoid 激活函数"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sigmoid_derivative</span>(<span class="params">self, z</span>):</span><br><span class="line">        <span class="string">"""Sigmoid 激活函数的导数"""</span></span><br><span class="line">        s = <span class="variable language_">self</span>.sigmoid(z)</span><br><span class="line">        <span class="keyword">return</span> s * (<span class="number">1</span> - s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, activations</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行前向传播：z = a * w + b, a_out = 激活函数(z)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="variable language_">self</span>.last_input = activations</span><br><span class="line">        <span class="comment"># 计算加权和 z</span></span><br><span class="line">        z = activations @ <span class="variable language_">self</span>.weights + <span class="variable language_">self</span>.bias</span><br><span class="line">        <span class="variable language_">self</span>.last_z = z</span><br><span class="line">        <span class="comment"># 应用激活函数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.activation_name == <span class="string">"relu"</span>:</span><br><span class="line">            a = <span class="variable language_">self</span>.relu(z)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.activation_name == <span class="string">"tanh"</span>:</span><br><span class="line">            a = <span class="variable language_">self</span>.tanh(z)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.activation_name == <span class="string">"sigmoid"</span>:</span><br><span class="line">            a = <span class="variable language_">self</span>.sigmoid(z)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f"不支持的激活函数: <span class="subst">{self.activation_name}</span>"</span>)</span><br><span class="line">        <span class="variable language_">self</span>.last_a = a</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dC_da, learning_rate</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行反向传播，计算并应用梯度。</span></span><br><span class="line"><span class="string">        dC_da: 损失函数对本神经元输出 a 的梯度 (从下一层传来)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 1. 计算 da/dz (激活函数对z的梯度)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.activation_name == <span class="string">"relu"</span>:</span><br><span class="line">            da_dz = <span class="variable language_">self</span>.relu_derivative(<span class="variable language_">self</span>.last_z)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.activation_name == <span class="string">"tanh"</span>:</span><br><span class="line">            da_dz = <span class="variable language_">self</span>.tanh_derivative(<span class="variable language_">self</span>.last_z)</span><br><span class="line">        <span class="keyword">elif</span> <span class="variable language_">self</span>.activation_name == <span class="string">"sigmoid"</span>:</span><br><span class="line">            da_dz = <span class="variable language_">self</span>.sigmoid_derivative(<span class="variable language_">self</span>.last_z)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f"不支持的激活函数: <span class="subst">{self.activation_name}</span>"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 计算 dC/dz (损失对z的梯度) = dC/da * da/dz</span></span><br><span class="line">        dC_dz = dC_da * da_dz</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 计算 dC/dw (损失对权重的梯度) = dC/dz * dz/dw</span></span><br><span class="line">        <span class="comment">#    dz/dw = last_input, 所以 dC/dw = last_input.T * dC/dz</span></span><br><span class="line">        dC_dw = <span class="variable language_">self</span>.last_input.T @ dC_dz</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 计算 dC/db (损失对偏置的梯度) = dC/dz * dz/db</span></span><br><span class="line">        <span class="comment">#    dz/db = 1, 所以 dC/db = dC/dz</span></span><br><span class="line">        dC_db = np.<span class="built_in">sum</span>(dC_dz, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 计算 dC/da_prev (损失对前一层激活值的梯度)，用于传给前一层</span></span><br><span class="line">        <span class="comment">#    dC/da_prev = dC/dz * dz/da_prev</span></span><br><span class="line">        <span class="comment">#    dz/da_prev = weights, 所以 dC/da_prev = dC/dz * weights.T</span></span><br><span class="line">        dC_da_prev = dC_dz @ <span class="variable language_">self</span>.weights.T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 6. 根据梯度更新权重和偏置</span></span><br><span class="line">        <span class="variable language_">self</span>.weights -= learning_rate * dC_dw</span><br><span class="line">        <span class="variable language_">self</span>.bias -= learning_rate * dC_db</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回 dC/da_prev，传递给前一层继续反向传播</span></span><br><span class="line">        <span class="keyword">return</span> dC_da_prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    一层神经元。支持指定激活函数。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_neurons, num_inputs_per_neuron, activation=<span class="string">"relu"</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.neurons = [</span><br><span class="line">            Neuron(num_inputs_per_neuron, activation) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_neurons)</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, activations</span>):</span><br><span class="line">        <span class="string">"""对层中所有神经元执行前向传播"""</span></span><br><span class="line">        <span class="comment"># hstack 用于水平堆叠输出，形成一个 (batch_size, num_neurons) 的矩阵</span></span><br><span class="line">        <span class="keyword">return</span> np.hstack([neuron.forward(activations) <span class="keyword">for</span> neuron <span class="keyword">in</span> <span class="variable language_">self</span>.neurons])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dC_da, learning_rate</span>):</span><br><span class="line">        <span class="string">"""对层中所有神经元执行反向传播"""</span></span><br><span class="line">        <span class="comment"># dC_da 的形状是 (batch_size, num_neurons)</span></span><br><span class="line">        <span class="comment"># 我们需要为每个神经元传入对应的梯度 dC_da[:, [i]]</span></span><br><span class="line">        <span class="comment"># 然后将所有神经元返回的 dC/da_prev 相加，得到传给前一层的总梯度</span></span><br><span class="line">        <span class="keyword">return</span> np.<span class="built_in">sum</span>(</span><br><span class="line">            [</span><br><span class="line">                neuron.backward(dC_da[:, [i]], learning_rate)</span><br><span class="line">                <span class="keyword">for</span> i, neuron <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.neurons)</span><br><span class="line">            ],</span><br><span class="line">            axis=<span class="number">0</span>,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NeuralNetwork</span>:</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    完整的神经网络模型。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, layer_sizes, activations=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># activations: 每层的激活函数（不含输入层），如 ["tanh", "sigmoid"]</span></span><br><span class="line">        <span class="keyword">if</span> activations <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 默认隐藏层tanh，输出层sigmoid</span></span><br><span class="line">            activations = [<span class="string">"tanh"</span>] * (<span class="built_in">len</span>(layer_sizes) - <span class="number">2</span>) + [<span class="string">"sigmoid"</span>]</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(activations) == <span class="built_in">len</span>(layer_sizes) - <span class="number">1</span></span><br><span class="line">        <span class="variable language_">self</span>.layers = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(layer_sizes) - <span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.layers.append(</span><br><span class="line">                Layer(layer_sizes[i + <span class="number">1</span>], layer_sizes[i], activations[i])</span><br><span class="line">            )</span><br><span class="line">        <span class="variable language_">self</span>.output_activation = activations[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, activations</span>):</span><br><span class="line">        <span class="string">"""对所有层执行前向传播"""</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="variable language_">self</span>.layers:</span><br><span class="line">            activations = layer.forward(activations)</span><br><span class="line">        <span class="keyword">return</span> activations</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mse_loss</span>(<span class="params">self, y_true, y_pred</span>):</span><br><span class="line">        <span class="string">"""均方误差损失函数"""</span></span><br><span class="line">        <span class="keyword">return</span> np.mean((y_pred - y_true) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">derivative_mse_loss</span>(<span class="params">self, y_true, y_pred</span>):</span><br><span class="line">        <span class="string">"""均方误差损失函数的导数"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (y_pred - y_true) / y_true.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bce_loss</span>(<span class="params">self, y_true, y_pred, eps=<span class="number">1e-8</span></span>):</span><br><span class="line">        <span class="string">"""二元交叉熵损失函数"""</span></span><br><span class="line">        y_pred = np.clip(y_pred, eps, <span class="number">1</span> - eps)</span><br><span class="line">        <span class="keyword">return</span> -np.mean(y_true * np.log(y_pred) + (<span class="number">1</span> - y_true) * np.log(<span class="number">1</span> - y_pred))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">derivative_bce_loss</span>(<span class="params">self, y_true, y_pred, eps=<span class="number">1e-8</span></span>):</span><br><span class="line">        <span class="string">"""二元交叉熵损失函数的导数"""</span></span><br><span class="line">        y_pred = np.clip(y_pred, eps, <span class="number">1</span> - eps)</span><br><span class="line">        <span class="keyword">return</span> (y_pred - y_true) / (y_pred * (<span class="number">1</span> - y_pred) * y_true.shape[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self, X, y, epochs, learning_rate, batch_size=<span class="number">32</span></span>):</span><br><span class="line">        <span class="string">"""训练神经网络"""</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">            total_loss = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(X), batch_size):</span><br><span class="line">                X_batch = X[i : i + batch_size]</span><br><span class="line">                y_batch = y[i : i + batch_size]</span><br><span class="line"></span><br><span class="line">                outputs = <span class="variable language_">self</span>.forward(X_batch)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 自动选择损失函数</span></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.output_activation == <span class="string">"sigmoid"</span>:</span><br><span class="line">                    loss = <span class="variable language_">self</span>.bce_loss(y_batch, outputs)</span><br><span class="line">                    output_gradient = <span class="variable language_">self</span>.derivative_bce_loss(y_batch, outputs)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    loss = <span class="variable language_">self</span>.mse_loss(y_batch, outputs)</span><br><span class="line">                    output_gradient = <span class="variable language_">self</span>.derivative_mse_loss(y_batch, outputs)</span><br><span class="line"></span><br><span class="line">                total_loss += loss * <span class="built_in">len</span>(X_batch)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="variable language_">self</span>.layers):</span><br><span class="line">                    output_gradient = layer.backward(output_gradient, learning_rate)</span><br><span class="line"></span><br><span class="line">            avg_loss = total_loss / <span class="built_in">len</span>(X)</span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">                (epoch + <span class="number">1</span>) % <span class="built_in">max</span>(<span class="number">1</span>, epochs // <span class="number">10</span>) == <span class="number">0</span></span><br><span class="line">                <span class="keyword">or</span> epoch == <span class="number">0</span></span><br><span class="line">                <span class="keyword">or</span> epoch == epochs - <span class="number">1</span></span><br><span class="line">            ):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f"Epoch <span class="subst">{epoch+<span class="number">1</span>}</span>/<span class="subst">{epochs}</span>, Loss: <span class="subst">{avg_loss:<span class="number">.6</span>f}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        out = <span class="variable language_">self</span>.forward(X)</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.output_activation == <span class="string">"sigmoid"</span>:</span><br><span class="line">            <span class="keyword">return</span> out</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 定义 XOR 数据集</span></span><br><span class="line">X_train = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">y_train = np.array([[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建神经网络实例</span></span><br><span class="line"><span class="comment"># 2个输入节点，一个有2个节点的隐藏层，1个输出节点，激活函数分别为tanh和sigmoid</span></span><br><span class="line">nn = NeuralNetwork([<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>], activations=[<span class="string">"tanh"</span>, <span class="string">"sigmoid"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 训练网络</span></span><br><span class="line"><span class="comment"># XOR 是一个非线性问题，需要足够的迭代次数和合适的学习率</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"开始训练XOR网络..."</span>)</span><br><span class="line">nn.train(X_train, y_train, epochs=<span class="number">200000</span>, learning_rate=<span class="number">0.1</span>, batch_size=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"训练完成。"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 进行预测并展示结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n对输入进行预测:"</span>)</span><br><span class="line"><span class="keyword">for</span> x_input <span class="keyword">in</span> X_train:</span><br><span class="line">    prediction = nn.predict(x_input.reshape(<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"输入: <span class="subst">{x_input}</span>, 预测输出: <span class="subst">{prediction[<span class="number">0</span>][<span class="number">0</span>]:<span class="number">.4</span>f}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练XOR网络...</span></span><br><span class="line"><span class="comment"># Epoch 1/200000, Loss: 0.710580</span></span><br><span class="line"><span class="comment"># Epoch 20000/200000, Loss: 0.001633</span></span><br><span class="line"><span class="comment"># Epoch 40000/200000, Loss: 0.000789</span></span><br><span class="line"><span class="comment"># Epoch 60000/200000, Loss: 0.000520</span></span><br><span class="line"><span class="comment"># Epoch 80000/200000, Loss: 0.000387</span></span><br><span class="line"><span class="comment"># Epoch 100000/200000, Loss: 0.000308</span></span><br><span class="line"><span class="comment"># Epoch 120000/200000, Loss: 0.000256</span></span><br><span class="line"><span class="comment"># Epoch 140000/200000, Loss: 0.000219</span></span><br><span class="line"><span class="comment"># Epoch 160000/200000, Loss: 0.000191</span></span><br><span class="line"><span class="comment"># Epoch 180000/200000, Loss: 0.000170</span></span><br><span class="line"><span class="comment"># Epoch 200000/200000, Loss: 0.000153</span></span><br><span class="line"><span class="comment"># 训练完成。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对输入进行预测:</span></span><br><span class="line"><span class="comment"># 输入: [0 0], 预测输出: 0.0002</span></span><br><span class="line"><span class="comment"># 输入: [0 1], 预测输出: 0.9999</span></span><br><span class="line"><span class="comment"># 输入: [1 0], 预测输出: 0.9999</span></span><br><span class="line"><span class="comment"># 输入: [1 1], 预测输出: 0.0002</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以明显看到 XOR
网络的预测更加精准了，并且我在本地连续训练了很多次，几乎不再有训练失败的情况发生。显然，我们的神经网络实现可以说成功了。</p>
<p>本篇中的 Layer / Neuron 结构采用 for-loop +
np.hstack，便于理解原理。实际程序中建议采用全矩阵化实现以提升效率。</p>
]]></content>
      <categories>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>NN</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore lab1 实验报告</title>
    <url>/uCore/28113.html</url>
    <content><![CDATA[<h2 id="本章任务">本章任务</h2>
<h3 id="获取任务信息">获取任务信息</h3>
<p>ch3
中，我们的系统已经能够支持多个任务分时轮流运行，我们希望引入一个新的系统调用
<code>sys_trace</code> （syscall ID:
410）用来追踪当前任务系统调用的历史信息、并进行任务内存的读写。定义如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_trace</span><span class="params">(<span class="type">int</span> trace_request, <span class="type">unsigned</span> <span class="type">long</span> id, <span class="type">uint8_t</span> data)</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>syscall ID: 410</p></li>
<li><p>调用规范：</p>
<ul>
<li>这个系统调用有三种功能，根据 trace_request
的值不同，执行不同的操作：</li>
<li>如果 trace_request 为 0，则 id 应被视作 uint8_t * ，表示读取当前任务
id 地址处一个字节的无符号整数值。此时应忽略 data 参数。返回值为 id
地址处的值。</li>
<li>如果 trace_request 为 1，则 id 应被视作 uint8_t * ，表示写入 data
（作为 uint8_t，即只考虑最低位的一个字节）到该用户程序 id
地址处。返回值应为 0。</li>
<li>如果 trace_request 为 2，表示查询当前任务调用编号为 id
的系统调用的次数，返回值为这个调用次数。本次调用也计入统计 。</li>
<li>否则，忽略其他参数，返回值为 -1。</li>
</ul></li>
<li><p>说明：</p>
<ul>
<li>uint8_t
是 C 语言中的标准类型，表示一个无符号的 8 位整数。在代码中你可能需要使用
uint8 替代。</li>
<li>你可能会注意到，这个调用的读写并不安全，使用不当可能导致崩溃。这是因为在下一章节实现地址空间之前，系统中缺乏隔离机制。所以我们
不要求你实现安全检查机制，只需通过测试用例即可。</li>
<li>你还可能注意到，这个系统调用读写本任务内存的功能并不是很有用。这是因为作业的灵感来源
syscall 主要依靠 trace
功能追踪其他任务的信息，但在本章节我们还没有进程、线程等概念，所以简化了操作，只要求追踪自身的信息。</li>
</ul></li>
</ul>
<h3 id="完成任务">完成任务</h3>
<p>下面是我对代码的修改，导出提交：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From b1836f667109436153481ae6f338a6a50a19e232 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Wed, 23 Jul 2025 22:57:41 +0800</span><br><span class="line">Subject: [PATCH] chapter3 practice</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/loader.c      |  1 +</span><br><span class="line"> os/proc.c        |  1 +</span><br><span class="line"> os/proc.h        |  1 +</span><br><span class="line"> os/syscall.c     | 22 ++++++++++++++++++++++</span><br><span class="line"> os/syscall_ids.h |  1 +</span><br><span class="line"> 5 files changed, 26 insertions(+)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/loader.c b/os/loader.c</span></span><br><span class="line"><span class="comment">index be9f10a..72b49ed 100644</span></span><br><span class="line"><span class="comment">--- a/os/loader.c</span></span><br><span class="line"><span class="comment">+++ b/os/loader.c</span></span><br><span class="line"><span class="meta">@@ -51,6 +51,7 @@</span> int run_all_app()</span><br><span class="line"> 		/*</span><br><span class="line"> 		* LAB1: you may need to initialize your new fields of proc here</span><br><span class="line"> 		*/</span><br><span class="line"><span class="addition">+		memset(p-&gt;syscall_cnt, 0, sizeof(p-&gt;syscall_cnt));</span></span><br><span class="line"> 	}</span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line">\ No newline at end of file</span><br><span class="line"><span class="comment">diff --git a/os/proc.c b/os/proc.c</span></span><br><span class="line"><span class="comment">index 84240a8..c98b49e 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.c</span></span><br><span class="line"><span class="comment">+++ b/os/proc.c</span></span><br><span class="line"><span class="meta">@@ -34,6 +34,7 @@</span> void proc_init(void)</span><br><span class="line"> 		/*</span><br><span class="line"> 		* LAB1: you may need to initialize your new fields of proc here</span><br><span class="line"> 		*/</span><br><span class="line"><span class="addition">+		memset(p-&gt;syscall_cnt, 0, sizeof(p-&gt;syscall_cnt));</span></span><br><span class="line"> 	}</span><br><span class="line"> 	idle.kstack = (uint64)boot_stack_top;</span><br><span class="line"> 	idle.pid = 0;</span><br><span class="line"><span class="comment">diff --git a/os/proc.h b/os/proc.h</span></span><br><span class="line"><span class="comment">index f27369a..74cfe1c 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.h</span></span><br><span class="line"><span class="comment">+++ b/os/proc.h</span></span><br><span class="line"><span class="meta">@@ -38,6 +38,7 @@</span> struct proc {</span><br><span class="line"> 	/*</span><br><span class="line"> 	* LAB1: you may need to add some new fields here</span><br><span class="line"> 	*/</span><br><span class="line"><span class="addition">+	int syscall_cnt[512];</span></span><br><span class="line"> };</span><br><span class="line"> </span><br><span class="line"> struct proc *curr_proc();</span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 3225031..50b0035 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -39,6 +39,22 @@</span> uint64 sys_gettimeofday(TimeVal *val, int _tz)</span><br><span class="line"> /*</span><br><span class="line"> * LAB1: you may need to define sys_trace here</span><br><span class="line"> */</span><br><span class="line"><span class="addition">+int sys_trace(int trace_request, unsigned long id, uint8 data)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	switch (trace_request) {</span></span><br><span class="line"><span class="addition">+	case 0:</span></span><br><span class="line"><span class="addition">+		return *(uint8 *)id;</span></span><br><span class="line"><span class="addition">+	case 1:</span></span><br><span class="line"><span class="addition">+		*(uint8 *)id = data;</span></span><br><span class="line"><span class="addition">+		return 0;</span></span><br><span class="line"><span class="addition">+	case 2:</span></span><br><span class="line"><span class="addition">+		return (id &lt; 512) ? p-&gt;syscall_cnt[id] : -1;</span></span><br><span class="line"><span class="addition">+	default:</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"> </span><br><span class="line"> extern char trap_page[];</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -53,6 +69,9 @@</span> void syscall()</span><br><span class="line"> 	/*</span><br><span class="line"> 	* LAB1: you may need to update syscall counter here</span><br><span class="line"> 	*/</span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	(id &lt; 512) ? p-&gt;syscall_cnt[id]++ : 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	switch (id) {</span><br><span class="line"> 	case SYS_write:</span><br><span class="line"> 		ret = sys_write(args[0], (char *)args[1], args[2]);</span><br><span class="line"><span class="meta">@@ -69,6 +88,9 @@</span> void syscall()</span><br><span class="line"> 	/*</span><br><span class="line"> 	* LAB1: you may need to add SYS_trace case here</span><br><span class="line"> 	*/</span><br><span class="line"><span class="addition">+	case SYS_trace:</span></span><br><span class="line"><span class="addition">+		ret = sys_trace(args[0], args[1], args[2]);</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"> 	default:</span><br><span class="line"> 		ret = -1;</span><br><span class="line"> 		errorf("unknown syscall %d", id);</span><br><span class="line"><span class="comment">diff --git a/os/syscall_ids.h b/os/syscall_ids.h</span></span><br><span class="line"><span class="comment">index e6fac51..06d8c00 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall_ids.h</span></span><br><span class="line"><span class="comment">+++ b/os/syscall_ids.h</span></span><br><span class="line"><span class="meta">@@ -280,6 +280,7 @@</span></span><br><span class="line"> /*</span><br><span class="line"> * LAB1: you may need to define SYS_trace here</span><br><span class="line"> */</span><br><span class="line"><span class="addition">+#define SYS_trace 410</span></span><br><span class="line"> #define SYS_pidfd_send_signal 424</span><br><span class="line"> #define SYS_io_uring_setup 425</span><br><span class="line"> #define SYS_io_uring_enter 426</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>然后 <code>make test</code> 检查即可</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87000000..0x87000ef2</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">Hello world from user mode program!</span><br><span class="line">Test hello_world OK!</span><br><span class="line">3^10000=5079</span><br><span class="line">3^20000=8202</span><br><span class="line">3^30000=8824</span><br><span class="line">3^40000=5750</span><br><span class="line">3^50000=3824</span><br><span class="line">3^60000=8516</span><br><span class="line">3^70000=2510</span><br><span class="line">3^80000=9379</span><br><span class="line">3^90000=2621</span><br><span class="line">3^100000=2749</span><br><span class="line">Test power OK!</span><br><span class="line">get_time OK! 11</span><br><span class="line">current time_msec = 11</span><br><span class="line">AAAAAAAAAA [1/5]</span><br><span class="line">CCCCCCCCCC [1/5]</span><br><span class="line">BBBBBBBBBB [1/5]</span><br><span class="line">AAAAAAAAAA [2/5]</span><br><span class="line">CCCCCCCCCC [2/5]</span><br><span class="line">BBBBBBBBBB [2/5]</span><br><span class="line">AAAAAAAAAA [3/5]</span><br><span class="line">CCCCCCCCCC [3/5]</span><br><span class="line">BBBBBBBBBB [3/5]</span><br><span class="line">AAAAAAAAAA [4/5]</span><br><span class="line">CCCCCCCCCC [4/5]</span><br><span class="line">BBBBBBBBBB [4/5]</span><br><span class="line">AAAAAAAAAA [5/5]</span><br><span class="line">CCCCCCCCCC [5/5]</span><br><span class="line">BBBBBBBBBB [5/5]</span><br><span class="line">Test write A OK!</span><br><span class="line">Test write C OK!</span><br><span class="line">Test write B OK!</span><br><span class="line">time_msec = 112 after sleeping 100 ticks, delta = 101ms!</span><br><span class="line">Test sleep1 passed!</span><br><span class="line">string from task trace test</span><br><span class="line">Test trace OK!</span><br><span class="line">Test sleep OK!</span><br><span class="line">[PANIC 5] os/loader.c:14: all apps over</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到 <code>Test trace OK!</code>，修改成功通过了测试。</p>
<h2 id="问答作业">问答作业</h2>
<ol type="1">
<li><p>正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S
态寄存器后会报错。请同学们可以自行测试这些内容（参考
前三个测例，描述程序出错行为，同时注意注明你使用的 sbi
及其版本。</p></li>
<li><p>请结合用例理解 trampoline.S 中两个函数 <code>userret</code> 和
<code>uservec</code> 的作用，并回答如下几个问题:</p>
<ol type="1">
<li><p>L79: 刚进入 <code>userret</code>
时，<code>a0</code>、<code>a1</code> 分别代表了什么值。</p></li>
<li><p>L87-L88: <code>sfence</code>
指令有何作用？为什么要执行该指令，当前章节中，删掉该指令会导致错误吗？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">csrw satp, a1</span><br><span class="line">sfence.vma zero, zero</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>L96-L125: 为何注释中说要除去 a0？哪一个地址代表 a0？现在 a0
的值存在何处？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># restore all but a0 from TRAPFRAME</span><br><span class="line">ld ra, 40(a0)</span><br><span class="line">ld sp, 48(a0)</span><br><span class="line">ld t5, 272(a0)</span><br><span class="line">ld t6, 280(a0)</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p><code>userret</code>：中发生状态切换在哪一条指令？为何执行之后会进入用户态？</p></li>
<li><p>L29： 执行之后，<code>a0</code> 和 <code>sscratch</code>
中各是什么值，为什么？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">csrrw a0, sscratch, a0</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>L32-L61: 从 trapframe
第几项开始保存？为什么？是否从该项开始保存了所有的值，如果不是，为什么？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sd ra, 40(a0)</span><br><span class="line">sd sp, 48(a0)</span><br><span class="line">...</span><br><span class="line">sd t5, 272(a0)</span><br><span class="line">sd t6, 280(a0)</span><br></pre></td></tr></tbody></table></figure><p></p></li>
<li><p>进入 S 态是哪一条指令发生的？</p></li>
<li><p>L75-L76: <code>ld t0, 16(a0)</code>
执行之后，<code>t0</code>中的值是什么，解释该值的由来？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ld t0, 16(a0)</span><br><span class="line">jr t0</span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ol></li>
</ol>
<h2 id="问答作业解答">问答作业解答</h2>
<ol type="1">
<li><p>正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S
态寄存器后会报错。请同学们可以自行测试这些内容（参考前三个测例
，描述程序出错行为，同时注意注明你使用的 sbi 及其版本。</p>
<p>执行 <code>make test CHAPTER=2_bad</code> 后如下：</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87000000..0x87000ef2</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">hello wrold!</span><br><span class="line">[ERROR 0]unknown trap: 0x0000000000000007, stval = 0x0000000000000000 sepc = 0x0000000080400004</span><br><span class="line">[ERROR 0]IllegalInstruction in application, epc = 0x0000000080400004, core dumped.</span><br><span class="line">[ERROR 0]IllegalInstruction in application, epc = 0x0000000080400004, core dumped.</span><br><span class="line">ALL DONE</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>可以看到项目使用 RustSBI，版本为 0.3.0-alpha.2。</p>
<p>别忘记 <code>trap</code> 类异常：</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Exception</span> {</span></span><br><span class="line">  InstructionMisaligned = <span class="number">0</span>,</span><br><span class="line">  InstructionAccessFault = <span class="number">1</span>,</span><br><span class="line">  IllegalInstruction = <span class="number">2</span>,</span><br><span class="line">  Breakpoint = <span class="number">3</span>,</span><br><span class="line">  LoadMisaligned = <span class="number">4</span>,</span><br><span class="line">  LoadAccessFault = <span class="number">5</span>,</span><br><span class="line">  StoreMisaligned = <span class="number">6</span>,</span><br><span class="line">  StoreAccessFault = <span class="number">7</span>,</span><br><span class="line">  UserEnvCall = <span class="number">8</span>,</span><br><span class="line">  SupervisorEnvCall = <span class="number">9</span>,</span><br><span class="line">  MachineEnvCall = <span class="number">11</span>,</span><br><span class="line">  InstructionPageFault = <span class="number">12</span>,</span><br><span class="line">  LoadPageFault = <span class="number">13</span>,</span><br><span class="line">  StorePageFault = <span class="number">15</span>,</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>三个测例如下：</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// __ch2_bad_address.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> *p = (<span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">  *p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这是一个空指针解引用的测例，U 态程序尝试访问 S 态，显然运行会触发
<code>Store/AMO access fault</code> 异常，所以我们可以看到
<code>unknown trap: 0x0000000000000007</code>。</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// __ch2_bad_instruction.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">"sret"</span>)</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这是一个使用 S 态特权指令的测例，因为 U 态不能执行 S
态特权指令，所以会触发 <code>Illegal instruction</code> 异常。</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// __ch2_bad_register.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">"csrr %0, sstatus"</span> : <span class="string">"=r"</span>(x))</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>这是一个访问 S 态寄存器的测例，同样地，U 态不能访问 S 态 CSR
寄存器，所以会触发 <code>Illegal instruction</code> 异常。</p>
<p>通过上面的测试可以看到，成功输出了
<code>hello wrold!</code>，即用户态程序可以正常运行，且 RustSBI
正常工作，但存在对 U 态的特权级别限制，所以这几个测例会报错。</p></li>
<li><p>请结合用例理解 trampoline.S 中两个函数 <code>userret</code> 和
<code>uservec</code> 的作用，并回答如下几个问题:</p>
<ol type="1">
<li><p>L79: 刚进入 <code>userret</code>
时，<code>a0</code>、<code>a1</code> 分别代表了什么值。</p>
<p>从注释中可以看到 </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">userret:</span><br><span class="line">    # userret(TRAPFRAME, pagetable)</span><br><span class="line">    # switch from kernel to user.</span><br><span class="line">    # usertrapret() calls here.</span><br><span class="line">    # a0: TRAPFRAME, in user page table.</span><br><span class="line">    # a1: user page table, for satp.</span><br></pre></td></tr></tbody></table></figure> 所以 <code>a0</code> 指向 TRAPFRAME
的地址；<code>a1</code> 是用户页表的物理地址，将被设置为寄存器
<code>satp</code> 的值。<p></p></li>
<li><p>L87-L88: <code>sfence</code>
指令有何作用？为什么要执行该指令，当前章节中，删掉该指令会导致错误吗？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">csrw satp, a1</span><br><span class="line">sfence.vma zero, zero</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>刷新 TLB。当修改 <code>satp</code> 寄存器切换页表时，TLB
中可能还缓存着旧页表的地址转换，必须刷新 TLB
确保后续的地址转换使用新页表。当前章节中删去不会出错，这里还不涉及用户页表切换。</p></li>
<li><p>L96-L125: 为何注释中说要除去 <code>a0</code>？哪一个地址代表
<code>a0</code>？现在 <code>a0</code> 的值存在何处？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># restore all but a0 from TRAPFRAME</span><br><span class="line">ld ra, 40(a0)</span><br><span class="line">ld sp, 48(a0)</span><br><span class="line">...</span><br><span class="line">ld t5, 272(a0)</span><br><span class="line">ld t6, 280(a0)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>当前 <code>a0</code> 存储的是 TRAPFRAME
的地址，需要用它访问保存的寄存器值，如果现在恢复
<code>a0</code>，就无法继续访问 TRAPFRAME 了。<code>a0</code>
的原始值保存在 <code>112(a0)</code> 位置，也就是 TRAPFRAME 中的
<code>a0</code> 字段。在恢复过程中会先被加载到 <code>sscratch</code>
寄存器，最后通过 L128：<code>csrrw a0, sscratch, a0</code> 指令完成
<code>a0</code> 的恢复。</p></li>
<li><p><code>userret</code>：中发生状态切换在哪一条指令？为何执行之后会进入用户态？</p>
<p><code>sret</code>。<code>sret</code> 指令会根据 <code>sstatus</code>
寄存器的 <code>SPP</code> 位决定返回的特权级，在
<code>usertrapret()</code> 中，<code>x &amp;= ~SSTATUS_SPP;</code>
已经设置了 <code>sstatus.SPP = 0</code>，表示返回用户态。</p></li>
<li><p>L29： 执行之后，<code>a0</code> 和 <code>sscratch</code>
中各是什么值，为什么？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">csrrw a0, sscratch, a0</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>csrrw</code> 是原子交换指令，同时读取和写入 <code>CSR</code>
寄存器，所以 <code>a0</code> 是 TRAPFRAME 的地址，<code>sscratch</code>
中是用户程序的原始 <code>a0</code> 值。</p></li>
<li><p>L32-L61: 从 trapframe
第几项开始保存？为什么？是否从该项开始保存了所有的值，如果不是，为什么？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sd ra, 40(a0)</span><br><span class="line">sd sp, 48(a0)</span><br><span class="line">...</span><br><span class="line">sd t5, 272(a0)</span><br><span class="line">sd t6, 280(a0)</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>从 <code>ra</code> 开始保存，<code>ra</code> 的偏移量为 40，<span class="math inline">40 ÷ 8 = 5</span>，所以从 <code>trapframe</code>
第六项开始保存。并没有保存所有的值，<code>a0</code> 没有保存，因为此时
<code>a0</code> 指向 <code>trapframe</code>，其原始值通过
<code>csrrw a0, sscratch, a0</code> 保存在 <code>sscratch</code>
中，后续在 <code>trapframe</code> 偏移量 112 处，也就是
<code>trapframe</code> 中的 <code>a0</code> 字段保存。</p></li>
<li><p>进入 S 态是哪一条指令发生的？</p>
<p>用户程序中的 <code>ecall</code>。</p></li>
<li><p>L75-L76: <code>ld t0, 16(a0)</code>
执行之后，<code>t0</code>中的值是什么，解释该值的由来？</p>
<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ld t0, 16(a0)</span><br><span class="line">jr t0</span><br></pre></td></tr></tbody></table></figure><p></p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// os/trap.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="keyword">struct</span> trapframe *trapframe, uint64 kstack)</span></span><br><span class="line">{</span><br><span class="line">  trapframe-&gt;kernel_satp = r_satp(); <span class="comment">// kernel page table</span></span><br><span class="line">  trapframe-&gt;kernel_sp = kstack + PGSIZE; <span class="comment">// process's kernel stack</span></span><br><span class="line">  trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  trapframe-&gt;kernel_hartid = r_tp(); <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  w_sepc(trapframe-&gt;epc);</span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S's sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  uint64 x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  <span class="comment">// uint64 satp = MAKE_SATP(p-&gt;pagetable);</span></span><br><span class="line">  userret((uint64)trapframe);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>可以看到
<code>trapframe-&gt;kernel_trap = (uint64)usertrap;</code>，所以
<code>t0</code> 中的值是 <code>usertrap</code>
函数的地址。当系统调用完成准备返回用户态时，<code>usertrapret()</code>
函数会被调用，<code>trapframe-&gt;kernel_trap = (uint64)usertrap;</code>
将 <code>usertrap</code> 函数地址存储在 <code>trapframe</code> 的偏移量
16 处，于是下次用户态发生 <code>trap</code> 时，<code>uservec</code>
就能正确跳转到<code>usertrap</code> 函数。</p></li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>uCore</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>riscv</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore lab2 实验报告</title>
    <url>/uCore/50167.html</url>
    <content><![CDATA[<h2 id="本章任务">本章任务</h2>
<ul>
<li><code>make test BASE=1</code></li>
<li>理解 vm.c 中的几个函数的大致功能，通过 <code>bin_loader</code>
理解当前用户程序的虚存布局。</li>
<li>结合课堂内容，完成本章问答作业。</li>
<li>完成本章编程作业。</li>
<li>最终，完成实验报告并 push 你的 ch4 分支到远程仓库。</li>
</ul>
<h2 id="编程作业">编程作业</h2>
<h3 id="重新实现-sys_gettimeofday-以及-sys_trace">重新实现
sys_gettimeofday 以及 sys_trace</h3>
<p>引入虚存机制后，原来内核的 <code>sys_gettimeofday</code> 和
<code>sys_trace</code> 函数实现就无效了。
请你重写这两个系统调用的代码，恢复其正常功能。</p>
<p>此外，由于本章我们有了地址空间作为隔离机制，所以
<code>sys_trace</code> 需要考虑一些额外的情况：</p>
<ul>
<li>在读取（<code>trace_request</code> 为
0）时，如果对应地址用户不可见或不可读，则返回值应为 -1（<code>int</code>
的 -1，而非 <code>uint8_t</code>）。</li>
<li>在写入（<code>trace_request</code> 为
1）时，如果对应地址用户不可见或不可写，则返回值应为 -1（<code>int</code>
的 -1，而非 <code>uint8_t</code>）。</li>
</ul>
<h3 id="mmap-匿名映射">mmap 匿名映射</h3>
<p><code>mmap</code> 在 Linux
中主要用于在内存中映射文件，本次实验简化它的功能，仅使用匿名映射来申请内存。</p>
<p>请实现 <code>mmap</code> 和 <code>munmap</code>
系统调用，<code>mmap</code> 定义如下：</p>
<p><code>int mmap(void* start, unsigned long long len, int prot, int flags)</code></p>
<ul>
<li>syscall ID：222</li>
<li>功能：申请长度为 <code>len</code>
字节的匿名物理内存（不要求实际物理内存位置，可以随便找一块），并映射到
<code>addr</code> 开始的虚拟地址，内存页属性为 <code>prot</code>。</li>
<li>参数：
<ul>
<li><code>start</code>：需要映射的虚存起始地址。</li>
<li><code>len</code>：映射字节长度，可以为 0。</li>
<li><code>prot</code>：第 0 位表示是否可读，第 1 位表示是否可写，第 2
位表示是否可执行。其他位无效且必须为 0。</li>
<li><code>flags</code>：默认为
<code>MAP_ANONYMOUS</code>，可忽略该参数。</li>
</ul></li>
<li>返回值:
<ul>
<li>成功返回 0，错误返回 -1。</li>
</ul></li>
<li>说明：
<ul>
<li>为了简单，<code>addr</code> 要求按页对齐 (否则报错)，<code>len</code>
可直接按页上取整。</li>
<li>为了简单，不考虑分配失败时的页回收。</li>
<li>flags 参数留待后续实验拓展。</li>
</ul></li>
<li>错误：
<ul>
<li>[<code>addr</code>, <code>addr + len</code>)
存在已经被映射的页。</li>
<li>物理内存不足。</li>
<li><code>prot &amp; ~0x7 == 0</code>，<code>prot</code> 其他位必须为
0</li>
<li><code>prot &amp; 0x7 != 0</code>，不可读不可写不可执行的内存无意义</li>
</ul></li>
</ul>
<p><code>munmap</code> 系统调用定义如下：</p>
<p><code>int munmap(void* start, unsigned long long len)</code></p>
<ul>
<li>syscall ID：215</li>
<li>功能：取消到虚拟地址区间 [<code>start</code>,
<code>start + len</code>) 的映射。</li>
<li>参数和返回值：参考 mmap</li>
<li>说明：
<ul>
<li>为了简单，参数错误时不考虑内存的恢复和回收。</li>
</ul></li>
<li>错误：
<ul>
<li>[<code>start</code>, <code>start + len</code>)
中存在未被映射的虚存。</li>
</ul></li>
</ul>
<p>正确实现后，你的 os 应该能够正确运行 ch4_*
对应的一些测试用例，<code>make test BASE=0</code> 来执行测试。</p>
<h2 id="编程作业答案">编程作业答案</h2>
<p>导出提交：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From eeab0d1bc86291192109b8387c321600cfb27d83 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Fri, 25 Jul 2025 01:27:26 +0800</span><br><span class="line">Subject: [PATCH] chapter4 practice</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/loader.c      |   1 +</span><br><span class="line"> os/proc.c        |   1 +</span><br><span class="line"> os/proc.h        |   1 +</span><br><span class="line"> os/syscall.c     | 163 ++++++++++++++++++++++++++++++++++++++++++++++-</span><br><span class="line"> os/syscall_ids.h |   2 +-</span><br><span class="line"> os/vm.h          |   1 +</span><br><span class="line"> 6 files changed, 167 insertions(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/loader.c b/os/loader.c</span></span><br><span class="line"><span class="comment">index 735b433..47f9159 100644</span></span><br><span class="line"><span class="comment">--- a/os/loader.c</span></span><br><span class="line"><span class="comment">+++ b/os/loader.c</span></span><br><span class="line"><span class="meta">@@ -72,6 +72,7 @@</span> int run_all_app()</span><br><span class="line"> 		/*</span><br><span class="line"> 		* LAB1: you may need to initialize your new fields of proc here</span><br><span class="line"> 		*/</span><br><span class="line"><span class="addition">+		memset(p-&gt;syscall_cnt, 0, sizeof(p-&gt;syscall_cnt));</span></span><br><span class="line"> 	}</span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"><span class="comment">diff --git a/os/proc.c b/os/proc.c</span></span><br><span class="line"><span class="comment">index 4436826..824b95c 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.c</span></span><br><span class="line"><span class="comment">+++ b/os/proc.c</span></span><br><span class="line"><span class="meta">@@ -33,6 +33,7 @@</span> void proc_init(void)</span><br><span class="line"> 		/*</span><br><span class="line"> 		* LAB1: you may need to initialize your new fields of proc here</span><br><span class="line"> 		*/</span><br><span class="line"><span class="addition">+		memset(p-&gt;syscall_cnt, 0, sizeof(p-&gt;syscall_cnt));</span></span><br><span class="line"> 	}</span><br><span class="line"> 	idle.kstack = (uint64)boot_stack_top;</span><br><span class="line"> 	idle.pid = 0;</span><br><span class="line"><span class="comment">diff --git a/os/proc.h b/os/proc.h</span></span><br><span class="line"><span class="comment">index b6991b3..f2a355d 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.h</span></span><br><span class="line"><span class="comment">+++ b/os/proc.h</span></span><br><span class="line"><span class="meta">@@ -43,6 +43,7 @@</span> struct proc {</span><br><span class="line"> 	/*</span><br><span class="line"> 	* LAB1: you may need to add some new fields here</span><br><span class="line"> 	*/</span><br><span class="line"><span class="addition">+	int syscall_cnt[512];</span></span><br><span class="line"> };</span><br><span class="line"> </span><br><span class="line"> struct proc *curr_proc();</span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 78342ce..b859ea1 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -33,6 +33,7 @@</span> uint64 sys_sched_yield()</span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#if 0</span></span><br><span class="line"> uint64 sys_gettimeofday(TimeVal *val, int _tz) // TODO: implement sys_gettimeofday in pagetable. (VA to PA)</span><br><span class="line"> {</span><br><span class="line"> 	// YOUR CODE</span><br><span class="line"><span class="meta">@@ -46,6 +47,23 @@</span> uint64 sys_gettimeofday(TimeVal *val, int _tz) // TODO: implement sys_gettimeofd</span><br><span class="line"> 	// val-&gt;usec = (cycle % CPU_FREQ) * 1000000 / CPU_FREQ;</span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"><span class="addition">+#endif // #if 0</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+uint64 sys_gettimeofday(uint64 val_va, int _tz)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	TimeVal val;</span></span><br><span class="line"><span class="addition">+	uint64 cycle = get_cycle();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	val.sec = cycle / CPU_FREQ;</span></span><br><span class="line"><span class="addition">+	val.usec = (cycle % CPU_FREQ) * 1000000 / CPU_FREQ;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (copyout(p-&gt;pagetable, val_va, (char *)&amp;val,</span></span><br><span class="line"><span class="addition">+			sizeof(TimeVal)) &lt; 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"> </span><br><span class="line"> uint64 sys_sbrk(int n)</span><br><span class="line"> {</span><br><span class="line"><span class="meta">@@ -65,6 +83,137 @@</span> uint64 sys_sbrk(int n)</span><br><span class="line"> /*</span><br><span class="line"> * LAB1: you may need to define sys_trace here</span><br><span class="line"> */</span><br><span class="line"><span class="addition">+int sys_trace(int trace_request, uint64 id, uint8 data)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/*</span></span><br><span class="line"><span class="addition">+	 * Handle syscall count query first to avoid unnecessary</span></span><br><span class="line"><span class="addition">+	 * page table operations. In case 2, 'id' represents a</span></span><br><span class="line"><span class="addition">+	 * syscall number, not a memory address, so</span></span><br><span class="line"><span class="addition">+	 * calling walk() would fail and cause incorrect behavior.</span></span><br><span class="line"><span class="addition">+	 */</span></span><br><span class="line"><span class="addition">+	if (trace_request == 2)</span></span><br><span class="line"><span class="addition">+		return (id &lt; 512) ? p-&gt;syscall_cnt[id] : -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	pte_t *pte = walk(p-&gt;pagetable, id, 0);</span></span><br><span class="line"><span class="addition">+	uint8 val;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (pte == 0 || (*pte &amp; PTE_V) == 0 || (*pte &amp; PTE_U) == 0)</span></span><br><span class="line"><span class="addition">+		goto err;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	switch (trace_request) {</span></span><br><span class="line"><span class="addition">+	case 0:</span></span><br><span class="line"><span class="addition">+		if ((*pte &amp; PTE_R) == 0)</span></span><br><span class="line"><span class="addition">+			goto err;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (copyin(p-&gt;pagetable, (char *)&amp;val, id, 1) &lt; 0)</span></span><br><span class="line"><span class="addition">+			goto err;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		return (int)val;</span></span><br><span class="line"><span class="addition">+	case 1:</span></span><br><span class="line"><span class="addition">+		if ((*pte &amp; PTE_W) == 0)</span></span><br><span class="line"><span class="addition">+			goto err;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (copyout(p-&gt;pagetable, id, (char *)&amp;data, 1) &lt; 0)</span></span><br><span class="line"><span class="addition">+			goto err;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		return 0;</span></span><br><span class="line"><span class="addition">+	default:</span></span><br><span class="line"><span class="addition">+err:</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+int sys_mmap(uint64 start, uint64 len, int prot, int flags)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (start % PGSIZE != 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if ((prot &amp; ~0x7) != 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	if ((prot &amp; 0x7) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (len == 0)</span></span><br><span class="line"><span class="addition">+		return 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	uint64 end = PGROUNDUP(start + len);</span></span><br><span class="line"><span class="addition">+	for (uint64 va = start; va &lt; end; va += PGSIZE) {</span></span><br><span class="line"><span class="addition">+		pte_t *pte = walk(p-&gt;pagetable, va, 0);</span></span><br><span class="line"><span class="addition">+		if (pte != 0 &amp;&amp; (*pte &amp; PTE_V))</span></span><br><span class="line"><span class="addition">+			return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+#if 0</span></span><br><span class="line"><span class="addition">+	int xperm = 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (prot &amp; 0x2)</span></span><br><span class="line"><span class="addition">+		xperm |= PTE_W;</span></span><br><span class="line"><span class="addition">+	if (prot &amp; 0x4)</span></span><br><span class="line"><span class="addition">+		xperm |= PTE_X;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (uvmalloc(p-&gt;pagetable, start, end, xperm) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+#else // #if 0</span></span><br><span class="line"><span class="addition">+	/*</span></span><br><span class="line"><span class="addition">+	 * Manual page allocation and mapping loop.</span></span><br><span class="line"><span class="addition">+	 * Unlike uvmalloc(), this gives us precise control</span></span><br><span class="line"><span class="addition">+	 * over permission bits to match the exact prot</span></span><br><span class="line"><span class="addition">+	 * flags specified by the user. We allocate physical</span></span><br><span class="line"><span class="addition">+	 * pages one by one, zero them for security,</span></span><br><span class="line"><span class="addition">+	 * set only the requested permission bits (crucial</span></span><br><span class="line"><span class="addition">+	 * for RISC-V compliance where PTE_W=1,PTE_R=0 is</span></span><br><span class="line"><span class="addition">+	 * illegal), and install the mapping via mappages().</span></span><br><span class="line"><span class="addition">+	 */</span></span><br><span class="line"><span class="addition">+	for (uint64 va = start; va &lt; end; va += PGSIZE) {</span></span><br><span class="line"><span class="addition">+		char *pa = kalloc();</span></span><br><span class="line"><span class="addition">+		int pte_flags = PTE_V | PTE_U;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (!pa)</span></span><br><span class="line"><span class="addition">+			return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		memset(pa, 0, PGSIZE);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (prot &amp; 0x1)</span></span><br><span class="line"><span class="addition">+			pte_flags |= PTE_R;</span></span><br><span class="line"><span class="addition">+		if (prot &amp; 0x2)</span></span><br><span class="line"><span class="addition">+			pte_flags |= PTE_W;</span></span><br><span class="line"><span class="addition">+		if (prot &amp; 0x4)</span></span><br><span class="line"><span class="addition">+			pte_flags |= PTE_X;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (mappages(p-&gt;pagetable, va, PGSIZE, (uint64)pa, pte_flags) != 0) {</span></span><br><span class="line"><span class="addition">+			kfree(pa);</span></span><br><span class="line"><span class="addition">+			return -1;</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+#endif // #if 0</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+int sys_munmap(uint64 start, uint64 len)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (start % PGSIZE != 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (len == 0)</span></span><br><span class="line"><span class="addition">+		return 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	uint64 end = PGROUNDUP(start + len);</span></span><br><span class="line"><span class="addition">+	for (uint64 va = start; va &lt; end; va += PGSIZE) {</span></span><br><span class="line"><span class="addition">+		pte_t *pte = walk(p-&gt;pagetable, va, 0);</span></span><br><span class="line"><span class="addition">+		if (pte == 0 || (*pte &amp; PTE_V) == 0)</span></span><br><span class="line"><span class="addition">+			return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	uvmunmap(p-&gt;pagetable, start, (end - start) / PGSIZE, 1);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"> </span><br><span class="line"> extern char trap_page[];</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -79,6 +228,9 @@</span> void syscall()</span><br><span class="line"> 	/*</span><br><span class="line"> 	* LAB1: you may need to update syscall counter here</span><br><span class="line"> 	*/</span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	(id &lt; 512) ? p-&gt;syscall_cnt[id]++ : 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	switch (id) {</span><br><span class="line"> 	case SYS_write:</span><br><span class="line"> 		ret = sys_write(args[0], args[1], args[2]);</span><br><span class="line"><span class="meta">@@ -90,7 +242,7 @@</span> void syscall()</span><br><span class="line"> 		ret = sys_sched_yield();</span><br><span class="line"> 		break;</span><br><span class="line"> 	case SYS_gettimeofday:</span><br><span class="line"><span class="deletion">-		ret = sys_gettimeofday((TimeVal *)args[0], args[1]);</span></span><br><span class="line"><span class="addition">+		ret = sys_gettimeofday(args[0], args[1]);</span></span><br><span class="line"> 		break;</span><br><span class="line"> 	case SYS_sbrk:</span><br><span class="line"> 		ret = sys_sbrk(args[0]);</span><br><span class="line"><span class="meta">@@ -98,6 +250,15 @@</span> void syscall()</span><br><span class="line"> 	/*</span><br><span class="line"> 	* LAB1: you may need to add SYS_trace case here</span><br><span class="line"> 	*/</span><br><span class="line"><span class="addition">+	case SYS_trace:</span></span><br><span class="line"><span class="addition">+		ret = sys_trace(args[0], args[1], args[2]);</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"><span class="addition">+	case SYS_mmap:</span></span><br><span class="line"><span class="addition">+		ret = sys_mmap(args[0], args[1], args[2], args[3]);</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"><span class="addition">+	case SYS_munmap:</span></span><br><span class="line"><span class="addition">+		ret = sys_munmap(args[0], args[1]);</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"> 	default:</span><br><span class="line"> 		ret = -1;</span><br><span class="line"> 		errorf("unknown syscall %d", id);</span><br><span class="line"><span class="comment">diff --git a/os/syscall_ids.h b/os/syscall_ids.h</span></span><br><span class="line"><span class="comment">index 9c0df90..ff7ba8e 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall_ids.h</span></span><br><span class="line"><span class="comment">+++ b/os/syscall_ids.h</span></span><br><span class="line"><span class="meta">@@ -280,7 +280,7 @@</span></span><br><span class="line"> /*</span><br><span class="line"> * LAB1: you may need to define SYS_trace here</span><br><span class="line"> */</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+#define SYS_trace 410</span></span><br><span class="line"> </span><br><span class="line"> #define SYS_pidfd_send_signal 424</span><br><span class="line"> #define SYS_io_uring_setup 425</span><br><span class="line"><span class="comment">diff --git a/os/vm.h b/os/vm.h</span></span><br><span class="line"><span class="comment">index d404df6..d3463e4 100644</span></span><br><span class="line"><span class="comment">--- a/os/vm.h</span></span><br><span class="line"><span class="comment">+++ b/os/vm.h</span></span><br><span class="line"><span class="meta">@@ -10,6 +10,7 @@</span> int mappages(pagetable_t, uint64, uint64, uint64, int);</span><br><span class="line"> pagetable_t uvmcreate(void);</span><br><span class="line"> void uvmfree(pagetable_t, uint64);</span><br><span class="line"> void uvmunmap(pagetable_t, uint64, uint64, int);</span><br><span class="line"><span class="addition">+pte_t *walk(pagetable_t, uint64, int);</span></span><br><span class="line"> uint64 walkaddr(pagetable_t, uint64);</span><br><span class="line"> uint64 useraddr(pagetable_t, uint64);</span><br><span class="line"> int copyout(pagetable_t, uint64, char *, uint64);</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.50.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><code>make test BASE=0</code> 后： </p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[rustsbi] RustSBI version 0.3.0-alpha.2, adapting to RISC-V SBI v1.0.0</span><br><span class="line">.______       __    __      _______.___________.  _______..______   __</span><br><span class="line">|   _  \     |  |  |  |    /       |           | /       ||   _  \ |  |</span><br><span class="line">|  |_)  |    |  |  |  |   |   (----`---|  |----`|   (----`|  |_)  ||  |</span><br><span class="line">|      /     |  |  |  |    \   \       |  |      \   \    |   _  &lt; |  |</span><br><span class="line">|  |\  \----.|  `--'  |.----)   |      |  |  .----)   |   |  |_)  ||  |</span><br><span class="line">| _| `._____| \______/ |_______/       |__|  |_______/    |______/ |__|</span><br><span class="line">[rustsbi] Implementation     : RustSBI-QEMU Version 0.2.0-alpha.2</span><br><span class="line">[rustsbi] Platform Name      : riscv-virtio,qemu</span><br><span class="line">[rustsbi] Platform SMP       : 1</span><br><span class="line">[rustsbi] Platform Memory    : 0x80000000..0x88000000</span><br><span class="line">[rustsbi] Boot HART          : 0</span><br><span class="line">[rustsbi] Device Tree Region : 0x87000000..0x87000ef2</span><br><span class="line">[rustsbi] Firmware Address   : 0x80000000</span><br><span class="line">[rustsbi] Supervisor Address : 0x80200000</span><br><span class="line">[rustsbi] pmp01: 0x00000000..0x80000000 (-wr)</span><br><span class="line">[rustsbi] pmp02: 0x80000000..0x80200000 (---)</span><br><span class="line">[rustsbi] pmp03: 0x80200000..0x88000000 (xwr)</span><br><span class="line">[rustsbi] pmp04: 0x88000000..0x00000000 (-wr)</span><br><span class="line">hello world!</span><br><span class="line">Hello world from user mode program!</span><br><span class="line">Test hello_world OK!</span><br><span class="line">3^10000=5079</span><br><span class="line">3^20000=8202</span><br><span class="line">3^30000=8824</span><br><span class="line">3^40000=5750</span><br><span class="line">3^50000=3824</span><br><span class="line">3^60000=8516</span><br><span class="line">3^70000=2510</span><br><span class="line">3^80000=9379</span><br><span class="line">3^90000=2621</span><br><span class="line">3^100000=2749</span><br><span class="line">Test power OK!</span><br><span class="line">get_time OK! 172</span><br><span class="line">current time_msec = 173</span><br><span class="line">AAAAAAAAAA [1/5]</span><br><span class="line">CCCCCCCCCC [1/5]</span><br><span class="line">BBBBBBBBBB [1/5]</span><br><span class="line">Test 04_0 OK!</span><br><span class="line">[ERROR 11]15 in application, bad addr = 0x0000000010000000, bad instruction = 0x0000000000001022, core dumped.</span><br><span class="line">[ERROR 12]13 in application, bad addr = 0x0000000010000000, bad instruction = 0x0000000000001022, core dumped.</span><br><span class="line">Test 04_3 test OK!</span><br><span class="line">Test sbrk start.</span><br><span class="line">origin break point = 0x0000000000005000</span><br><span class="line">one page allocated, break point = 0x0000000000006000</span><br><span class="line">try write to allocated page</span><br><span class="line">write ok</span><br><span class="line">10 page allocated, break point = 0x0000000000010000</span><br><span class="line">11 page DEALLOCATED, break point = 0x0000000000005000</span><br><span class="line">try DEALLOCATED more one page, should be failed.</span><br><span class="line">Test trace_1 OK!</span><br><span class="line">Test 04_4 ummap OK!</span><br><span class="line">Test 04_5 ummap2 OK!</span><br><span class="line">AAAAAAAAAA [2/5]</span><br><span class="line">CCCCCCCCCC [2/5]</span><br><span class="line">BBBBBBBBBB [2/5]</span><br><span class="line">Test sbrk almost OK!</span><br><span class="line">now write to deallocated page, should cause page fault.</span><br><span class="line">[ERROR 14]15 in application, bad addr = 0x0000000000005000, bad instruction = 0x0000000000001212, core dumped.</span><br><span class="line">AAAAAAAAAA [3/5]</span><br><span class="line">CCCCCCCCCC [3/5]</span><br><span class="line">BBBBBBBBBB [3/5]</span><br><span class="line">AAAAAAAAAA [4/5]</span><br><span class="line">CCCCCCCCCC [4/5]</span><br><span class="line">BBBBBBBBBB [4/5]</span><br><span class="line">AAAAAAAAAA [5/5]</span><br><span class="line">CCCCCCCCCC [5/5]</span><br><span class="line">BBBBBBBBBB [5/5]</span><br><span class="line">Test write A OK!</span><br><span class="line">Test write C OK!</span><br><span class="line">Test write B OK!</span><br><span class="line">time_msec = 273 after sleeping 100 ticks, delta = 100ms!</span><br><span class="line">Test sleep1 passed!</span><br><span class="line">string from task trace test</span><br><span class="line">Test trace OK!</span><br><span class="line">Test sleep OK!</span><br><span class="line">[PANIC 5] os/loader.c:14: all apps over</span><br></pre></td></tr></tbody></table></figure>
自行和各个测例进行比对，可以知道成功通过了所有测例。<p></p>
<h2 id="问答作业">问答作业</h2>
<ol type="1">
<li><p>请列举 SV39
页表页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？</p></li>
<li><p>缺页</p>
<p><em>这次的实验没有涉及到缺页有点遗憾，主要是缺页难以测试，而且更多的是一种优化，不符合这次实验的核心理念，所以这里补几道小题（共 6 题，注意按顺序阅读，<strong>题目之间的文本并不只属于上一题</strong>）。</em></p>
<p><em>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时
MMU 将会返回一个中断，告知 os 进程内存访问出了问题。os
选择填补页表并重新执行异常指令或者杀死进程。</em></p>
<ol type="1">
<li><p><em>请问哪些异常可能是缺页导致的？</em></p></li>
<li><p><em>发生缺页时，描述相关的重要寄存器的值（lab2 中描述过的可以简单点）。</em></p></li>
</ol>
<p><em>缺页有两个常见的原因，其一是 Lazy
策略，也就是直到内存页面被访问才实际进行页表操作。比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是
os 并不会马上这样做，而是会保存 .text
段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。</em></p>
<ol start="3" type="1">
<li><em>这样做有哪些好处？</em></li>
</ol>
<p><em>此外 COW (Copy On Write) 也是常见的容易导致缺页的 Lazy
策略，这个之后再说。其实，我们的 mmap 也可以采取 Lazy
策略，比如：一个用户进程先后申请了 10G 的内存空间，然后用了其中 1M
就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。</em></p>
<ol start="4" type="1">
<li><p><em>请问处理 10G
连续的内存页面，需要操作的页表实际大致占用多少内存 (给出数量级即可)？</em></p></li>
<li><p><em>请简单思考如何才能在现有框架基础上实现 Lazy
策略，缺页时又如何处理？描述合理即可，不需要考虑实现。</em></p></li>
</ol>
<p><em>缺页的另一个常见原因是 swap
策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。</em></p>
<ol start="6" type="1">
<li><em>此时页面失效如何表现在页表项 (PTE) 上？</em></li>
</ol></li>
<li><p>双页表与单页表</p>
<p>为了防范侧信道攻击，我们的 os
使用了双页表。但是传统的设计一直是单页表的，也就是说，用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。请结合课堂知识回答如下问题：(备注：这里的单 / 双的说法仅为自创的通俗说法，并无这个名词概念，详情见
<a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation">KPTI</a>)</p>
<ol type="1">
<li>单页表情况下，如何更换页表？</li>
<li>单页表情况下，如何控制用户态无法访问内核页面？（tips: 看看第一题最后一问）</li>
<li>单页表有何优势？（回答合理即可）</li>
<li>双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？</li>
</ol></li>
</ol>
<h2 id="问答作业答案">问答作业答案</h2>
<ol type="1">
<li><p>请列举 SV39
页表页表项的组成，结合课堂内容，描述其中的标志位有何作用／潜在作用？</p>
<p>SV39 分页模式下的页表项如图所示： <img src="/uCore/50167/SV39-PTE.png" class="" title="PTE"> 这是一个 64
位结构，但实际只使用 54 位，最高 10 bits 为保留位。这些位必须全部为
0，否则触发 page fault。如果不为 0，PTE 被视为无效，MMU
在地址转换时会触发异常。Bits 53-10 是 PPN (Physical Page
Number)，用于地址转换，其中细分为 PPN [2] (53-28 bits)、PPN [1] (27-19
bits)、PPN [0] (18-10 bits)。Bits 9-0
是标志位，控制访问权限和状态等，其中：</p>
<ul>
<li><p>V (Valid, Bit 0): 页表项是否合法，1 为合法，被 MMU 参与翻译。</p>
<ul>
<li>当 V 为 0
的时候，代表当前指针是一个空指针，无法走向下一级节点，即该页表项对应的虚拟地址范围是无效的；</li>
<li>只有当 V 为 1 且 R/W/X 均为 0
时，表示是一个合法的页目录表项，其包含的指针会指向下一级的页表；</li>
<li>当 V 为 1 且 R/W/X 不全为 0
时，表示是一个合法的页表项，其包含了虚地址对应的物理页号。</li>
</ul></li>
<li><p>R (Read, Bit 1): 是否允许读访问，1 为允许。防止非法读。</p></li>
<li><p>W (Write, Bit 2): 是否允许写访问，1 为允许。防止非法写；结合 D
位可以实现写时拷贝 (COW)。</p>
<ul>
<li>规范要求 W = 1 -&gt; R = 1；若出现非法组合 (R = 0, W =
1)，必须立即触发 page fault。</li>
</ul></li>
<li><p>X (eXecute, Bit 3): 表示是否允许执行，1
为允许。防止数据段被执行，提高安全性。</p></li>
<li><p>U (User, Bit 4): 表示 U 模式下是否可访问，1
为允许。用于隔离内核／用户空间；还可以在单页表设计中控制用户态访问内核页。</p></li>
<li><p>G (Global, Bit 5): 全局映射标志。置 1
后表示映射对所有地址空间全局有效；可以优化 TLB
缓存，减少刷新开销。</p></li>
<li><p>A (Accessed, Bit 6): 表示页面自 A 被软件清零之后是否发生过访问，1
为已访问。用于跟踪页面使用；是页面替换算法 (e.g., LRU) 的依据。</p></li>
<li><p>D (Dirty, Bit 7): 表示页面自 D 被软件清零之后是否发生过修改，1
为已修改。用于跟踪页面脏状态；在 swap 时决定是否写回磁盘。</p></li>
<li><p>RSW (Bits 8-9): 软件保留位。可以用来作为 OS
的自定义扩展；实现一些自定义标志等。</p></li>
</ul></li>
<li><p>缺页</p>
<p><em>这次的实验没有涉及到缺页有点遗憾，主要是缺页难以测试，而且更多的是一种优化，不符合这次实验的核心理念，所以这里补几道小题（共 6 题，注意按顺序阅读，<strong>题目之间的文本并不只属于上一题</strong>）。</em></p>
<p><em>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时
MMU 将会返回一个中断，告知 os 进程内存访问出了问题。os
选择填补页表并重新执行异常指令或者杀死进程。</em></p>
<ol type="1">
<li><p><em>请问哪些异常可能是缺页导致的？</em></p>
<p><code>InstructionPageFault</code>、<code>LoadPageFault</code>、<code>StorePageFault</code></p></li>
<li><p><em>发生缺页时，描述相关的重要寄存器的值（lab2 中描述过的可以简单点）。</em></p>
<p><code>scause</code>，指示异常类型，bit 63 为 0
表示异常，低位表示具体原因代码；<code>stval</code>，保存导致缺页的虚拟地址；<code>sepc</code>，保存触发异常的指令地址（如果是异步中断，则指向下一条指令），处理完缺页后，OS
会将 <code>sepc</code> 写回 <code>trapframe</code> 中的
<code>epc</code>，然后 <code>sret</code>
返回重新执行该异常指令；<code>sstatus</code>，SPIE (Supervisor Previous
Interrupt Enable, bit 5)、SPP (Supervisor Previous Privilege, bit 8)
等表明陷入前的中断使能状态与特权级；satp，指向当前进程的页表根。</p></li>
</ol>
<p><em>缺页有两个常见的原因，其一是 Lazy
策略，也就是直到内存页面被访问才实际进行页表操作。比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是
os 并不会马上这样做，而是会保存 .text
段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。</em></p>
<ol start="3" type="1">
<li><p><em>这样做有哪些好处？</em></p>
<p>节约内存与页表开销，未实际访问的页永远不会占物理页，也无需填充
PTE；减少初始分配开销，优化启动时间；结合
COW，可以实现延迟拷贝；减少不必要的磁盘 I / O。</p></li>
</ol>
<p><em>此外 COW (Copy On Write) 也是常见的容易导致缺页的 Lazy
策略，这个之后再说。其实，我们的 mmap 也可以采取 Lazy
策略，比如：一个用户进程先后申请了 10G 的内存空间，然后用了其中 1M
就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。</em></p>
<ol start="4" type="1">
<li><p><em>请问处理 10G
连续的内存页面，需要操作的页表实际大致占用多少内存 (给出数量级即可)？</em></p>
<p>10GiB ÷ 4KiB = 2621440 页。每个 L0 级条目覆盖 4KiB，每个 L1
级条目覆盖 4KiB × 512 = 2MiB，每个 L2 级条目覆盖 2MiB × 512 = 1GiB。需要
2621440 个 L0 级条目，2621440 ÷ 512 = 5120 个页表；需要 5120 个 L1
级条目，5120 ÷ 512 = 10 个页表；需要 10 个 L2 级条目，向上取整为 1
个页表。(1 + 10 + 5120) × 4KiB ≈ 20.04 MiB。</p></li>
<li><p><em>请简单思考如何才能在现有框架基础上实现 Lazy
策略，缺页时又如何处理？描述合理即可，不需要考虑实现。</em></p>
<p>分配内存时暂时不进行分配，只是将其记录下来，第一次访问缺页时会触发缺页异常，自己再实现一个
<code>handler()</code>
函数处理相应的异常，在此时将内存加载或分配即可。</p></li>
</ol>
<p><em>缺页的另一个常见原因是 swap
策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。</em></p>
<ol start="6" type="1">
<li><p><em>此时页面失效如何表现在页表项 (PTE) 上？</em></p>
<p>将标志位 <code>V</code> 置 0。</p></li>
</ol></li>
<li><p>双页表与单页表</p>
<p>为了防范侧信道攻击，我们的 os
使用了双页表。但是传统的设计一直是单页表的，也就是说，用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。请结合课堂知识回答如下问题：(备注：这里的单 / 双的说法仅为自创的通俗说法，并无这个名词概念，详情见
<a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation">KPTI</a>)</p>
<ol type="1">
<li><p>单页表情况下，如何更换页表？</p>
<p>仅在进程切换时更换 <code>satp</code>，指向新进程的页表根节点，并执行
<code>sfence.vma</code> 刷新 TLB，内核和用户共享同一页表。</p></li>
<li><p>单页表情况下，如何控制用户态无法访问内核页面？（tips: 看看第一题最后一问）</p>
<p>将内核页面的 PTE 的 <code>U</code> 标志位置 0。</p></li>
<li><p>单页表有何优势？（回答合理即可）</p>
<p>在内核和用户态之间转换时不需要更换页表，可以像之前一样直接切换上下文；无需维护双份页表，节省内存；内核可以直接访问用户空间，无需
<code>copyin/out</code> 的额外拷贝开销。</p></li>
<li><p>双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？</p>
<p>双页表实现下，用户程序和内核转换时、用户程序转换时都需要更换页表。我会选择在进程切换时更换页表。</p></li>
</ol></li>
</ol>
<h2 id="选做题目">选做题目</h2>
<h3 id="选作题目列表">选作题目列表</h3>
<ul>
<li>（4 分）惰性页面分配（Lazy page allocation）</li>
<li>（4 分）局部页面置换算法：改进的 Clock 页面置换算法</li>
<li>（5 分）全局页面置换算法：工作集置换策略</li>
<li>（5 分）全局页面置换算法：缺页率置换策略</li>
</ul>
<p>这里我暂时只实现了惰性页面分配，如果有空会继续实现选做题目。惰性页面分配的修改如下（基于上面的
patch）：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 8d3c64cc01624c02df3850b65a67382efaffe908 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Fri, 25 Jul 2025 15:06:26 +0800</span><br><span class="line">Subject: [PATCH 2/2] add lazy page allocation support</span><br><span class="line"></span><br><span class="line">Lazy page allocation is a memory management optimization technique with the core idea of "deferred allocation, on-demand allocation". Traditional memory allocation immediately allocates physical memory during system calls, even if the process may never use these pages, causing memory waste. Lazy allocation only creates virtual memory mappings during system calls, and when the process first accesses the page, it triggers a page fault, and the kernel allocates actual physical memory in the page fault handler. This approach saves memory, improves performance, and better utilizes resources.</span><br><span class="line"></span><br><span class="line">Page Table Flag Extension (riscv.h)</span><br><span class="line">Add PTE_LAZY flag (bit 8) to mark lazily allocated pages. Utilize RISC-V architecture's RSW (Reserved for Software) bits to avoid conflicts with standard flags.</span><br><span class="line"></span><br><span class="line">Feature Toggle Control (const.h)</span><br><span class="line">Add LAZY_ALLOCATION macro for conditional compilation. Enable easy feature toggling and debugging while maintaining code maintainability.</span><br><span class="line"></span><br><span class="line">Lazy Page Fault Handling (vm.c)</span><br><span class="line">Add new handle_lazy_fault() function to detect lazy page access, allocate physical memory on demand, and update PTE to valid mapping.</span><br><span class="line">Modify walkaddr() function to automatically detect and handle lazy pages, providing transparent lazy allocation support for all memory access. This is the core of the mechanism, ensuring copyout, copyin, copyinstr functions work without modification.</span><br><span class="line">Modify mappages() function to support creating lazy PTEs (when pa=0) while maintaining backward compatibility.</span><br><span class="line">Modify uvmalloc() function to create lazy mappings during process memory expansion instead of immediate physical memory allocation, significantly reducing memory allocation overhead.</span><br><span class="line">Modify uvmunmap() function to properly handle lazy page deallocation, avoiding freeing unallocated physical memory.</span><br><span class="line"></span><br><span class="line">System Call Optimization (syscall.c)</span><br><span class="line">Modify sys_mmap() function to use lazy allocation instead of immediate allocation while maintaining accurate permission bit settings.</span><br><span class="line">Modify sys_trace() function to support memory access tracing for lazy pages and automatically trigger page allocation.</span><br><span class="line"></span><br><span class="line">Page Fault Handling (trap.c)</span><br><span class="line">Modify usertrap() function to catch page faults caused by lazy page access, invoke lazy allocation handler, while maintaining process boundary checking security.</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/const.h   |   2 +</span><br><span class="line"> os/riscv.h   |   2 +</span><br><span class="line"> os/syscall.c |  32 ++++++++++++++</span><br><span class="line"> os/trap.c    |  29 ++++++++-----</span><br><span class="line"> os/vm.c      | 118 +++++++++++++++++++++++++++++++++++++++------------</span><br><span class="line"> os/vm.h      |   4 ++</span><br><span class="line"> 6 files changed, 149 insertions(+), 38 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/const.h b/os/const.h</span></span><br><span class="line"><span class="comment">index 74096d6..f2b6907 100644</span></span><br><span class="line"><span class="comment">--- a/os/const.h</span></span><br><span class="line"><span class="comment">+++ b/os/const.h</span></span><br><span class="line"><span class="meta">@@ -33,4 +33,6 @@</span> enum {</span><br><span class="line"> </span><br><span class="line"> #define MAX_STR_LEN (200)</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#define LAZY_ALLOCATION 1</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #endif // CONST_H</span><br><span class="line">\ No newline at end of file</span><br><span class="line"><span class="comment">diff --git a/os/riscv.h b/os/riscv.h</span></span><br><span class="line"><span class="comment">index affaeef..d1865d1 100644</span></span><br><span class="line"><span class="comment">--- a/os/riscv.h</span></span><br><span class="line"><span class="comment">+++ b/os/riscv.h</span></span><br><span class="line"><span class="meta">@@ -299,6 +299,8 @@</span> static inline void sfence_vma()</span><br><span class="line"> #define PTE_X (1L &lt;&lt; 3)</span><br><span class="line"> #define PTE_U (1L &lt;&lt; 4) // 1 -&gt; user can access</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#define PTE_LAZY (1L &lt;&lt; 8)</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // shift a physical address to the right place for a PTE.</span><br><span class="line"> #define PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span><br><span class="line"> </span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index b859ea1..fbf51aa 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -99,6 +99,16 @@</span> int sys_trace(int trace_request, uint64 id, uint8 data)</span><br><span class="line"> 	pte_t *pte = walk(p-&gt;pagetable, id, 0);</span><br><span class="line"> 	uint8 val;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+	if (pte != 0 &amp;&amp; (*pte &amp; PTE_V) == 0 &amp;&amp; (*pte &amp; PTE_LAZY)) {</span></span><br><span class="line"><span class="addition">+		if (handle_lazy_fault(p-&gt;pagetable, id) == 0) {</span></span><br><span class="line"><span class="addition">+			pte = walk(p-&gt;pagetable, id, 0);</span></span><br><span class="line"><span class="addition">+			if (pte == 0)</span></span><br><span class="line"><span class="addition">+				goto err;</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	if (pte == 0 || (*pte &amp; PTE_V) == 0 || (*pte &amp; PTE_U) == 0)</span><br><span class="line"> 		goto err;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -143,7 +153,11 @@</span> int sys_mmap(uint64 start, uint64 len, int prot, int flags)</span><br><span class="line"> 	uint64 end = PGROUNDUP(start + len);</span><br><span class="line"> 	for (uint64 va = start; va &lt; end; va += PGSIZE) {</span><br><span class="line"> 		pte_t *pte = walk(p-&gt;pagetable, va, 0);</span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+		if (pte != 0 &amp;&amp; ((*pte &amp; PTE_V) || (*pte &amp; PTE_LAZY)))</span></span><br><span class="line"><span class="addition">+#else</span></span><br><span class="line"> 		if (pte != 0 &amp;&amp; (*pte &amp; PTE_V))</span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"> 			return -1;</span><br><span class="line"> 	}</span><br><span class="line"> #if 0</span><br><span class="line"><span class="meta">@@ -157,6 +171,19 @@</span> int sys_mmap(uint64 start, uint64 len, int prot, int flags)</span><br><span class="line"> 	if (uvmalloc(p-&gt;pagetable, start, end, xperm) == 0)</span><br><span class="line"> 		return -1;</span><br><span class="line"> #else // #if 0</span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+	int pte_flags = PTE_U;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (prot &amp; 0x1)</span></span><br><span class="line"><span class="addition">+		pte_flags |= PTE_R;</span></span><br><span class="line"><span class="addition">+	if (prot &amp; 0x2)</span></span><br><span class="line"><span class="addition">+		pte_flags |= PTE_W;</span></span><br><span class="line"><span class="addition">+	if (prot &amp; 0x4)</span></span><br><span class="line"><span class="addition">+		pte_flags |= PTE_X;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (mappages(p-&gt;pagetable, start, end - start, 0, pte_flags) != 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+#else // #ifdef LAZY_ALLOCATION</span></span><br><span class="line"> 	/*</span><br><span class="line"> 	 * Manual page allocation and mapping loop.</span><br><span class="line"> 	 * Unlike uvmalloc(), this gives us precise control</span><br><span class="line"><span class="meta">@@ -188,6 +215,7 @@</span> int sys_mmap(uint64 start, uint64 len, int prot, int flags)</span><br><span class="line"> 			return -1;</span><br><span class="line"> 		}</span><br><span class="line"> 	}</span><br><span class="line"><span class="addition">+#endif // #ifdef LAZY_ALLOCATION</span></span><br><span class="line"> #endif // #if 0</span><br><span class="line"> </span><br><span class="line"> 	return 0;</span><br><span class="line"><span class="meta">@@ -206,7 +234,11 @@</span> int sys_munmap(uint64 start, uint64 len)</span><br><span class="line"> 	uint64 end = PGROUNDUP(start + len);</span><br><span class="line"> 	for (uint64 va = start; va &lt; end; va += PGSIZE) {</span><br><span class="line"> 		pte_t *pte = walk(p-&gt;pagetable, va, 0);</span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+		if (pte == 0 || ((*pte &amp; PTE_V) == 0 &amp;&amp; (*pte &amp; PTE_LAZY) == 0))</span></span><br><span class="line"><span class="addition">+#else</span></span><br><span class="line"> 		if (pte == 0 || (*pte &amp; PTE_V) == 0)</span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"> 			return -1;</span><br><span class="line"> 	}</span><br><span class="line"> </span><br><span class="line"><span class="comment">diff --git a/os/trap.c b/os/trap.c</span></span><br><span class="line"><span class="comment">index 2b91799..226b455 100644</span></span><br><span class="line"><span class="comment">--- a/os/trap.c</span></span><br><span class="line"><span class="comment">+++ b/os/trap.c</span></span><br><span class="line"><span class="meta">@@ -70,16 +70,25 @@</span> void usertrap()</span><br><span class="line"> 			syscall();</span><br><span class="line"> 			break;</span><br><span class="line"> 		case StoreMisaligned:</span><br><span class="line"><span class="deletion">-                case StorePageFault:</span></span><br><span class="line"><span class="deletion">-                case InstructionMisaligned:</span></span><br><span class="line"><span class="deletion">-                case InstructionPageFault:</span></span><br><span class="line"><span class="deletion">-                case LoadMisaligned:</span></span><br><span class="line"><span class="deletion">-                case LoadPageFault:</span></span><br><span class="line"><span class="deletion">-                        errorf("%d in application, bad addr = %p, bad instruction = %p, "</span></span><br><span class="line"><span class="deletion">-                               "core dumped.",</span></span><br><span class="line"><span class="deletion">-                               cause, r_stval(), trapframe-&gt;epc);</span></span><br><span class="line"><span class="deletion">-                        exit(-2);</span></span><br><span class="line"><span class="deletion">-                        break;</span></span><br><span class="line"><span class="addition">+		case StorePageFault:</span></span><br><span class="line"><span class="addition">+		case InstructionMisaligned:</span></span><br><span class="line"><span class="addition">+		case InstructionPageFault:</span></span><br><span class="line"><span class="addition">+		case LoadMisaligned:</span></span><br><span class="line"><span class="addition">+		case LoadPageFault:</span></span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+		{</span></span><br><span class="line"><span class="addition">+			// Handle lazy allocation page faults</span></span><br><span class="line"><span class="addition">+			uint64 va = r_stval();</span></span><br><span class="line"><span class="addition">+			struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+			if (handle_lazy_fault(p-&gt;pagetable, va) == 0)</span></span><br><span class="line"><span class="addition">+				break;</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"><span class="addition">+			errorf("%d in application, bad addr = %p, bad instruction = %p, "</span></span><br><span class="line"><span class="addition">+				"core dumped.", cause, r_stval(), trapframe-&gt;epc);</span></span><br><span class="line"><span class="addition">+			exit(-2);</span></span><br><span class="line"><span class="addition">+			break;</span></span><br><span class="line"> 		case IllegalInstruction:</span><br><span class="line"> 			errorf("IllegalInstruction in application, core dumped.");</span><br><span class="line"> 			exit(-3);</span><br><span class="line"><span class="comment">diff --git a/os/vm.c b/os/vm.c</span></span><br><span class="line"><span class="comment">index 59eec39..7e7b7ce 100644</span></span><br><span class="line"><span class="comment">--- a/os/vm.c</span></span><br><span class="line"><span class="comment">+++ b/os/vm.c</span></span><br><span class="line"><span class="meta">@@ -65,6 +65,38 @@</span> pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)</span><br><span class="line"> 	return &amp;pagetable[PX(0, va)];</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * Handle page fault for lazy allocated pages.</span></span><br><span class="line"><span class="addition">+ * Allocate physical page when process first</span></span><br><span class="line"><span class="addition">+ * accesses lazy allocated memory region.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+int handle_lazy_fault(pagetable_t pagetable, uint64 va)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	char *mem;</span></span><br><span class="line"><span class="addition">+	pte_t *pte;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	va = PGROUNDDOWN(va);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if ((pte = walk(pagetable, va, 0)) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if ((*pte &amp; PTE_LAZY) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	mem = kalloc();</span></span><br><span class="line"><span class="addition">+	if (mem == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	memset(mem, 0, PGSIZE);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	uint64 perm = PTE_FLAGS(*pte) &amp; ~PTE_LAZY;</span></span><br><span class="line"><span class="addition">+	*pte = PA2PTE(mem) | perm | PTE_V;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // Look up a virtual address, return the physical address,</span><br><span class="line"> // or 0 if not mapped.</span><br><span class="line"> // Can only be used to look up user pages.</span><br><span class="line"><span class="meta">@@ -79,6 +111,12 @@</span> uint64 walkaddr(pagetable_t pagetable, uint64 va)</span><br><span class="line"> 	pte = walk(pagetable, va, 0);</span><br><span class="line"> 	if (pte == 0)</span><br><span class="line"> 		return 0;</span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+	// Check if page is lazy allocated and handle fault</span></span><br><span class="line"><span class="addition">+	if ((*pte &amp; (PTE_V | PTE_LAZY)) == PTE_LAZY &amp;&amp;</span></span><br><span class="line"><span class="addition">+		 !handle_lazy_fault(pagetable, va))</span></span><br><span class="line"><span class="addition">+		pte = walk(pagetable, va, 0);</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"> 	if ((*pte &amp; PTE_V) == 0)</span><br><span class="line"> 		return 0;</span><br><span class="line"> 	if ((*pte &amp; PTE_U) == 0)</span><br><span class="line"><span class="meta">@@ -123,11 +161,24 @@</span> int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</span><br><span class="line"> 			errorf("remap");</span><br><span class="line"> 			return -1;</span><br><span class="line"> 		}</span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+		// Create lazy PTE when pa is 0, otherwise normal mapping</span></span><br><span class="line"><span class="addition">+		if (pa == 0)</span></span><br><span class="line"><span class="addition">+			*pte = (perm &amp; ~PTE_V) | PTE_LAZY;</span></span><br><span class="line"><span class="addition">+		else</span></span><br><span class="line"><span class="addition">+			*pte = PA2PTE(pa) | perm | PTE_V;</span></span><br><span class="line"><span class="addition">+#else</span></span><br><span class="line"> 		*pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"> 		if (a == last)</span><br><span class="line"> 			break;</span><br><span class="line"> 		a += PGSIZE;</span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+		if (pa != 0)</span></span><br><span class="line"><span class="addition">+			pa += PGSIZE;</span></span><br><span class="line"><span class="addition">+#else</span></span><br><span class="line"> 		pa += PGSIZE;</span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"> 	}</span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"><span class="meta">@@ -300,27 +351,38 @@</span> int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)</span><br><span class="line"> // newsz, which need not be page aligned.  Returns new size or 0 on error.</span><br><span class="line"> uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)</span><br><span class="line"> {</span><br><span class="line"><span class="deletion">-        char *mem;</span></span><br><span class="line"><span class="deletion">-        uint64 a;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-        if(newsz &lt; oldsz)</span></span><br><span class="line"><span class="deletion">-                return oldsz;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-        oldsz = PGROUNDUP(oldsz);</span></span><br><span class="line"><span class="deletion">-        for(a = oldsz; a &lt; newsz; a += PGSIZE){</span></span><br><span class="line"><span class="deletion">-                mem = kalloc();</span></span><br><span class="line"><span class="deletion">-                if(mem == 0){</span></span><br><span class="line"><span class="deletion">-                        uvmdealloc(pagetable, a, oldsz);</span></span><br><span class="line"><span class="deletion">-                        return 0;</span></span><br><span class="line"><span class="deletion">-                }</span></span><br><span class="line"><span class="deletion">-                memset(mem, 0, PGSIZE);</span></span><br><span class="line"><span class="deletion">-                if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){</span></span><br><span class="line"><span class="deletion">-                        kfree(mem);</span></span><br><span class="line"><span class="deletion">-                        uvmdealloc(pagetable, a, oldsz);</span></span><br><span class="line"><span class="deletion">-                        return 0;</span></span><br><span class="line"><span class="deletion">-                }</span></span><br><span class="line"><span class="deletion">-        }</span></span><br><span class="line"><span class="deletion">-        return newsz;</span></span><br><span class="line"><span class="addition">+#ifndef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+	char *mem;</span></span><br><span class="line"><span class="addition">+	uint64 a;</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (newsz &lt; oldsz)</span></span><br><span class="line"><span class="addition">+		return oldsz;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	oldsz = PGROUNDUP(oldsz);</span></span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+	// create lazy PTEs without physical pages</span></span><br><span class="line"><span class="addition">+	if (mappages(pagetable, oldsz, newsz - oldsz, 0,</span></span><br><span class="line"><span class="addition">+		 PTE_R | PTE_U | xperm) != 0)</span></span><br><span class="line"><span class="addition">+		return 0;</span></span><br><span class="line"><span class="addition">+#else</span></span><br><span class="line"><span class="addition">+	for(a = oldsz; a &lt; newsz; a += PGSIZE) {</span></span><br><span class="line"><span class="addition">+		mem = kalloc();</span></span><br><span class="line"><span class="addition">+		if (mem == 0) {</span></span><br><span class="line"><span class="addition">+			uvmdealloc(pagetable, a, oldsz);</span></span><br><span class="line"><span class="addition">+			return 0;</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+		memset(mem, 0, PGSIZE);</span></span><br><span class="line"><span class="addition">+		if (mappages(pagetable, a, PGSIZE, (uint64)mem,</span></span><br><span class="line"><span class="addition">+			 PTE_R | PTE_U | xperm) != 0) {</span></span><br><span class="line"><span class="addition">+			kfree(mem);</span></span><br><span class="line"><span class="addition">+			uvmdealloc(pagetable, a, oldsz);</span></span><br><span class="line"><span class="addition">+			return 0;</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return newsz;</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> // Deallocate user pages to bring the process size from oldsz to</span><br><span class="line"><span class="meta">@@ -329,14 +391,14 @@</span> uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)</span><br><span class="line"> // process size.  Returns the new process size.</span><br><span class="line"> uint64 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)</span><br><span class="line"> {</span><br><span class="line"><span class="deletion">-        if(newsz &gt;= oldsz)</span></span><br><span class="line"><span class="deletion">-                return oldsz;</span></span><br><span class="line"><span class="addition">+	if (newsz &gt;= oldsz)</span></span><br><span class="line"><span class="addition">+		return oldsz;</span></span><br><span class="line"> </span><br><span class="line"><span class="deletion">-        if(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz)){</span></span><br><span class="line"><span class="deletion">-                int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span></span><br><span class="line"><span class="deletion">-                uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);</span></span><br><span class="line"><span class="deletion">-        }</span></span><br><span class="line"><span class="addition">+	if (PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz)) {</span></span><br><span class="line"><span class="addition">+		int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span></span><br><span class="line"><span class="addition">+		uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"> </span><br><span class="line"><span class="deletion">-        return newsz;</span></span><br><span class="line"><span class="addition">+	return newsz;</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="comment">diff --git a/os/vm.h b/os/vm.h</span></span><br><span class="line"><span class="comment">index d3463e4..db6d9d7 100644</span></span><br><span class="line"><span class="comment">--- a/os/vm.h</span></span><br><span class="line"><span class="comment">+++ b/os/vm.h</span></span><br><span class="line"><span class="meta">@@ -20,4 +20,8 @@</span> int copyinstr(pagetable_t, char *, uint64, uint64);</span><br><span class="line"> uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm);</span><br><span class="line"> uint64 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#ifdef LAZY_ALLOCATION</span></span><br><span class="line"><span class="addition">+int handle_lazy_fault(pagetable_t pagetable, uint64 va);</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #endif // VM_H</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.50.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>uCore</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>riscv</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore lab3 实验报告</title>
    <url>/uCore/10007.html</url>
    <content><![CDATA[<h2 id="本章任务">本章任务</h2>
<ul>
<li><code>make test BASE=1</code> 执行 usershell，然后输入
<code>ch5b_usertest</code> 运行。</li>
<li>merge ch4 的修改（如有需要，可以 <code>make test BASE=2</code>
然后输入 <code>ch5_mergetest</code> 运行，以此检查 merge
是否正确，但这不是实验必需要求）。</li>
<li>结合文档和代码理解 fork, exec, wait
的逻辑。结合课堂内容回答本章问答问题（注意第二问为选做）。</li>
<li>理解框架的调度机制，尤其要搞明白时钟中断的处理机制以及 yield
之后下一个进程的选择。在次基础上，完成本节的编程作业 (2) stride
调度算法。</li>
<li>完成本章编程作业。</li>
<li>最终，完成实验报告并 push 你的 ch5 分支到远程仓库。</li>
</ul>
<h2 id="编程作业">编程作业</h2>
<h3 id="关于之前的-syscall">关于之前的 syscall</h3>
<p>你仍需要迁移上一章的 <code>sys_gettimeofday</code>
<code>sys_mmap</code> <code>sys_munmap</code>
以适应新的进程结构。不过，<strong>从本章节开始，不再要求维护
<code>sys_trace</code> 这一系统调用</strong>。</p>
<h3 id="进程创建">进程创建</h3>
<p>大家一定好奇过为啥进程创建要用 fork + execve
这么一个奇怪的系统调用，就不能直接搞一个新进程吗？思而不学则殆，我们就来试一试！这章的编程练习请大家实现一个完全
DIY 的系统调用 spawn，用以创建一个新进程。</p>
<p>spawn 系统调用定义：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_spawn</span><span class="params">(<span class="type">char</span> *filename)</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>syscall ID: 400</li>
<li>功能：相当于 fork + exec，新建子进程并执行目标程序。</li>
<li>说明：成功返回子进程 id，否则返回 -1。</li>
<li>可能的错误：
<ul>
<li>无效的文件名。</li>
<li>进程池满 / 内存不足等资源错误。</li>
</ul></li>
</ul>
<p>实现完成之后，你应该能通过 ch5_spawn* 对应的所有测例，在 shell 中执行
ch5_usertest 来执行所有测试，应当发现除了 setprio 相关的测例均正确。</p>
<h4 id="tips">tips:</h4>
<ul>
<li>注意 fork 的执行流，新进程 context 的 ra 和 sp
与父进程不同。所以你不能在内核中通过 fork 和 exec 的简单组合实现
spawn。</li>
<li>在 spawn 中不应该有任何形式的内存拷贝。</li>
</ul>
<h3 id="stride-调度算法">stride 调度算法</h3>
<p>lab3
中我们引入了任务调度的概念，可以在不同任务之间切换，目前我们实现的调度算法十分简单，存在一些问题且不存在优先级。现在我们要为我们的
os 实现一种带优先级的调度算法：stride 调度算法。</p>
<p>算法描述如下:</p>
<ol type="1">
<li>为每个进程设置一个当前
stride，表示该进程当前已经运行的 “长度”。另外设置其对应的 pass
值（只与进程的优先权有关系），表示对应进程在调度后，stride
需要进行的累加值。</li>
<li>每次需要调度时，从当前 runnable 态的进程中选择 stride
最小的进程调度。对于获得调度的进程 P，将对应的 stride 加上其对应的步长
pass。</li>
<li>一个时间片后，回到上一步骤，重新调度当前 stride 最小的进程。</li>
</ol>
<p>可以证明，如果令 P.pass = BigStride / P.priority 其中 P.pass 为进程的
pass 值，P.priority 表示进程的优先权（大于 1），而 BigStride
表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。证明过程我们在这里略去，有兴趣的同学可以在网上查找相关资料。</p>
<p>其他实验细节：</p>
<ul>
<li>stride 调度要求进程优先级 ≥ 2，所以设定进程优先级 ≤ 1
会导致错误。</li>
<li>进程初始 stride 设置为 0 即可。</li>
<li>进程初始优先级设置为 16。</li>
</ul>
<p>为了实现该调度算法，内核还要增加 <code>sys_set_priority</code>
系统调用:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_priority</span><span class="params">(<span class="type">long</span> <span class="type">long</span> prio)</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>功能描述
<ul>
<li>syscall ID: 140</li>
<li>功能：设定进程优先级。</li>
<li>说明：设定自身进程优先级，只要 prio 在 [2, isize_max] 就成功，返回
prio，否则返回 -1。</li>
</ul></li>
<li>针对测例
<ul>
<li>ch5_setprio</li>
</ul></li>
</ul>
<p>完成之后你需要调整框架的代码调度机制，是的可以设置不同进程优先级之后可以按照
stride 算法进行调度。实现正确后，代码应该能够通过用户测例
ch5t_stride*。最终输出的 priority 和 exitcode
应该大致成正比，由于我们的时间片比较粗糙，qemu
的模拟也不是十分准确，我们最终的 CI 测试会允许最大 30% 的误差。</p>
<h4 id="实现-tips">实现 tips:</h4>
<ul>
<li>你应该给 proc 结构体加入新的字段来支持优先级。</li>
<li>我们的测例运行时间不很长，不要求处理 stride
的溢出（详见问答作业，当然处理了更好）。</li>
<li>为了减少整数除的误差，BIG_STRIDE 一般需要很大，但测例中的优先级都是
2 的整数次幂，结合第二点，BIG_STRIDE 不需要太大，65536
是一个不错的数字。</li>
<li>用户态的 printf
支持了行缓冲，所以如果你想要增加用户程序的输出，记得换行。</li>
<li>stride 算法要找到　stride
最小的进程，使用优先级队列是效率不错的办法，但是我们的实验测例很简单，所以效率完全不是问题。事实上，我很推荐使用暴力扫一遍的办法找最小值。</li>
<li>注意设置进程的初始优先级。</li>
</ul>
<h2 id="编程作业答案">编程作业答案</h2>
<h3 id="迁移之前的-syscall">迁移之前的 syscall</h3>
<p>简单地 cherry-pick 过来，解决一下冲突就行了，记得不要留下任何
<code>sys_trace</code> 的相关代码。</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 65f6316dbf37e297d56bdeb84775164a5e6f7aef Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Fri, 25 Jul 2025 01:27:26 +0800</span><br><span class="line">Subject: [PATCH 1/7] chapter4 practice</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/syscall.c | 118 ++++++++++++++++++++++++++++++++++++++++++++++++++-</span><br><span class="line"> os/vm.h      |   1 +</span><br><span class="line"> 2 files changed, 117 insertions(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index fa22920..9cbcc81 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -48,6 +48,7 @@</span> uint64 sys_sched_yield()</span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="addition">+#if 0</span></span><br><span class="line"> uint64 sys_gettimeofday(uint64 val, int _tz)</span><br><span class="line"> {</span><br><span class="line"> 	struct proc *p = curr_proc();</span><br><span class="line"><span class="meta">@@ -58,6 +59,23 @@</span> uint64 sys_gettimeofday(uint64 val, int _tz)</span><br><span class="line"> 	copyout(p-&gt;pagetable, val, (char *)&amp;t, sizeof(TimeVal));</span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"><span class="addition">+#else</span></span><br><span class="line"><span class="addition">+uint64 sys_gettimeofday(uint64 val_va, int _tz)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	TimeVal val;</span></span><br><span class="line"><span class="addition">+	uint64 cycle = get_cycle();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	val.sec = cycle / CPU_FREQ;</span></span><br><span class="line"><span class="addition">+	val.usec = (cycle % CPU_FREQ) * 1000000 / CPU_FREQ;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (copyout(p-&gt;pagetable, val_va, (char *)&amp;val,</span></span><br><span class="line"><span class="addition">+			sizeof(TimeVal)) &lt; 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"> </span><br><span class="line"> uint64 sys_getpid()</span><br><span class="line"> {</span><br><span class="line"><span class="meta">@@ -114,6 +132,96 @@</span> uint64 sys_sbrk(int n)</span><br><span class="line">         return addr;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="addition">+int sys_mmap(uint64 start, uint64 len, int prot, int flags)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (start % PGSIZE != 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if ((prot &amp; ~0x7) != 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	if ((prot &amp; 0x7) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (len == 0)</span></span><br><span class="line"><span class="addition">+		return 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	uint64 end = PGROUNDUP(start + len);</span></span><br><span class="line"><span class="addition">+	for (uint64 va = start; va &lt; end; va += PGSIZE) {</span></span><br><span class="line"><span class="addition">+		pte_t *pte = walk(p-&gt;pagetable, va, 0);</span></span><br><span class="line"><span class="addition">+		if (pte != 0 &amp;&amp; (*pte &amp; PTE_V))</span></span><br><span class="line"><span class="addition">+			return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+#if 0</span></span><br><span class="line"><span class="addition">+	int xperm = 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (prot &amp; 0x2)</span></span><br><span class="line"><span class="addition">+		xperm |= PTE_W;</span></span><br><span class="line"><span class="addition">+	if (prot &amp; 0x4)</span></span><br><span class="line"><span class="addition">+		xperm |= PTE_X;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (uvmalloc(p-&gt;pagetable, start, end, xperm) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+#else // #if 0</span></span><br><span class="line"><span class="addition">+	/*</span></span><br><span class="line"><span class="addition">+	 * Manual page allocation and mapping loop.</span></span><br><span class="line"><span class="addition">+	 * Unlike uvmalloc(), this gives us precise control</span></span><br><span class="line"><span class="addition">+	 * over permission bits to match the exact prot</span></span><br><span class="line"><span class="addition">+	 * flags specified by the user. We allocate physical</span></span><br><span class="line"><span class="addition">+	 * pages one by one, zero them for security,</span></span><br><span class="line"><span class="addition">+	 * set only the requested permission bits (crucial</span></span><br><span class="line"><span class="addition">+	 * for RISC-V compliance where PTE_W=1,PTE_R=0 is</span></span><br><span class="line"><span class="addition">+	 * illegal), and install the mapping via mappages().</span></span><br><span class="line"><span class="addition">+	 */</span></span><br><span class="line"><span class="addition">+	for (uint64 va = start; va &lt; end; va += PGSIZE) {</span></span><br><span class="line"><span class="addition">+		char *pa = kalloc();</span></span><br><span class="line"><span class="addition">+		int pte_flags = PTE_V | PTE_U;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (!pa)</span></span><br><span class="line"><span class="addition">+			return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		memset(pa, 0, PGSIZE);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (prot &amp; 0x1)</span></span><br><span class="line"><span class="addition">+			pte_flags |= PTE_R;</span></span><br><span class="line"><span class="addition">+		if (prot &amp; 0x2)</span></span><br><span class="line"><span class="addition">+			pte_flags |= PTE_W;</span></span><br><span class="line"><span class="addition">+		if (prot &amp; 0x4)</span></span><br><span class="line"><span class="addition">+			pte_flags |= PTE_X;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (mappages(p-&gt;pagetable, va, PGSIZE, (uint64)pa, pte_flags) != 0) {</span></span><br><span class="line"><span class="addition">+			kfree(pa);</span></span><br><span class="line"><span class="addition">+			return -1;</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+#endif // #if 0</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+int sys_munmap(uint64 start, uint64 len)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (start % PGSIZE != 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (len == 0)</span></span><br><span class="line"><span class="addition">+		return 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	uint64 end = PGROUNDUP(start + len);</span></span><br><span class="line"><span class="addition">+	for (uint64 va = start; va &lt; end; va += PGSIZE) {</span></span><br><span class="line"><span class="addition">+		pte_t *pte = walk(p-&gt;pagetable, va, 0);</span></span><br><span class="line"><span class="addition">+		if (pte == 0 || (*pte &amp; PTE_V) == 0)</span></span><br><span class="line"><span class="addition">+			return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	uvmunmap(p-&gt;pagetable, start, (end - start) / PGSIZE, 1);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> extern char trap_page[];</span><br><span class="line"> </span><br><span class="line"> void syscall()</span><br><span class="line"><span class="meta">@@ -159,8 +267,14 @@</span> void syscall()</span><br><span class="line"> 		ret = sys_spawn(args[0]);</span><br><span class="line"> 		break;</span><br><span class="line"> 	case SYS_sbrk:</span><br><span class="line"><span class="deletion">-                ret = sys_sbrk(args[0]);</span></span><br><span class="line"><span class="deletion">-                break;</span></span><br><span class="line"><span class="addition">+		ret = sys_sbrk(args[0]);</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"><span class="addition">+	case SYS_mmap:</span></span><br><span class="line"><span class="addition">+		ret = sys_mmap(args[0], args[1], args[2], args[3]);</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"><span class="addition">+	case SYS_munmap:</span></span><br><span class="line"><span class="addition">+		ret = sys_munmap(args[0], args[1]);</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"> 	default:</span><br><span class="line"> 		ret = -1;</span><br><span class="line"> 		errorf("unknown syscall %d", id);</span><br><span class="line"><span class="comment">diff --git a/os/vm.h b/os/vm.h</span></span><br><span class="line"><span class="comment">index 8618f5c..9975f6d 100644</span></span><br><span class="line"><span class="comment">--- a/os/vm.h</span></span><br><span class="line"><span class="comment">+++ b/os/vm.h</span></span><br><span class="line"><span class="meta">@@ -11,6 +11,7 @@</span> pagetable_t uvmcreate(uint64);</span><br><span class="line"> int uvmcopy(pagetable_t, pagetable_t, uint64);</span><br><span class="line"> void uvmfree(pagetable_t, uint64);</span><br><span class="line"> void uvmunmap(pagetable_t, uint64, uint64, int);</span><br><span class="line"><span class="addition">+pte_t *walk(pagetable_t, uint64, int);</span></span><br><span class="line"> uint64 walkaddr(pagetable_t, uint64);</span><br><span class="line"> uint64 useraddr(pagetable_t, uint64);</span><br><span class="line"> int copyout(pagetable_t, uint64, char *, uint64);</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.50.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>简单 <code>make test BASE=2</code> 然后输入
<code>ch5_mergetest</code> 运行一下，发现运行不了，运行到 mmap
的测例就会显示
<code>[PANIC 122] os/vm.c:198: freewalk: leaf</code>，看了一下应该是
max_page 的原因，于是进行以下修改：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 838f072a0424c4dae3753136c05a91e57f28fc9e Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Fri, 1 Aug 2025 03:14:17 +0800</span><br><span class="line">Subject: [PATCH 2/7] adapt mmap/munmap to ch5</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/syscall.c | 14 ++++++++++++++</span><br><span class="line"> 1 file changed, 14 insertions(+)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 9cbcc81..d0cf211 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -197,6 +197,10 @@</span> int sys_mmap(uint64 start, uint64 len, int prot, int flags)</span><br><span class="line"> 	}</span><br><span class="line"> #endif // #if 0</span><br><span class="line"> </span><br><span class="line"><span class="addition">+	uint64 end_page = end / PGSIZE;</span></span><br><span class="line"><span class="addition">+	if (end_page &gt; p-&gt;max_page)</span></span><br><span class="line"><span class="addition">+		p-&gt;max_page = end_page;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -219,6 +223,16 @@</span> int sys_munmap(uint64 start, uint64 len)</span><br><span class="line"> </span><br><span class="line"> 	uvmunmap(p-&gt;pagetable, start, (end - start) / PGSIZE, 1);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+	for (uint64 pg = p-&gt;max_page; pg &gt; 0; pg--) {</span></span><br><span class="line"><span class="addition">+		uint64 va  = (pg - 1) * PGSIZE;</span></span><br><span class="line"><span class="addition">+		pte_t *pte = walk(p-&gt;pagetable, va, 0);</span></span><br><span class="line"><span class="addition">+		if (pte &amp;&amp; (*pte &amp; PTE_V)) {</span></span><br><span class="line"><span class="addition">+			p-&gt;max_page = pg;</span></span><br><span class="line"><span class="addition">+			return 0;</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+	p-&gt;max_page = 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.50.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>改完之后再次运行 <code>make test BASE=2</code> 然后输入
<code>ch5_mergetest</code>，可以看到最后
<code>ch5 Mergetests passed!</code>，测试通过。</p>
<h3 id="进程创建-1">进程创建</h3>
<p>spawn 的实现比较简单，看看 fork 和 execve 的逻辑就行了：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 63314392ebafe3f203477c684709d8b611baef47 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Fri, 1 Aug 2025 18:46:29 +0800</span><br><span class="line">Subject: [PATCH 3/7] implement spawn syscall</span><br><span class="line"></span><br><span class="line">This change brings a new `spawn` system call to provide an</span><br><span class="line">efficient way to create a new process and execute a program</span><br><span class="line">in a single operation.</span><br><span class="line"></span><br><span class="line">This new system call is designed as a more performant alternative to</span><br><span class="line">the traditional fork-then-exec model. It avoids the overhead of copying</span><br><span class="line">the parent process's entire address space, which is immediately discarded</span><br><span class="line">by exec. Instead, `spawn` creates a new, empty process and directly loads</span><br><span class="line">the specified application into it.</span><br><span class="line"></span><br><span class="line">Key implementation details:</span><br><span class="line"><span class="deletion">- A new system call, `sys_spawn`, is added. It takes a user-space</span></span><br><span class="line">  pointer to a filename as an argument.</span><br><span class="line"><span class="deletion">- The filename is safely copied into the kernel using `copyinstr` to</span></span><br><span class="line">  prevent security vulnerabilities.</span><br><span class="line"><span class="deletion">- A new process is created by calling `allocproc`, which sets up a</span></span><br><span class="line">  clean process state, including a PCB and a kernel stack.</span><br><span class="line"><span class="deletion">- The application's binary is loaded into the new process's address</span></span><br><span class="line">  space using the existing `loader` function.</span><br><span class="line"><span class="deletion">- The parent-child relationship is established to maintain the process</span></span><br><span class="line">  tree, which is essential for the `wait` system call.</span><br><span class="line"><span class="deletion">- Robust error handling is implemented. If any step fails (e.g., invalid</span></span><br><span class="line">  filename, process allocation failure, or loader error), allocated</span><br><span class="line">  resources are cleaned up, and an error code (-1) is returned to the</span><br><span class="line">  calling process.</span><br><span class="line"><span class="deletion">- Expose the function `freeproc` from proc.h.</span></span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/proc.h    |  1 +</span><br><span class="line"> os/syscall.c | 42 ++++++++++++++++++++++++++++++++++++++++--</span><br><span class="line"> 2 files changed, 41 insertions(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/proc.h b/os/proc.h</span></span><br><span class="line"><span class="comment">index aabc2e8..85a527c 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.h</span></span><br><span class="line"><span class="comment">+++ b/os/proc.h</span></span><br><span class="line"><span class="meta">@@ -62,6 +62,7 @@</span> int wait(int, int *);</span><br><span class="line"> void add_task(struct proc *);</span><br><span class="line"> struct proc *pop_task();</span><br><span class="line"> struct proc *allocproc();</span><br><span class="line"><span class="addition">+void freeproc(struct proc *p);</span></span><br><span class="line"> int fdalloc(struct file *);</span><br><span class="line"> // swtch.S</span><br><span class="line"> void swtch(struct context *, struct context *);</span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index d0cf211..b3a354a 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -110,10 +110,48 @@</span> uint64 sys_wait(int pid, uint64 va)</span><br><span class="line"> 	return wait(pid, code);</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * sys_spawn - Create a new process and execute a program.</span></span><br><span class="line"><span class="addition">+ * @va: User-space virtual address of the filename to execute.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Creates a new process in a single step, avoiding the overhead of</span></span><br><span class="line"><span class="addition">+ * fork-then-exec. This is more efficient as it does not copy the</span></span><br><span class="line"><span class="addition">+ * parent's address space.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Returns:</span></span><br><span class="line"><span class="addition">+ * The new process's PID on success.</span></span><br><span class="line"><span class="addition">+ * -1 on error (e.g., invalid filename, out of memory, or process limit reached).</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"> uint64 sys_spawn(uint64 va)</span><br><span class="line"> {</span><br><span class="line"><span class="deletion">-	// TODO: your job is to complete the sys call</span></span><br><span class="line"><span class="deletion">-	return -1;</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	char name[MAX_STR_LEN];</span></span><br><span class="line"><span class="addition">+	struct proc *np;</span></span><br><span class="line"><span class="addition">+	int id;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/*</span></span><br><span class="line"><span class="addition">+	 * Copy the filename from user space to kernel space.</span></span><br><span class="line"><span class="addition">+	 */</span></span><br><span class="line"><span class="addition">+	if (copyinstr(p-&gt;pagetable, name, va, MAX_STR_LEN) &lt; 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	id = get_id_by_name(name);</span></span><br><span class="line"><span class="addition">+	if (id &lt; 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if ((np = allocproc()) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	np-&gt;parent = p;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (loader(id, np) &lt; 0) {</span></span><br><span class="line"><span class="addition">+		freeproc(np);</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	add_task(np);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return np-&gt;pid;</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> uint64 sys_set_priority(long long prio){</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.50.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><code>make test BASE=2</code> 然后执行 <code>ch5_usertest</code>
进行测试，中间会有几个
<code>[ERROR 156]unknown syscall 140</code>，这不要紧，是因为我们还没实现优先级设置的系统调用导致的，下面实现完
<code>sys_set_priority</code>
后就不会再有这些错误了，现在只要看到最后的</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ch5t usertest passed!</span><br><span class="line">ch5 Usertests passed!</span><br></pre></td></tr></tbody></table></figure>
<p>就证明我们的 spawn 系统调用完成了。</p>
<h3 id="stride-调度算法-1">stride 调度算法</h3>
<p>这算是这个实验最复杂的一部分了吧，首先最简单的引入 stride
调度算法：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 707d366e7a892d0b75e4dfc9e276ea13734496e6 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Fri, 1 Aug 2025 22:17:09 +0800</span><br><span class="line">Subject: [PATCH 4/7] Implement stride scheduling algorithm</span><br><span class="line"></span><br><span class="line">This commit replaces the previous simple round-robin scheduler with the stride scheduling algo</span><br><span class="line">to enable priority-based process scheduling. The new scheduler ensures that processes receive CPU time</span><br><span class="line">proportional to their assigned priority, leading to a more fair and controllable execution environment.</span><br><span class="line"></span><br><span class="line">Key changes include modifications to the process structure in proc.h, where stride and priority</span><br><span class="line">fields have been added to struct proc. The main scheduler logic in proc.c is updated to select the process</span><br><span class="line">with the minimum stride for execution and then increments its stride based on its priority.</span><br><span class="line"></span><br><span class="line">New processes are initialized with a default priority of 16 and a stride of 0 in allocproc().</span><br><span class="line">Child processes created via fork() now inherit the priority and stride from their parent.</span><br><span class="line"></span><br><span class="line">Additionally, a new system call, sys_set_priority, is introduced in syscall.c. This allows a</span><br><span class="line">process to set its own priority, provided it is 2 or greater.</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/const.h   |  4 ++++</span><br><span class="line"> os/proc.c    | 43 ++++++++++++++++++++++++++++++++++++++++++-</span><br><span class="line"> os/proc.h    |  3 +++</span><br><span class="line"> os/syscall.c | 14 ++++++++++++--</span><br><span class="line"> 4 files changed, 61 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/const.h b/os/const.h</span></span><br><span class="line"><span class="comment">index a178e6c..2cce207 100644</span></span><br><span class="line"><span class="comment">--- a/os/const.h</span></span><br><span class="line"><span class="comment">+++ b/os/const.h</span></span><br><span class="line"><span class="meta">@@ -35,4 +35,8 @@</span> enum {</span><br><span class="line"> #define MAX_STR_LEN (200)</span><br><span class="line"> #define IDLE_PID (0)</span><br><span class="line"> </span><br><span class="line"><span class="addition">+// scheduler algo</span></span><br><span class="line"><span class="addition">+#define BIG_STRIDE 65536</span></span><br><span class="line"><span class="addition">+#define DEFAULT_PRIO 16</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> #endif // CONST_H</span><br><span class="line">\ No newline at end of file</span><br><span class="line"><span class="comment">diff --git a/os/proc.c b/os/proc.c</span></span><br><span class="line"><span class="comment">index ce45bff..c59ef01 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.c</span></span><br><span class="line"><span class="comment">+++ b/os/proc.c</span></span><br><span class="line"><span class="meta">@@ -85,7 +85,10 @@</span> found:</span><br><span class="line"> 	p-&gt;exit_code = 0;</span><br><span class="line"> 	p-&gt;pagetable = uvmcreate((uint64)p-&gt;trapframe);</span><br><span class="line"> 	p-&gt;program_brk = 0;</span><br><span class="line"><span class="deletion">-        p-&gt;heap_bottom = 0;</span></span><br><span class="line"><span class="addition">+	p-&gt;heap_bottom = 0;</span></span><br><span class="line"><span class="addition">+	p-&gt;stride = 0;</span></span><br><span class="line"><span class="addition">+	p-&gt;priority = DEFAULT_PRIO;</span></span><br><span class="line"><span class="addition">+	p-&gt;pass = BIG_STRIDE / p-&gt;priority;</span></span><br><span class="line"> 	memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));</span><br><span class="line"> 	memset((void *)p-&gt;kstack, 0, KSTACK_SIZE);</span><br><span class="line"> 	memset((void *)p-&gt;trapframe, 0, TRAP_PAGE_SIZE);</span><br><span class="line"><span class="meta">@@ -99,6 +102,7 @@</span> found:</span><br><span class="line"> //  - swtch to start running that process.</span><br><span class="line"> //  - eventually that process transfers control</span><br><span class="line"> //    via swtch back to the scheduler.</span><br><span class="line"><span class="addition">+#if 0</span></span><br><span class="line"> void scheduler()</span><br><span class="line"> {</span><br><span class="line"> 	struct proc *p;</span><br><span class="line"><span class="meta">@@ -126,6 +130,40 @@</span> void scheduler()</span><br><span class="line"> 		swtch(&amp;idle.context, &amp;p-&gt;context);</span><br><span class="line"> 	}</span><br><span class="line"> }</span><br><span class="line"><span class="addition">+#else</span></span><br><span class="line"><span class="addition">+void scheduler()</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct proc *p;</span></span><br><span class="line"><span class="addition">+	struct proc *nxt_proc;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	for (;;) {</span></span><br><span class="line"><span class="addition">+		/*</span></span><br><span class="line"><span class="addition">+		 * Find the process with the smallest stride</span></span><br><span class="line"><span class="addition">+		 */</span></span><br><span class="line"><span class="addition">+		nxt_proc = 0;</span></span><br><span class="line"><span class="addition">+		for (p = pool; p &lt; &amp;pool[NPROC]; p++) {</span></span><br><span class="line"><span class="addition">+			if (p-&gt;state == RUNNABLE) {</span></span><br><span class="line"><span class="addition">+				if (nxt_proc == 0 || p-&gt;stride &lt; nxt_proc-&gt;stride)</span></span><br><span class="line"><span class="addition">+					nxt_proc = p;</span></span><br><span class="line"><span class="addition">+			}</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+		if (nxt_proc) {</span></span><br><span class="line"><span class="addition">+			p = nxt_proc;</span></span><br><span class="line"><span class="addition">+			p-&gt;state = RUNNING;</span></span><br><span class="line"><span class="addition">+			current_proc = p;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+			if (p-&gt;priority &gt; 0)</span></span><br><span class="line"><span class="addition">+				p-&gt;stride += p-&gt;pass;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+			swtch(&amp;idle.context, &amp;p-&gt;context);</span></span><br><span class="line"><span class="addition">+			current_proc = &amp;idle;</span></span><br><span class="line"><span class="addition">+		} else</span></span><br><span class="line"><span class="addition">+			// No runnable processes, wait for interrupt</span></span><br><span class="line"><span class="addition">+			asm volatile("wfi");</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"> </span><br><span class="line"> // Switch to scheduler.  Must hold only p-&gt;lock</span><br><span class="line"> // and have changed proc-&gt;state. Saves and restores</span><br><span class="line"><span class="meta">@@ -185,6 +223,9 @@</span> int fork()</span><br><span class="line"> 	// Cause fork to return 0 in the child.</span><br><span class="line"> 	np-&gt;trapframe-&gt;a0 = 0;</span><br><span class="line"> 	np-&gt;parent = p;</span><br><span class="line"><span class="addition">+	np-&gt;stride = p-&gt;stride;</span></span><br><span class="line"><span class="addition">+	np-&gt;priority = p-&gt;priority;</span></span><br><span class="line"><span class="addition">+	np-&gt;pass = p-&gt;pass;</span></span><br><span class="line"> 	np-&gt;state = RUNNABLE;</span><br><span class="line"> 	add_task(np);</span><br><span class="line"> 	return np-&gt;pid;</span><br><span class="line"><span class="comment">diff --git a/os/proc.h b/os/proc.h</span></span><br><span class="line"><span class="comment">index 85a527c..d7bb108 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.h</span></span><br><span class="line"><span class="comment">+++ b/os/proc.h</span></span><br><span class="line"><span class="meta">@@ -47,6 +47,9 @@</span> struct proc {</span><br><span class="line"> 	struct file *files[FD_BUFFER_SIZE];</span><br><span class="line"> 	uint64 program_brk;</span><br><span class="line"> 	uint64 heap_bottom;</span><br><span class="line"><span class="addition">+	uint64 stride;</span></span><br><span class="line"><span class="addition">+	int priority;</span></span><br><span class="line"><span class="addition">+	uint64 pass;</span></span><br><span class="line"> };</span><br><span class="line"> </span><br><span class="line"> int cpuid();</span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index b3a354a..2611e9c 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -155,8 +155,15 @@</span> uint64 sys_spawn(uint64 va)</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> uint64 sys_set_priority(long long prio){</span><br><span class="line"><span class="deletion">-    // TODO: your job is to complete the sys call</span></span><br><span class="line"><span class="deletion">-    return -1;</span></span><br><span class="line"><span class="addition">+	if (prio &lt; 2)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	p-&gt;priority = prio;</span></span><br><span class="line"><span class="addition">+	p-&gt;pass = BIG_STRIDE / p-&gt;priority;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return prio;</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -318,6 +325,9 @@</span> void syscall()</span><br><span class="line"> 	case SYS_spawn:</span><br><span class="line"> 		ret = sys_spawn(args[0]);</span><br><span class="line"> 		break;</span><br><span class="line"><span class="addition">+	case SYS_setpriority:</span></span><br><span class="line"><span class="addition">+		ret = sys_set_priority(args[0]);</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"> 	case SYS_sbrk:</span><br><span class="line"> 		ret = sys_sbrk(args[0]);</span><br><span class="line"> 		break;</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.50.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>开始我以为写得没问题了，结果跑了一下 <code>ch5_usertest</code> 显示
<code>[PANIC 5] os/queue.c:13: queue shouldn't be overflow</code>。看了一下代码，是因为和原来简单的
RR 调度冲突了，引入新的调度算法后，原来依靠队列 FIFO
的调度就不应该再被使用了，于是就有了以下更改：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 556473656e043aa5dc748f632ed75a9c4a3d5aaf Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Fri, 1 Aug 2025 22:37:05 +0800</span><br><span class="line">Subject: [PATCH 5/7] refactor scheduler from obsolete task queue</span><br><span class="line"></span><br><span class="line">This change resolves a panic that occurred after implementing the stride scheduler.</span><br><span class="line"></span><br><span class="line">The root cause of the issue was a design mismatch between the new scheduling logic</span><br><span class="line">and legacy code. The Stride scheduler selects the next process by directly iterating</span><br><span class="line">through the global process pool, making the task_queue obsolete. However, functions</span><br><span class="line">like yield(), fork(), and etc were still calling add_task(), which continued to</span><br><span class="line">enqueue processes into a queue that was never dequeued from, inevitably leading to an overflow.</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/loader.c  |  2 +-</span><br><span class="line"> os/proc.c    | 23 +++++++++++++++--------</span><br><span class="line"> os/proc.h    |  1 -</span><br><span class="line"> os/queue.c   |  2 ++</span><br><span class="line"> os/syscall.c |  2 +-</span><br><span class="line"> 5 files changed, 19 insertions(+), 11 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/loader.c b/os/loader.c</span></span><br><span class="line"><span class="comment">index 77be56b..9e3fad4 100644</span></span><br><span class="line"><span class="comment">--- a/os/loader.c</span></span><br><span class="line"><span class="comment">+++ b/os/loader.c</span></span><br><span class="line"><span class="meta">@@ -99,6 +99,6 @@</span> int load_init_app()</span><br><span class="line"> 	}</span><br><span class="line"> 	debugf("load init proc %s", INIT_PROC);</span><br><span class="line"> 	loader(id, p);</span><br><span class="line"><span class="deletion">-	add_task(p);</span></span><br><span class="line"><span class="addition">+	// add_task(p);</span></span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"><span class="comment">diff --git a/os/proc.c b/os/proc.c</span></span><br><span class="line"><span class="comment">index c59ef01..a12ffb8 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.c</span></span><br><span class="line"><span class="comment">+++ b/os/proc.c</span></span><br><span class="line"><span class="meta">@@ -3,7 +3,7 @@</span></span><br><span class="line"> #include "loader.h"</span><br><span class="line"> #include "trap.h"</span><br><span class="line"> #include "vm.h"</span><br><span class="line"><span class="deletion">-#include "queue.h"</span></span><br><span class="line"><span class="addition">+//#include "queue.h"</span></span><br><span class="line"> </span><br><span class="line"> struct proc pool[NPROC];</span><br><span class="line"> __attribute__((aligned(16))) char kstack[NPROC][PAGE_SIZE];</span><br><span class="line"><span class="meta">@@ -12,7 +12,7 @@</span> __attribute__((aligned(4096))) char trapframe[NPROC][TRAP_PAGE_SIZE];</span><br><span class="line"> extern char boot_stack_top[];</span><br><span class="line"> struct proc *current_proc;</span><br><span class="line"> struct proc idle;</span><br><span class="line"><span class="deletion">-struct queue task_queue;</span></span><br><span class="line"><span class="addition">+//struct queue task_queue;</span></span><br><span class="line"> </span><br><span class="line"> int threadid()</span><br><span class="line"> {</span><br><span class="line"><span class="meta">@@ -36,7 +36,7 @@</span> void proc_init()</span><br><span class="line"> 	idle.kstack = (uint64)boot_stack_top;</span><br><span class="line"> 	idle.pid = IDLE_PID;</span><br><span class="line"> 	current_proc = &amp;idle;</span><br><span class="line"><span class="deletion">-	init_queue(&amp;task_queue);</span></span><br><span class="line"><span class="addition">+	// init_queue(&amp;task_queue);</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> int allocpid()</span><br><span class="line"><span class="meta">@@ -45,6 +45,12 @@</span> int allocpid()</span><br><span class="line"> 	return PID++;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * The fetch_task and add_task function is no longer</span></span><br><span class="line"><span class="addition">+ * needed with the stride scheduler, as the scheduler</span></span><br><span class="line"><span class="addition">+ * now iterates through the process pool directly.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+#if 0</span></span><br><span class="line"> struct proc *fetch_task()</span><br><span class="line"> {</span><br><span class="line"> 	int index = pop_queue(&amp;task_queue);</span><br><span class="line"><span class="meta">@@ -58,9 +64,10 @@</span> struct proc *fetch_task()</span><br><span class="line"> </span><br><span class="line"> void add_task(struct proc *p)</span><br><span class="line"> {</span><br><span class="line"><span class="deletion">-	push_queue(&amp;task_queue, p - pool);</span></span><br><span class="line"><span class="deletion">-	debugf("add task %d(pid=%d) to task queue\n", p - pool, p-&gt;pid);</span></span><br><span class="line"><span class="addition">+	// push_queue(&amp;task_queue, p - pool);</span></span><br><span class="line"><span class="addition">+	// debugf("add task %d(pid=%d) to task queue\n", p - pool, p-&gt;pid);</span></span><br><span class="line"> }</span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"> </span><br><span class="line"> // Look in the process table for an UNUSED proc.</span><br><span class="line"> // If found, initialize state required to run in the kernel.</span><br><span class="line"><span class="meta">@@ -184,7 +191,7 @@</span> void sched()</span><br><span class="line"> void yield()</span><br><span class="line"> {</span><br><span class="line"> 	current_proc-&gt;state = RUNNABLE;</span><br><span class="line"><span class="deletion">-	add_task(current_proc);</span></span><br><span class="line"><span class="addition">+	// add_task(current_proc);</span></span><br><span class="line"> 	sched();</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -227,7 +234,7 @@</span> int fork()</span><br><span class="line"> 	np-&gt;priority = p-&gt;priority;</span><br><span class="line"> 	np-&gt;pass = p-&gt;pass;</span><br><span class="line"> 	np-&gt;state = RUNNABLE;</span><br><span class="line"><span class="deletion">-	add_task(np);</span></span><br><span class="line"><span class="addition">+	// add_task(np);</span></span><br><span class="line"> 	return np-&gt;pid;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -269,7 +276,7 @@</span> int wait(int pid, int *code)</span><br><span class="line"> 			return -1;</span><br><span class="line"> 		}</span><br><span class="line"> 		p-&gt;state = RUNNABLE;</span><br><span class="line"><span class="deletion">-		add_task(p);</span></span><br><span class="line"><span class="addition">+		// add_task(p);</span></span><br><span class="line"> 		sched();</span><br><span class="line"> 	}</span><br><span class="line"> }</span><br><span class="line"><span class="comment">diff --git a/os/proc.h b/os/proc.h</span></span><br><span class="line"><span class="comment">index d7bb108..e32d656 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.h</span></span><br><span class="line"><span class="comment">+++ b/os/proc.h</span></span><br><span class="line"><span class="meta">@@ -63,7 +63,6 @@</span> int fork();</span><br><span class="line"> int exec(char *);</span><br><span class="line"> int wait(int, int *);</span><br><span class="line"> void add_task(struct proc *);</span><br><span class="line"><span class="deletion">-struct proc *pop_task();</span></span><br><span class="line"> struct proc *allocproc();</span><br><span class="line"> void freeproc(struct proc *p);</span><br><span class="line"> int fdalloc(struct file *);</span><br><span class="line"><span class="comment">diff --git a/os/queue.c b/os/queue.c</span></span><br><span class="line"><span class="comment">index 5f04063..60d2860 100644</span></span><br><span class="line"><span class="comment">--- a/os/queue.c</span></span><br><span class="line"><span class="comment">+++ b/os/queue.c</span></span><br><span class="line"><span class="meta">@@ -1,3 +1,4 @@</span></span><br><span class="line"><span class="addition">+#if 0</span></span><br><span class="line"> #include "queue.h"</span><br><span class="line"> #include "defs.h"</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -27,3 +28,4 @@</span> int pop_queue(struct queue *q)</span><br><span class="line"> 		q-&gt;empty = 1;</span><br><span class="line"> 	return value;</span><br><span class="line"> }</span><br><span class="line"><span class="addition">+#endif</span></span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 2611e9c..6dc9829 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -149,7 +149,7 @@</span> uint64 sys_spawn(uint64 va)</span><br><span class="line"> 		return -1;</span><br><span class="line"> 	}</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-	add_task(np);</span></span><br><span class="line"><span class="addition">+	// add_task(np);</span></span><br><span class="line"> </span><br><span class="line"> 	return np-&gt;pid;</span><br><span class="line"> }</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.50.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>这样修完就没问题了。不过我们还没处理可能的 stride
的溢出，虽然实验也不要求但是我觉得还是处理一下更好：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 529b7de53ab3dd0ebdc1de3e388797f97540f933 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Fri, 1 Aug 2025 23:17:25 +0800</span><br><span class="line">Subject: [PATCH 6/7] Prevent stride overflow in scheduler</span><br><span class="line"></span><br><span class="line">This commit addresses a potential long-term stability issue in the stride scheduling algo</span><br><span class="line">where the stride value could overflow its uint64 type. Such an overflow would wrap around</span><br><span class="line">and disrupt the scheduler's fairness.</span><br><span class="line"></span><br><span class="line">To resolve this, the scheduler logic in proc.c has been updated to normalize stride values</span><br><span class="line">during each scheduling cycle. After identifying the runnable process with the minimum</span><br><span class="line">stride, this minimum value is subtracted from the strides of all other runnable processes.</span><br><span class="line"></span><br><span class="line">This operation preserves the relative differences between strides, ensuring the scheduling</span><br><span class="line">order remains correct, while pulling all stride values down to a smaller range and preventing</span><br><span class="line">them from growing indefinitely. This change makes the scheduler robust against overflow without</span><br><span class="line">altering its proportional-share behavior, ensuring system stability over long periods of operation.</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/proc.c | 15 +++++++++++++++</span><br><span class="line"> 1 file changed, 15 insertions(+)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/proc.c b/os/proc.c</span></span><br><span class="line"><span class="comment">index a12ffb8..78429cb 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.c</span></span><br><span class="line"><span class="comment">+++ b/os/proc.c</span></span><br><span class="line"><span class="meta">@@ -156,6 +156,21 @@</span> void scheduler()</span><br><span class="line"> 		}</span><br><span class="line"> </span><br><span class="line"> 		if (nxt_proc) {</span><br><span class="line"><span class="addition">+			/*</span></span><br><span class="line"><span class="addition">+			 * To prevent stride overflow, subtract the minimum</span></span><br><span class="line"><span class="addition">+			 * stride from all runnable processes. This keeps the</span></span><br><span class="line"><span class="addition">+			 * relative order and prevents the stride values from</span></span><br><span class="line"><span class="addition">+			 * growing indefinitely.</span></span><br><span class="line"><span class="addition">+			 */</span></span><br><span class="line"><span class="addition">+			uint64 min_stride = nxt_proc-&gt;stride;</span></span><br><span class="line"><span class="addition">+			if (min_stride &gt; 0) {</span></span><br><span class="line"><span class="addition">+				for (p = pool; p &lt; &amp;pool[NPROC]; p++) {</span></span><br><span class="line"><span class="addition">+					if (p-&gt;state == RUNNABLE) {</span></span><br><span class="line"><span class="addition">+						p-&gt;stride -= min_stride;</span></span><br><span class="line"><span class="addition">+					}</span></span><br><span class="line"><span class="addition">+				}</span></span><br><span class="line"><span class="addition">+			}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 			p = nxt_proc;</span><br><span class="line"> 			p-&gt;state = RUNNING;</span><br><span class="line"> 			current_proc = p;</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.50.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>做了上面的更改之后，我觉得真的是非常完美，一点问题都没有了。结果怎么着，运行完测例后输入
<code>quit</code> 想退出
usershell，结果没反应了？？左思右想想不通问题出在哪儿，又回去翻了一下原本的
<code>scheduler()</code> 函数实现，发现了问题。我在引入 stride
调度算法的提交中，如果没有 <code>nxt_proc</code>，会进入 wfi
状态，而在原本的实现中，如果没有新任务，会执行
<code>panic("all app are over!\n");</code>，这就是我输入
<code>quit</code>
后无法退出没有反应的问题所在，一直等待中断可不就没反应了吗？于是就有了下面最后这个修复提交：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From f6e510a5fe5e6fe3a8f40e9a883b12d38c5055d7 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Sat, 2 Aug 2025 00:44:16 +0800</span><br><span class="line">Subject: [PATCH 7/7] use panic() instead of inline assembly wfi</span><br><span class="line"></span><br><span class="line">lol, if there's no existing process, we shouldn't wait for interrupt but</span><br><span class="line">to panic when input is quit.</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/proc.c | 3 +--</span><br><span class="line"> 1 file changed, 1 insertion(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/proc.c b/os/proc.c</span></span><br><span class="line"><span class="comment">index 78429cb..2e18321 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.c</span></span><br><span class="line"><span class="comment">+++ b/os/proc.c</span></span><br><span class="line"><span class="meta">@@ -181,8 +181,7 @@</span> void scheduler()</span><br><span class="line"> 			swtch(&amp;idle.context, &amp;p-&gt;context);</span><br><span class="line"> 			current_proc = &amp;idle;</span><br><span class="line"> 		} else</span><br><span class="line"><span class="deletion">-			// No runnable processes, wait for interrupt</span></span><br><span class="line"><span class="deletion">-			asm volatile("wfi");</span></span><br><span class="line"><span class="addition">+			panic("all app are over!\n");</span></span><br><span class="line"> 	}</span><br><span class="line"> }</span><br><span class="line"> #endif</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.50.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><del>我再也不用内联汇编了😭😭</del></p>
<h2 id="问答作业">问答作业</h2>
<h3 id="stride-算法深入">stride 算法深入</h3>
<p><em>stride 算法原理非常简单，但是有一个比较大的问题。例如两个 pass =
10 的进程，使用 8bit 无符号整形储存 stride，p1.stride = 255，p2.stride =
250，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。</em></p>
<ul>
<li><em>实际情况是轮到 p1 执行吗？为什么？</em></li>
</ul>
<p><em>我们之前要求进程优先级 &gt;= 2
其实就是为了解决这个问题。可以证明，<strong>在不考虑溢出的情况下</strong>,
在进程优先级全部 &gt;= 2 的情况下，如果严格按照算法执行，那么 STRIDE_MAX
– STRIDE_MIN &lt;= BigStride / 2。</em></p>
<ul>
<li><em>为什么？尝试简单说明（传达思想即可，不要求严格证明）。</em></li>
</ul>
<p><em>已知以上结论，<strong>在考虑溢出的情况下</strong>，假设我们通过逐个比较得到
Stride 最小的进程，请设计一个合适的比较函数，用来正确比较两个 Stride
的真正大小：</em></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> Stride_t;</span><br><span class="line"><span class="type">const</span> Stride_t BIG_STRIDE = <span class="number">0xffffffffffffffffU</span>LL;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(Stride_t a, Stride_t b)</span> {</span><br><span class="line">    <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">    <span class="comment">// return 1 if a &gt; b</span></span><br><span class="line">    <span class="comment">// return -1 if a &lt; b</span></span><br><span class="line">    <span class="comment">// return 0 if a == b</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em>例子：假设使用 8 bits 储存 stride, BigStride =
255。那么：</em></p>
<ul>
<li><em>cmp(125, 255) == 1</em></li>
<li><em>cmp(129, 255) == -1</em></li>
</ul>
<h2 id="问答作业答案">问答作业答案</h2>
<h3 id="stride-算法深入-1">stride 算法深入</h3>
<p><em>stride 算法原理非常简单，但是有一个比较大的问题。例如两个 pass =
10 的进程，使用 8bit 无符号整形储存 stride，p1.stride = 255，p2.stride =
250，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。</em></p>
<ul>
<li><p><em>实际情况是轮到 p1 执行吗？为什么？</em></p>
<p>不是，p1.stride = 255，p2.stride = 250。p2 执行后，p2.stride = (250 +
10) % 256 = 4。于是 p1.stride = 255, p2.stride = 4，4 &lt;
255，所以会选择 p2 继续执行。</p></li>
</ul>
<p><em>我们之前要求进程优先级 &gt;= 2
其实就是为了解决这个问题。可以证明，<strong>在不考虑溢出的情况下</strong>,
在进程优先级全部 &gt;= 2 的情况下，如果严格按照算法执行，那么 STRIDE_MAX
– STRIDE_MIN &lt;= BigStride / 2。</em></p>
<ul>
<li><p><em>为什么？尝试简单说明（传达思想即可，不要求严格证明）。</em></p>
<p>当所有进程优先级 ≥ 2 时，最大的 stride 增量是 BigStride /
2，于是在最坏情况下，一个进程一直不执行，其他进程轮流执行。假设进程 A 的
stride 最小，进程 B 的 stride 最大，当 B 再次被选中执行时，A 和 B 的
stride 差值最多是 BigStride / 2，因为每次增量最多是
BigStride/2，所以差值不会超过这个限制。</p></li>
</ul>
<p><em>已知以上结论，<strong>在考虑溢出的情况下</strong>，假设我们通过逐个比较得到
Stride 最小的进程，请设计一个合适的比较函数，用来正确比较两个 Stride
的真正大小：</em></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> Stride_t;</span><br><span class="line"><span class="type">const</span> Stride_t BIG_STRIDE = <span class="number">0xffffffffffffffffU</span>LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(Stride_t a, Stride_t b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Stride_t diff = a - b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= BIG_STRIDE / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><em>例子：假设使用 8 bits 储存 stride, BigStride =
255。那么：</em></p>
<ul>
<li><em>cmp(125, 255) == 1</em></li>
<li><em>cmp(129, 255) == -1</em></li>
</ul>
<h2 id="选做题目">选做题目</h2>
<h3 id="选作题目列表">选作题目列表</h3>
<ul>
<li>（6 分）相同页面共享（Same page sharing）fork 时的 Copy on Write</li>
<li>（4 分）实现多种 (&gt;3 种) 调度算法：可动态提升 / 降低优先级的多级反馈队列、实时调度等</li>
<li>（7 分）多核支持与多核调度（支持进程迁移和多核模式执行应用程序，但在内核中没有抢占和多核支持）</li>
</ul>
<p>这次一道选做题目都没有写，时间不够了，如果之后有时间再补吧。<del>（虽然大概率是没有的</del></p>
]]></content>
      <categories>
        <category>uCore</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>riscv</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore lab4 实验报告</title>
    <url>/uCore/57361.html</url>
    <content><![CDATA[<p>做这节实验的时候是真的头疼，光是新增的代码就读了好久，以前也确实没接触过文件系统相关的东西，感觉很折磨。后面写系统调用也是东一榔头西一棒槌的，感觉未来还是得再复盘。</p>
<h2 id="本章任务">本章任务</h2>
<ul>
<li><code>ch6b_usertest</code></li>
<li>merge ch5 的改动，然后再次测试 <code>ch6_usertest</code>。</li>
<li>完成本章问答作业。</li>
<li>完成本章编程作业。</li>
<li>最终，完成实验报告并 push 你的 ch6 分支到远程仓库。</li>
</ul>
<h2 id="编程作业">编程作业</h2>
<h3 id="硬链接">硬链接</h3>
<p>你的电脑桌面是什么样的？放满了图标吗？反正我的 windows
是这样的。显然很少人会真的把可执行文件放到桌面上，桌面图标其实都是一些快捷方式。或者用
unix 的术语来说：软链接。为了减少工作量，我们今天来实现软链接的兄弟：<a href="https://en.wikipedia.org/wiki/Hard_link">硬链接</a>。</p>
<p>硬链接要求两个不同的目录项指向同一个文件，在我们的文件系统中也就是两个不同名称目录项指向同一个磁盘块。本节要求实现三个系统调用
<code>sys_linkat</code>、<code>sys_unlinkat</code>、<code>sys_stat</code>。</p>
<p><strong>linkat</strong>：</p>
<ul>
<li>syscall ID: 37</li>
<li>功能：创建一个文件的一个硬链接（<a href="https://linux.die.net/man/2/linkat">linkat 标准接口</a>）。</li>
<li>接口：<code>int linkat(int olddirfd, char* oldpath, int newdirfd, char* newpath, unsigned int flags)</code></li>
<li>参数：
<ul>
<li><code>olddirfd</code>，<code>newdirfd</code>:
仅为了兼容性考虑，本次实验中始终为 <code>AT_FDCWD</code>
(-100)，可以忽略。</li>
<li><code>flags</code>: 仅为了兼容性考虑，本次实验中始终为
0，可以忽略。</li>
<li><code>oldpath</code>：原有文件路径。</li>
<li><code>newpath</code>: 新的链接文件路径。</li>
</ul></li>
<li>说明：
<ul>
<li>为了方便，不考虑新文件路径已经存在的情况（属于未定义行为）。除非出现新旧名字一致的情况，此时需要返回
-1。</li>
<li>返回值：如果出现了错误则返回 -1，否则返回 0。</li>
</ul></li>
<li>可能的错误
<ul>
<li>链接同名文件。</li>
</ul></li>
</ul>
<p><strong>unlinkat</strong>:</p>
<ul>
<li>syscall ID: 35</li>
<li>功能：取消一个文件路径到文件的链接（<a href="https://linux.die.net/man/2/unlinkat">unlinkat 标准接口</a>）。</li>
<li>接口：<code>int unlinkat(int dirfd, char* path, unsigned int flags)</code></li>
<li>参数：
<ul>
<li><code>dirfd</code>: 仅为了兼容性考虑，本次实验中始终为
<code>AT_FDCWD</code> (-100)，可以忽略。</li>
<li><code>flags</code>: 仅为了兼容性考虑，本次实验中始终为
0，可以忽略。</li>
<li><code>path</code>：文件路径。</li>
</ul></li>
<li>说明：
<ul>
<li>需要注意 unlink 掉所有硬链接后彻底删除文件的情况。</li>
</ul></li>
<li>返回值：如果出现了错误则返回 -1，否则返回 0。</li>
<li>可能的错误
<ul>
<li>文件不存在。</li>
</ul></li>
</ul>
<p><strong>fstat</strong>:</p>
<ul>
<li>syscall ID: 80</li>
<li>功能：获取文件状态。</li>
<li>接口：<code>int fstat(int fd, struct Stat* st)</code></li>
<li>参数：
<ul>
<li><p><code>fd</code>: 文件描述符</p></li>
<li><p><code>st</code>: 文件状态结构体</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> {</span></span><br><span class="line">  uint64 dev,     <span class="comment">// 文件所在磁盘驱动号，该实现写死为 0 即可。</span></span><br><span class="line">  uint64 ino,     <span class="comment">// inode 文件所在 inode 编号</span></span><br><span class="line">  uint32 mode,    <span class="comment">// 文件类型</span></span><br><span class="line">  uint32 nlink,   <span class="comment">// 硬链接数量，初始为1</span></span><br><span class="line">  uint64 pad[<span class="number">7</span>],  <span class="comment">// 无需考虑，为了兼容性设计</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件类型只需要考虑:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIR 0x040000              <span class="comment">// directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE 0x100000             <span class="comment">// ordinary regular file</span></span></span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ul></li>
<li>返回值：如果出现了错误则返回 -1，否则返回 0。</li>
<li>可能的错误
<ul>
<li>fd 无效。</li>
<li>st 地址非法。</li>
</ul></li>
</ul>
<h3 id="tips">Tips</h3>
<ul>
<li>需要给 inode 和 dinode 都增加 link
的计数，但强烈建议不要改变整个数据结构的大小，事实上，推荐你修改一个
pad。</li>
<li>os 和 nfs 的修改需要同步，只不过 nfs 比较简单，只需要初始化 link
计数为 1 就行（可以通过修改 <code>ialloc</code> 来实现）。</li>
<li>unlink 有删除文件的语义，如果 link 计数为 0，需要删除 inode
和对应的数据块，为此你需要正确调用
<code>ivalid</code>、<code>iupdate</code>、<code>iput</code>（如果测试遇到 bug 了不妨再看看这句话），并取消
<code>iput</code> 中判断条件的注释。你可能需要修改 <code>iput</code>
注释中的变量名（如果你的计数变量不叫 nlink）。</li>
</ul>
<h2 id="编程作业答案">编程作业答案</h2>
<p>首先，简单把 ch5
的提交摘过来，或者直接合并分支也行，处理冲突很简单。测试一下
<code>make test BASE=2</code>，发现编译不通过，是 <code>spawn</code>
的系统调用迁移到 ch6 后，与新的 loader.c 不兼容导致的，看一下 ch6
的历史提交更改了什么就能很快修复了：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 58af914164e469e653ee063a4050251fe8a5d86f Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Sat, 9 Aug 2025 15:06:32 +0800</span><br><span class="line">Subject: [PATCH 08/11] syscall: adapt sys_spawn to ch6</span><br><span class="line"></span><br><span class="line">os/syscall.c: In function 'sys_spawn':</span><br><span class="line">os/syscall.c:188:7: error: implicit declaration of function 'get_id_by_name' [-Werror=implicit-function-declaration]</span><br><span class="line">  188 |  id = get_id_by_name(name);</span><br><span class="line">      |       ^~~~~~~~~~~~~~</span><br><span class="line">os/syscall.c:197:6: error: implicit declaration of function 'loader'; did you mean 'bin_loader'? [-Werror=implicit-function-declaration]</span><br><span class="line">  197 |  if (loader(id, np) &lt; 0) {</span><br><span class="line">      |      ^~~~~~</span><br><span class="line">      |      bin_loader</span><br><span class="line"></span><br><span class="line">This commit refactors the sys_spawn system call to make it compatible with the new</span><br><span class="line">filesystem-based program loading mechanism introduced in ch6.</span><br><span class="line"></span><br><span class="line">The previous implementation of spawn was designed for the ch5 architecture, where applications</span><br><span class="line">were loaded from a pre-compiled, in-memory archive using an internal ID. With the transition to</span><br><span class="line">a proper on-disk filesystem, this loading method became obsolete, causing the spawn system call to fail.</span><br><span class="line"></span><br><span class="line">It now accepts a file path string from the user, uses namei() to resolve this path to</span><br><span class="line">its corresponding inode on the disk. If the file is found, it allocates a new process</span><br><span class="line">and uses the bin_loader() function to load the executable content from the inode into</span><br><span class="line">the new process's address space. Otherwise, use init_stdio() to initialize standard I/O</span><br><span class="line">for the new process to avoid errors like "[ERROR &lt;pid&gt;]invalid fd 1" because of</span><br><span class="line">p-&gt;files[fd], that which files[1] is null. This change fully integrates spawn with the</span><br><span class="line">filesystem, allowing it to correctly load and execute programs from disk.</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/syscall.c | 18 +++++++++++++-----</span><br><span class="line"> 1 file changed, 13 insertions(+), 5 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 2cb67f8..d8be06e 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -177,7 +177,7 @@</span> uint64 sys_spawn(uint64 va)</span><br><span class="line"> 	struct proc *p = curr_proc();</span><br><span class="line"> 	char name[MAX_STR_LEN];</span><br><span class="line"> 	struct proc *np;</span><br><span class="line"><span class="deletion">-	int id;</span></span><br><span class="line"><span class="addition">+	struct inode *ip;</span></span><br><span class="line"> </span><br><span class="line"> 	/*</span><br><span class="line"> 	 * Copy the filename from user space to kernel space.</span><br><span class="line"><span class="meta">@@ -185,19 +185,27 @@</span> uint64 sys_spawn(uint64 va)</span><br><span class="line"> 	if (copyinstr(p-&gt;pagetable, name, va, MAX_STR_LEN) &lt; 0)</span><br><span class="line"> 		return -1;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-	id = get_id_by_name(name);</span></span><br><span class="line"><span class="deletion">-	if (id &lt; 0)</span></span><br><span class="line"><span class="addition">+	if ((ip = namei(name)) == 0)</span></span><br><span class="line"> 		return -1;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-	if ((np = allocproc()) == 0)</span></span><br><span class="line"><span class="addition">+	if ((np = allocproc()) == 0) {</span></span><br><span class="line"><span class="addition">+		iput(ip);</span></span><br><span class="line"> 		return -1;</span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	/*</span></span><br><span class="line"><span class="addition">+	 * Initialize standard I/O for the new process.</span></span><br><span class="line"><span class="addition">+	 */</span></span><br><span class="line"><span class="addition">+	init_stdio(np);</span></span><br><span class="line"> </span><br><span class="line"> 	np-&gt;parent = p;</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-	if (loader(id, np) &lt; 0) {</span></span><br><span class="line"><span class="addition">+	if (bin_loader(ip, np) &lt; 0) {</span></span><br><span class="line"> 		freeproc(np);</span><br><span class="line"><span class="addition">+		iput(ip);</span></span><br><span class="line"> 		return -1;</span><br><span class="line"> 	}</span><br><span class="line"><span class="addition">+	iput(ip);</span></span><br><span class="line"> </span><br><span class="line"> 	// add_task(np);</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>接下来测试一下
ch6_usertest，可以看见除了需要实现的三个系统调用以外，别的测例都是通过的，那么接下来实现实验要求的三个系统调用就可以了，这里我为了防止系统调用的函数体冗余，还新写了几个函数。简单一点的实现肯定也是没事的，因为前面实验指导书说过我们的
os
的文件系统只有一层，不过实现得更加细致肯定没有问题。修改结构体时别忘了对齐，不然镜像跑不起来。初始化也要相应做好，不然测例通不过。</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 4296a91d6325835336b6f848882d125d617b6255 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Sat, 9 Aug 2025 22:44:04 +0800</span><br><span class="line">Subject: [PATCH 09/11] Implement fstat syscall</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> nfs/fs.c     |  3 ++-</span><br><span class="line"> nfs/fs.h     |  3 ++-</span><br><span class="line"> os/file.h    |  3 ++-</span><br><span class="line"> os/fs.c      |  9 ++++++---</span><br><span class="line"> os/fs.h      | 14 +++++++++++++-</span><br><span class="line"> os/syscall.c | 37 +++++++++++++++++++++++++++++++++++--</span><br><span class="line"> 6 files changed, 60 insertions(+), 9 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/nfs/fs.c b/nfs/fs.c</span></span><br><span class="line"><span class="comment">index acff784..6a5d4c3 100644</span></span><br><span class="line"><span class="comment">--- a/nfs/fs.c</span></span><br><span class="line"><span class="comment">+++ b/nfs/fs.c</span></span><br><span class="line"><span class="meta">@@ -203,8 +203,9 @@</span> uint ialloc(ushort type)</span><br><span class="line"> </span><br><span class="line"> 	bzero(&amp;din, sizeof(din));</span><br><span class="line"> 	din.type = xshort(type);</span><br><span class="line"><span class="deletion">-	din.size = xint(0);</span></span><br><span class="line"> 	// LAB4: You may want to init link count here</span><br><span class="line"><span class="addition">+	din.nlink = xshort(1);</span></span><br><span class="line"><span class="addition">+	din.size = xint(0);</span></span><br><span class="line"> 	winode(inum, &amp;din);</span><br><span class="line"> 	return inum;</span><br><span class="line"> }</span><br><span class="line"><span class="comment">diff --git a/nfs/fs.h b/nfs/fs.h</span></span><br><span class="line"><span class="comment">index 2e9670a..263d9b0 100644</span></span><br><span class="line"><span class="comment">--- a/nfs/fs.h</span></span><br><span class="line"><span class="comment">+++ b/nfs/fs.h</span></span><br><span class="line"><span class="meta">@@ -45,7 +45,8 @@</span> struct superblock {</span><br><span class="line"> // On-disk inode structure</span><br><span class="line"> struct dinode {</span><br><span class="line"> 	short type; // File type</span><br><span class="line"><span class="deletion">-	short pad[3];</span></span><br><span class="line"><span class="addition">+	short pad[2];</span></span><br><span class="line"><span class="addition">+	short nlink;</span></span><br><span class="line"> 	uint size; // Size of file (bytes)</span><br><span class="line"> 	uint addrs[NDIRECT + 1]; // Data block addresses</span><br><span class="line"> };</span><br><span class="line"><span class="comment">diff --git a/os/file.h b/os/file.h</span></span><br><span class="line"><span class="comment">index 433f0a1..aae675a 100644</span></span><br><span class="line"><span class="comment">--- a/os/file.h</span></span><br><span class="line"><span class="comment">+++ b/os/file.h</span></span><br><span class="line"><span class="meta">@@ -15,9 +15,10 @@</span> struct inode {</span><br><span class="line"> 	int ref; // Reference count</span><br><span class="line"> 	int valid; // inode has been read from disk?</span><br><span class="line"> 	short type; // copy of disk inode</span><br><span class="line"><span class="addition">+	// LAB4: You may need to add link count here</span></span><br><span class="line"><span class="addition">+	short nlink;</span></span><br><span class="line"> 	uint size;</span><br><span class="line"> 	uint addrs[NDIRECT + 1];</span><br><span class="line"><span class="deletion">-	// LAB4: You may need to add link count here</span></span><br><span class="line"> };</span><br><span class="line"> </span><br><span class="line"> // Defines a file in memory that provides information about the current use of the file and the corresponding inode location</span><br><span class="line"><span class="comment">diff --git a/os/fs.c b/os/fs.c</span></span><br><span class="line"><span class="comment">index beb8224..91a3d4e 100644</span></span><br><span class="line"><span class="comment">--- a/os/fs.c</span></span><br><span class="line"><span class="comment">+++ b/os/fs.c</span></span><br><span class="line"><span class="meta">@@ -114,6 +114,7 @@</span> struct inode *ialloc(uint dev, short type)</span><br><span class="line"> 		if (dip-&gt;type == 0) { // a free inode</span><br><span class="line"> 			memset(dip, 0, sizeof(*dip));</span><br><span class="line"> 			dip-&gt;type = type;</span><br><span class="line"><span class="addition">+			dip-&gt;nlink = 1;</span></span><br><span class="line"> 			bwrite(bp);</span><br><span class="line"> 			brelse(bp);</span><br><span class="line"> 			return iget(dev, inum);</span><br><span class="line"><span class="meta">@@ -135,8 +136,9 @@</span> void iupdate(struct inode *ip)</span><br><span class="line"> 	bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line"> 	dip = (struct dinode *)bp-&gt;data + ip-&gt;inum % IPB;</span><br><span class="line"> 	dip-&gt;type = ip-&gt;type;</span><br><span class="line"><span class="deletion">-	dip-&gt;size = ip-&gt;size;</span></span><br><span class="line"> 	// LAB4: you may need to update link count here</span><br><span class="line"><span class="addition">+	dip-&gt;nlink = ip-&gt;nlink;</span></span><br><span class="line"><span class="addition">+	dip-&gt;size = ip-&gt;size;</span></span><br><span class="line"> 	memmove(dip-&gt;addrs, ip-&gt;addrs, sizeof(ip-&gt;addrs));</span><br><span class="line"> 	bwrite(bp);</span><br><span class="line"> 	brelse(bp);</span><br><span class="line"><span class="meta">@@ -188,8 +190,9 @@</span> void ivalid(struct inode *ip)</span><br><span class="line"> 		bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line"> 		dip = (struct dinode *)bp-&gt;data + ip-&gt;inum % IPB;</span><br><span class="line"> 		ip-&gt;type = dip-&gt;type;</span><br><span class="line"><span class="deletion">-		ip-&gt;size = dip-&gt;size;</span></span><br><span class="line"> 		// LAB4: You may need to get lint count here</span><br><span class="line"><span class="addition">+		ip-&gt;nlink = dip-&gt;nlink;</span></span><br><span class="line"><span class="addition">+		ip-&gt;size = dip-&gt;size;</span></span><br><span class="line"> 		memmove(ip-&gt;addrs, dip-&gt;addrs, sizeof(ip-&gt;addrs));</span><br><span class="line"> 		brelse(bp);</span><br><span class="line"> 		ip-&gt;valid = 1;</span><br><span class="line"><span class="meta">@@ -208,7 +211,7 @@</span> void ivalid(struct inode *ip)</span><br><span class="line"> void iput(struct inode *ip)</span><br><span class="line"> {</span><br><span class="line"> 	// LAB4: Unmark the condition and change link count variable name (nlink) if needed</span><br><span class="line"><span class="deletion">-	if (ip-&gt;ref == 1 &amp;&amp; ip-&gt;valid &amp;&amp; 0 /*&amp;&amp; ip-&gt;nlink == 0*/) {</span></span><br><span class="line"><span class="addition">+	if (ip-&gt;ref == 1 &amp;&amp; ip-&gt;valid &amp;&amp; ip-&gt;nlink == 0) {</span></span><br><span class="line"> 		// inode has no links and no other references: truncate and free.</span><br><span class="line"> 		itrunc(ip);</span><br><span class="line"> 		ip-&gt;type = 0;</span><br><span class="line"><span class="comment">diff --git a/os/fs.h b/os/fs.h</span></span><br><span class="line"><span class="comment">index efb4674..ddd640c 100644</span></span><br><span class="line"><span class="comment">--- a/os/fs.h</span></span><br><span class="line"><span class="comment">+++ b/os/fs.h</span></span><br><span class="line"><span class="meta">@@ -44,10 +44,11 @@</span> struct superblock {</span><br><span class="line"> // On-disk inode structure</span><br><span class="line"> struct dinode {</span><br><span class="line"> 	short type; // File type</span><br><span class="line"><span class="deletion">-	short pad[3];</span></span><br><span class="line"><span class="addition">+	short pad[2];</span></span><br><span class="line"> 	// LAB4: you can reduce size of pad array and add link count below,</span><br><span class="line"> 	//       or you can just regard a pad as link count.</span><br><span class="line"> 	//       But keep in mind that you'd better keep sizeof(dinode) unchanged</span><br><span class="line"><span class="addition">+	short nlink;</span></span><br><span class="line"> 	uint size; // Size of file (bytes)</span><br><span class="line"> 	uint addrs[NDIRECT + 1]; // Data block addresses</span><br><span class="line"> };</span><br><span class="line"><span class="meta">@@ -72,6 +73,17 @@</span> struct dirent {</span><br><span class="line"> 	char name[DIRSIZ];</span><br><span class="line"> };</span><br><span class="line"> </span><br><span class="line"><span class="addition">+struct stat {</span></span><br><span class="line"><span class="addition">+	uint64 dev;</span></span><br><span class="line"><span class="addition">+	uint64 ino;</span></span><br><span class="line"><span class="addition">+	uint32 mode;</span></span><br><span class="line"><span class="addition">+	uint32 nlink;</span></span><br><span class="line"><span class="addition">+	uint64 pad[7];</span></span><br><span class="line"><span class="addition">+};</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+#define DIR 0x040000</span></span><br><span class="line"><span class="addition">+#define FILE 0x100000</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> // file.h</span><br><span class="line"> struct inode;</span><br><span class="line"> </span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index d8be06e..b880ec6 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -248,10 +248,43 @@</span> uint64 sys_close(int fd)</span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * sys_fstat - get file status</span></span><br><span class="line"><span class="addition">+ * @fd: The file descriptor to query.</span></span><br><span class="line"><span class="addition">+ * @stat: User-space address for the result.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Retrieves information about an open file.</span></span><br><span class="line"><span class="addition">+ * It writes the data to a stat</span></span><br><span class="line"><span class="addition">+ * structure in user space. The structure</span></span><br><span class="line"><span class="addition">+ * includes device, inode number, type,</span></span><br><span class="line"><span class="addition">+ * and the number of hard links.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Returns 0 on success, -1 on error.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"> int sys_fstat(int fd, uint64 stat)</span><br><span class="line"> {</span><br><span class="line"><span class="deletion">-	//TODO: your job is to complete the syscall</span></span><br><span class="line"><span class="deletion">-	return -1;</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	struct file *f = p-&gt;files[fd];</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (fd &lt; 0 || fd &gt; FD_BUFFER_SIZE || f == NULL)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	struct stat st;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	st.dev = f-&gt;ip-&gt;dev;</span></span><br><span class="line"><span class="addition">+	st.ino = f-&gt;ip-&gt;inum;</span></span><br><span class="line"><span class="addition">+	if (f-&gt;ip-&gt;type == T_DIR)</span></span><br><span class="line"><span class="addition">+		st.mode = DIR;</span></span><br><span class="line"><span class="addition">+	else if (f-&gt;ip-&gt;type == T_FILE)</span></span><br><span class="line"><span class="addition">+		st.mode = FILE;</span></span><br><span class="line"><span class="addition">+	else</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	st.nlink = f-&gt;ip-&gt;nlink;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (copyout(p-&gt;pagetable, stat, (char *)&amp;st, sizeof(st)) &lt; 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> int sys_linkat(int olddirfd, uint64 oldpath, int newdirfd, uint64 newpath,</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 5bafc45cca257777c87a0a863db321b65bd3c647 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Sat, 9 Aug 2025 23:06:05 +0800</span><br><span class="line">Subject: [PATCH 10/11] Implement linkat syscall</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/fs.c      | 33 +++++++++++++++++++++++++++++</span><br><span class="line"> os/fs.h      |  1 +</span><br><span class="line"> os/syscall.c | 59 +++++++++++++++++++++++++++++++++++++++++++++++++++-</span><br><span class="line"> 3 files changed, 92 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/fs.c b/os/fs.c</span></span><br><span class="line"><span class="comment">index 91a3d4e..8c38f4d 100644</span></span><br><span class="line"><span class="comment">--- a/os/fs.c</span></span><br><span class="line"><span class="comment">+++ b/os/fs.c</span></span><br><span class="line"><span class="meta">@@ -455,3 +455,36 @@</span> struct inode *namei(char *path)</span><br><span class="line"> 		panic("fs dumped.\n");</span><br><span class="line"> 	return dirlookup(dp, path + skip, 0);</span><br><span class="line"> }</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * @path: The full path to resolve.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Finds the inode of a parent directory.</span></span><br><span class="line"><span class="addition">+ * It parses the given path to find</span></span><br><span class="line"><span class="addition">+ * the last component. Then it returns</span></span><br><span class="line"><span class="addition">+ * the inode of the containing directory.</span></span><br><span class="line"><span class="addition">+ * This is a helper for link and unlink.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Returns inode of parent, or 0 on error.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+struct inode *nameiparent(char *path)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	char *s;</span></span><br><span class="line"><span class="addition">+	struct inode *ip;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Find the last slash in the path string.</span></span><br><span class="line"><span class="addition">+	for (s = path + strlen(path) - 1; s &gt;= path &amp;&amp; *s != '/'; s--);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// If no slash, parent is the root directory.</span></span><br><span class="line"><span class="addition">+	if (s &lt; path)</span></span><br><span class="line"><span class="addition">+		return root_dir();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Temporarily truncate string at the slash</span></span><br><span class="line"><span class="addition">+    // to get the parent path.</span></span><br><span class="line"><span class="addition">+	*s = 0;</span></span><br><span class="line"><span class="addition">+	ip = namei(path);</span></span><br><span class="line"><span class="addition">+	// Restore the slash.</span></span><br><span class="line"><span class="addition">+	*s = '/';</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return ip;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="comment">diff --git a/os/fs.h b/os/fs.h</span></span><br><span class="line"><span class="comment">index ddd640c..01d6e79 100644</span></span><br><span class="line"><span class="comment">--- a/os/fs.h</span></span><br><span class="line"><span class="comment">+++ b/os/fs.h</span></span><br><span class="line"><span class="meta">@@ -99,6 +99,7 @@</span> void iunlock(struct inode *);</span><br><span class="line"> void iunlockput(struct inode *);</span><br><span class="line"> void iupdate(struct inode *);</span><br><span class="line"> struct inode *namei(char *);</span><br><span class="line"><span class="addition">+struct inode *nameiparent(char *path);</span></span><br><span class="line"> struct inode *root_dir();</span><br><span class="line"> int readi(struct inode *, int, uint64, uint, uint);</span><br><span class="line"> int writei(struct inode *, int, uint64, uint, uint);</span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index b880ec6..1f7b761 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -287,10 +287,67 @@</span> int sys_fstat(int fd, uint64 stat)</span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * @oldpath: The existing file to link.</span></span><br><span class="line"><span class="addition">+ * @newpath: The new link name to create.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Creates a new hard link to an</span></span><br><span class="line"><span class="addition">+ * existing file. It finds the inode</span></span><br><span class="line"><span class="addition">+ * of the old path. Then it increments</span></span><br><span class="line"><span class="addition">+ * the link count. A new directory entry</span></span><br><span class="line"><span class="addition">+ * is created for the new path. This</span></span><br><span class="line"><span class="addition">+ * entry points to the same inode.</span></span><br><span class="line"><span class="addition">+ * Directories cannot be hard-linked.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Returns 0 on success, -1 on error.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"> int sys_linkat(int olddirfd, uint64 oldpath, int newdirfd, uint64 newpath,</span><br><span class="line"> 	       uint64 flags)</span><br><span class="line"> {</span><br><span class="line"><span class="deletion">-	//TODO: your job is to complete the syscall</span></span><br><span class="line"><span class="addition">+	char old[MAXPATH], new[MAXPATH], *filename;</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	struct inode *dp, *ip;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (copyinstr(p-&gt;pagetable, old, oldpath, MAXPATH) &lt; 0 ||</span></span><br><span class="line"><span class="addition">+		copyinstr(p-&gt;pagetable, new, newpath, MAXPATH) &lt; 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Can't be linked to itself.</span></span><br><span class="line"><span class="addition">+	if (strncmp(old, new, MAXPATH) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if ((ip = namei(old)) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	ivalid(ip);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (ip-&gt;type == T_DIR) {</span></span><br><span class="line"><span class="addition">+		iput(ip);</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	ip-&gt;nlink++;</span></span><br><span class="line"><span class="addition">+	iupdate(ip);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if ((dp = nameiparent(new)) == 0)</span></span><br><span class="line"><span class="addition">+		goto fail;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	for (filename = new + strlen(new) - 1;</span></span><br><span class="line"><span class="addition">+		 filename &gt;= new &amp;&amp; *filename != '/'; filename--);</span></span><br><span class="line"><span class="addition">+	filename++;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (dirlink(dp, new, ip-&gt;inum) &lt; 0) {</span></span><br><span class="line"><span class="addition">+		iput(dp);</span></span><br><span class="line"><span class="addition">+		goto fail;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+	iput(dp);</span></span><br><span class="line"><span class="addition">+	iput(ip);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+fail:</span></span><br><span class="line"><span class="addition">+	ip-&gt;nlink--;</span></span><br><span class="line"><span class="addition">+	iupdate(ip);</span></span><br><span class="line"><span class="addition">+	iput(ip);</span></span><br><span class="line"> 	return -1;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 9064998e654b199eb4994876bda479c096f87b97 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Sat, 9 Aug 2025 23:17:53 +0800</span><br><span class="line">Subject: [PATCH 11/11] Implement unlinkat syscall</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/fs.c      | 54 +++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> os/fs.h      |  2 ++</span><br><span class="line"> os/syscall.c | 57 ++++++++++++++++++++++++++++++++++++++++++++++++++--</span><br><span class="line"> 3 files changed, 111 insertions(+), 2 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/fs.c b/os/fs.c</span></span><br><span class="line"><span class="comment">index 8c38f4d..41f7180 100644</span></span><br><span class="line"><span class="comment">--- a/os/fs.c</span></span><br><span class="line"><span class="comment">+++ b/os/fs.c</span></span><br><span class="line"><span class="meta">@@ -488,3 +488,57 @@</span> struct inode *nameiparent(char *path)</span><br><span class="line"> </span><br><span class="line"> 	return ip;</span><br><span class="line"> }</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * @dp:   The directory inode to modify.</span></span><br><span class="line"><span class="addition">+ * @off:  Offset of the entry to remove.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Removes a directory entry by zeroing it.</span></span><br><span class="line"><span class="addition">+ * It first reads the entry to ensure</span></span><br><span class="line"><span class="addition">+ * it is a valid, non-empty one.</span></span><br><span class="line"><span class="addition">+ * Then it overwrites the entry with</span></span><br><span class="line"><span class="addition">+ * zeros, effectively unlinking it.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Returns 0 on success, panics on error.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+int dirunlink(struct inode *dp, uint off)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct dirent de;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (readi(dp, 0, (uint64)&amp;de, off, sizeof(de)) != sizeof(de))</span></span><br><span class="line"><span class="addition">+		panic("dirunlink: read");</span></span><br><span class="line"><span class="addition">+	if (de.inum == 0)</span></span><br><span class="line"><span class="addition">+		panic("dirunlink: trying to unlink empty entry");</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	memset(&amp;de, 0, sizeof(de));</span></span><br><span class="line"><span class="addition">+	if (writei(dp, 0, (uint64)&amp;de, off, sizeof(de)) != sizeof(de))</span></span><br><span class="line"><span class="addition">+		panic("dirunlink: writei");</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+/**</span></span><br><span class="line"><span class="addition">+ * @dp: The directory inode to check.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Iterates through directory entries.</span></span><br><span class="line"><span class="addition">+ * It checks for any valid entries</span></span><br><span class="line"><span class="addition">+ * other than "." and "..". The loop</span></span><br><span class="line"><span class="addition">+ * starts after the first two entries.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Returns 1 if empty, 0 otherwise.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"><span class="addition">+int isdirempty(struct inode *dp)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	struct dirent de;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Iterate through directory entries. </span></span><br><span class="line"><span class="addition">+	// Skip the first two entries, "." and "..".</span></span><br><span class="line"><span class="addition">+	for (uint off = 2 * sizeof(de); off &lt; dp-&gt;size; off += sizeof(de)) {</span></span><br><span class="line"><span class="addition">+		if (readi(dp, 0, (uint64)&amp;de, off, sizeof(de)) != sizeof(de))</span></span><br><span class="line"><span class="addition">+			panic("isdirempty: readi");</span></span><br><span class="line"><span class="addition">+		if (de.inum != 0)</span></span><br><span class="line"><span class="addition">+			return 0;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 1;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"><span class="comment">diff --git a/os/fs.h b/os/fs.h</span></span><br><span class="line"><span class="comment">index 01d6e79..d47bd76 100644</span></span><br><span class="line"><span class="comment">--- a/os/fs.h</span></span><br><span class="line"><span class="comment">+++ b/os/fs.h</span></span><br><span class="line"><span class="meta">@@ -105,4 +105,6 @@</span> int readi(struct inode *, int, uint64, uint, uint);</span><br><span class="line"> int writei(struct inode *, int, uint64, uint, uint);</span><br><span class="line"> void itrunc(struct inode *);</span><br><span class="line"> int dirls(struct inode *);</span><br><span class="line"><span class="addition">+int dirunlink(struct inode *dp, uint off);</span></span><br><span class="line"><span class="addition">+int isdirempty(struct inode *dp);</span></span><br><span class="line"> #endif //!__FS_H__</span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 1f7b761..278276c 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -351,10 +351,63 @@</span> fail:</span><br><span class="line"> 	return -1;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="addition">+/*</span></span><br><span class="line"><span class="addition">+ * @name:   The path of the link to remove.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Removes a link from a directory.</span></span><br><span class="line"><span class="addition">+ * It finds the parent directory and</span></span><br><span class="line"><span class="addition">+ * the target inode. If the target is</span></span><br><span class="line"><span class="addition">+ * a non-empty directory, it fails.</span></span><br><span class="line"><span class="addition">+ * The directory entry is then cleared.</span></span><br><span class="line"><span class="addition">+ * Finally, it decrements the inode's</span></span><br><span class="line"><span class="addition">+ * link count. If the link count</span></span><br><span class="line"><span class="addition">+ * drops to zero, the inode and its</span></span><br><span class="line"><span class="addition">+ * data blocks are freed by iput.</span></span><br><span class="line"><span class="addition">+ *</span></span><br><span class="line"><span class="addition">+ * Returns 0 on success, -1 on error.</span></span><br><span class="line"><span class="addition">+ */</span></span><br><span class="line"> int sys_unlinkat(int dirfd, uint64 name, uint64 flags)</span><br><span class="line"> {</span><br><span class="line"><span class="deletion">-	//TODO: your job is to complete the syscall</span></span><br><span class="line"><span class="deletion">-	return -1;</span></span><br><span class="line"><span class="addition">+	char path[MAXPATH], *filename;</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	struct inode *dp, *ip;</span></span><br><span class="line"><span class="addition">+	uint off;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (copyinstr(p-&gt;pagetable, path, name, MAXPATH) &lt; 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	for (filename = path + strlen(path) - 1;</span></span><br><span class="line"><span class="addition">+		 filename &gt;= path &amp;&amp; *filename != '/'; filename--);</span></span><br><span class="line"><span class="addition">+	filename++;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if ((dp = nameiparent(path)) == 0)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if ((ip = dirlookup(dp, filename, &amp;off)) == 0) {</span></span><br><span class="line"><span class="addition">+		iput(dp);</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	ivalid(ip);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (ip-&gt;type == T_DIR &amp;&amp; !isdirempty(ip)) {</span></span><br><span class="line"><span class="addition">+		iput(dp);</span></span><br><span class="line"><span class="addition">+		iput(ip);</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (dirunlink(dp, off) != 0) {</span></span><br><span class="line"><span class="addition">+		iput(dp);</span></span><br><span class="line"><span class="addition">+		iput(ip);</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	ip-&gt;nlink--;</span></span><br><span class="line"><span class="addition">+	iupdate(ip);</span></span><br><span class="line"><span class="addition">+	iput(dp);</span></span><br><span class="line"><span class="addition">+	iput(ip);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> uint64 sys_sbrk(int n)</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>上面就是我对新增系统调用的完整实现了，我是按
<code>fstat</code>、<code>linkat</code>、<code>unlinkat</code>
的顺序实现的。懒得再写详细的 commit message，只做了一点简单的注释。再次
<code>make test BASE=2</code> 然后运行
<code>ch6_usertest</code>，最后看到 <code>ch6 Usertests passed!</code>
就行了。</p>
<h2 id="问答作业">问答作业</h2>
<h3 id="ch6">ch6</h3>
<ol type="1">
<li>在我们的文件系统中，root inode 起着什么作用？如果 root
inode 中的内容损坏了，会发生什么？</li>
</ol>
<h3 id="ch7">ch7</h3>
<ol type="1">
<li>举出使用 pipe 的一个实际应用的例子。</li>
</ol>
<ul>
<li>tips:
<ul>
<li>想想你平时咋使用 linux terminal 的？</li>
<li>如何使用 cat 和 wc 完成一个文件的行数统计？</li>
</ul></li>
</ul>
<ol start="2" type="1">
<li>如果需要在多个进程间互相通信，则需要为每一对进程建立一个管道，非常繁琐，请设计一个更易用的多进程通信机制。</li>
</ol>
<h2 id="问答作业答案">问答作业答案</h2>
<h3 id="ch6-1">ch6</h3>
<ol type="1">
<li><p>在我们的文件系统中，root inode 起着什么作用？如果 root inode
中的内容损坏了，会发生什么？</p>
<p>root inode 代表根目录所对应的
inode，也是整个文件系统的起点，对其他的所有文件的操作都是在根目录的前提下完成的，如果损坏，那么整个文件系统就无法正常操作文件。</p></li>
</ol>
<h3 id="ch7-1">ch7</h3>
<ol type="1">
<li>举出使用 pipe 的一个实际应用的例子。</li>
</ol>
<ul>
<li><p>tips:</p>
<ul>
<li>想想你平时咋使用 linux terminal 的？</li>
<li>如何使用 cat 和 wc 完成一个文件的行数统计？</li>
</ul>
<p>对一个文本文件排序并去重：<code>cat data.txt | sort | uniq</code>。</p>
<p>用 cat 和 wc
完成一个文件的行数统计：<code>cat &lt;filename&gt; | wc -l</code>。</p></li>
</ul>
<ol start="2" type="1">
<li><p>如果需要在多个进程间互相通信，则需要为每一对进程建立一个管道，非常繁琐，请设计一个更易用的多进程通信机制。</p>
<p>传统管道方案中，<span class="math inline"><em>n</em></span>
个进程间通信需要建立 <span class="math inline"><em>n</em>(<em>n</em> − 1)/2</span>
个管道，连接复杂度为 <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>，管理困难繁琐。我认为，可以在内核中维护一个全局的消息缓冲区，所有进程的消息都写入这个统一的缓冲区。为每个进程维护独立的读取偏移量，这样每个进程可以按自己的进度读取消息，避免消息被其他进程读取后丢失的问题。为了避免安全问题，全局消息缓冲区只能在内核态访问，用户进程无法直接读写，并且所有消息操作必须通过系统调用进行，内核负责权限检查。</p></li>
</ol>
]]></content>
      <categories>
        <category>uCore</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>riscv</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore lab5 实验报告</title>
    <url>/uCore/8465.html</url>
    <content><![CDATA[<p>这次实验应该是最难的了，虽然不用考虑内核 / 用户态的切换，也不用移植前面实验的内容，但是光读一遍新增的锁就很累了。还要对一些算法有一定认识，后面再细讲。</p>
<h2 id="本章任务">本章任务</h2>
<ul>
<li>本次任务对应 lab5，也是本学期最后一次实验，祝你好运。</li>
<li>老规矩，先 <code>make test BASE=1</code> 看下啥情况。</li>
<li><strong>理解框架的多线程机制，了解几种锁的运行原理。在此基础上，实现本章编程作业死锁检测。</strong>
<ul>
<li>如果时间有限，多线程机制的一些细节大可跳过，但至少应知道多线程基本原理和本章在任务调度粒度上的调整</li>
<li>与实验息息相关的是互斥锁 (mutex) 与信号量 (semaphore)，条件变量 (condvar) 供阅读</li>
<li><strong>框架包含 <code>LAB5</code>
字样的注释中给出了一个供参考的实现位置和顺序，你可以按顺序完成（下面的标号与注释中的一种）：</strong>
<ul>
<li>1: 定义并初始化部分 PCB
的部分变量，包括控制死锁检测启动与死锁检测算法用到的变量，你可以先定义一部分，后面发现有需要时再做添加；</li>
<li>2: 完成系统调用
<code>sys_enable_deadlock_detect</code>，只需要修改变量，不必考虑是否正确实现了死锁。完成这一步后你可以顺利跑完
<code>ch8_sem2_deadlock</code>，这个测例开启了死锁检测但并没有死锁；</li>
<li>3:
尝试写一个函数实现下面提到的死锁检测算法，注释中给了供参考的函数签名。这是一个和
OS 独立的函数，你可以自行设计数据单独运行它以测试；</li>
<li>4-1: 维护 mutex
相关的死锁检测变量，并调用死锁检测算法，完成后你可以顺利跑完测例
<code>ch8_mut1_deadlock</code>；</li>
<li>4-2: 维护 semaphore
相关的死锁检测变量，并调用死锁检测算法，完成后你可以顺利跑完测例
<code>ch8_sem1_deadlock</code>；</li>
</ul></li>
</ul></li>
<li>最终，完成实验报告并 push 你的 ch8 分支到远程仓库。push
代码后会自动执行 CI，代码给分以 CI 给分为准。</li>
</ul>
<h2 id="编程作业">编程作业</h2>
<details>
<summary>
⚠警告
</summary>
<p>本次实验框架变动较大，且改动较为复杂，为降低同学们的工作量，本次实验不要求合并之前的实验内容，可以直接
checkout 到 ch8 框架开始实验，最终只需通过 ch8
系列的测例和前面章节的基础测例即可。</p>
</details>
<details>
<summary>
🖊注解
</summary>
<p>本次实验实现死锁检测算法本身只需要 40 行左右代码，但加上系统调用实现、变量声明与初始化、以及在锁的创建、锁、释放时维护死锁检测
Available、Allocation、Request 数组，总代码量预计在 100
行左右。助教的参考实现约为 90 行。</p>
</details>
<h3 id="死锁检测">死锁检测</h3>
<p>目前的 mutex 和 semaphore
相关的系统调用不会分析资源的依赖情况，用户程序可能出现死锁。
我们希望在系统中加入死锁检测机制，当发现可能发生死锁时拒绝对应的资源获取请求。一种检测死锁的算法如下：</p>
<p>定义如下三个数据结构：</p>
<ul>
<li>可利用资源向量 Available：含有 m
个元素的一维数组，每个元素代表可利用的某一类资源的数目，其初值是该类资源的全部可用数目，其值随该类资源的分配和回收而动态地改变。Available [j]
= k，表示第 j 类资源的可用数量为 k。</li>
<li>分配矩阵 Allocation：n * m
矩阵，表示每类资源已分配给每个线程的资源数。Allocation [i, j] =
g，则表示线程 i 当前己分得第 j 类资源的数量为 g。</li>
<li>需求矩阵 Request：n * m
的矩阵，表示每个线程还需要的各类资源数量。Request [i, j] = d，则表示线程
i 还需要第 j 类资源的数量为 d。</li>
</ul>
<p>算法运行过程如下：</p>
<ol type="1">
<li>设置两个向量: 工作向量
Work，表示操作系统可提供给线程继续运行所需的各类资源数目，它含有 m
个元素。初始时，Work = Available；结束向量
Finish，表示系统是否有足够的资源分配给线程，使之运行完成。初始时
Finish [0 ~ n - 1] =
false，表示所有线程都没结束；当有足够资源分配给线程时，设置 Finish [i] =
true。</li>
<li>从线程集合中找到一个能满足下述条件的线程 i</li>
</ol>
<blockquote>
<ol type="1">
<li>Finish[i] == false;</li>
<li>Request[i, 0 ~ n - 1] ≤ Work[0 ~ n - 1];</li>
</ol>
</blockquote>
<p>若找到，执行步骤 3，否则执行步骤 4。</p>
<ol start="3" type="1">
<li>当线程 i
获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行:</li>
</ol>
<blockquote>
<ol type="1">
<li>Work[0 ~ n - 1] = Work[0 ~ n - 1] + Allocation[i, 0 ~ n - 1];</li>
<li>Finish[i] = true;</li>
</ol>
</blockquote>
<p>跳转回步骤 2</p>
<ol start="4" type="1">
<li>如果 Finish [0 ~ n - 1] 都为
true，则表示系统处于安全状态；否则表示系统处于不安全状态，即出现死锁。</li>
</ol>
<p>出于兼容性和灵活性考虑，我们允许进程按需开启或关闭死锁检测功能。为此我们将实现一个新的系统调用：<code>sys_enable_deadlock_detect</code>。</p>
<p><strong>enable_deadlock_detect：</strong></p>
<ul>
<li>syscall ID: 469</li>
<li>功能：为当前进程启用或禁用死锁检测功能。</li>
<li>接口：<code>int enable_deadlock_detect(int is_enable)</code></li>
<li>参数：
<ul>
<li><code>is_enable</code>: 为 1 表示启用死锁检测，0
表示禁用死锁检测。</li>
</ul></li>
<li>说明：
<ul>
<li>开启死锁检测功能后，<code>mutex_lock</code> 和
<code>semaphore_down</code> 如果检测到死锁，应拒绝相应操作并返回
<code>-0xDEAD</code> (十六进制值)。</li>
<li>简便起见可对 mutex 和 semaphore 分别进行检测，无需考虑二者 (以及
<code>waittid</code> 等) 混合使用导致的死锁。</li>
</ul></li>
<li>返回值：如果出现了错误则返回 -1，否则返回 0。</li>
<li>可能的错误
<ul>
<li>参数不合法</li>
<li>死锁检测开启失败</li>
</ul></li>
</ul>
<h2 id="编程作业答案">编程作业答案</h2>
<p>就按实验要求的顺序一步一步实现吧，下面是我的更改：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 4ff1db2543e1394afd4b5a862fbb552e7f08b7d3 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Mon, 11 Aug 2025 23:12:01 +0800</span><br><span class="line">Subject: [PATCH 1/6] proc: Initialize needed variables in PCB</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/proc.c | 7 +++++++</span><br><span class="line"> os/proc.h | 7 +++++++</span><br><span class="line"> 2 files changed, 14 insertions(+)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/proc.c b/os/proc.c</span></span><br><span class="line"><span class="comment">index 9baaeb3..c964b99 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.c</span></span><br><span class="line"><span class="comment">+++ b/os/proc.c</span></span><br><span class="line"><span class="meta">@@ -143,6 +143,13 @@</span> found:</span><br><span class="line"> 	p-&gt;next_semaphore_id = 0;</span><br><span class="line"> 	p-&gt;next_condvar_id = 0;</span><br><span class="line"> 	// LAB5: (1) you may initialize your new proc variables here</span><br><span class="line"><span class="addition">+	p-&gt;deadlock_detect_enabled = 0;</span></span><br><span class="line"><span class="addition">+	memset(p-&gt;mutex_avail, 0, sizeof(p-&gt;mutex_avail));</span></span><br><span class="line"><span class="addition">+	memset(p-&gt;mutex_alloc, 0, sizeof(p-&gt;mutex_alloc));</span></span><br><span class="line"><span class="addition">+	memset(p-&gt;mutex_req, 0, sizeof(p-&gt;mutex_req));</span></span><br><span class="line"><span class="addition">+	memset(p-&gt;sem_avail, 0, sizeof(p-&gt;sem_avail));</span></span><br><span class="line"><span class="addition">+	memset(p-&gt;sem_alloc, 0, sizeof(p-&gt;sem_alloc));</span></span><br><span class="line"><span class="addition">+	memset(p-&gt;sem_req, 0, sizeof(p-&gt;sem_req));</span></span><br><span class="line"> 	return p;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="comment">diff --git a/os/proc.h b/os/proc.h</span></span><br><span class="line"><span class="comment">index 0398e36..ba43261 100644</span></span><br><span class="line"><span class="comment">--- a/os/proc.h</span></span><br><span class="line"><span class="comment">+++ b/os/proc.h</span></span><br><span class="line"><span class="meta">@@ -66,6 +66,13 @@</span> struct proc {</span><br><span class="line"> 	// LAB5: (1) Define your variables for deadlock detect here.</span><br><span class="line"> 	//			 You may need a flag to record if detection enabled,</span><br><span class="line"> 	//       and some arrays for detection algorithm.</span><br><span class="line"><span class="addition">+	int deadlock_detect_enabled;</span></span><br><span class="line"><span class="addition">+	int mutex_avail[LOCK_POOL_SIZE];</span></span><br><span class="line"><span class="addition">+	int mutex_alloc[NTHREAD][LOCK_POOL_SIZE];</span></span><br><span class="line"><span class="addition">+	int mutex_req[NTHREAD][LOCK_POOL_SIZE];</span></span><br><span class="line"><span class="addition">+	int sem_avail[LOCK_POOL_SIZE];</span></span><br><span class="line"><span class="addition">+	int sem_alloc[NTHREAD][LOCK_POOL_SIZE];</span></span><br><span class="line"><span class="addition">+	int sem_req[NTHREAD][LOCK_POOL_SIZE];</span></span><br><span class="line"> };</span><br><span class="line"> </span><br><span class="line"> int cpuid();</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From e5dfeb92213efd43fba0830e0f75175c55c33d83 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Mon, 11 Aug 2025 23:17:04 +0800</span><br><span class="line">Subject: [PATCH 2/6] Implement enable_deadlock_detect syscall</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/syscall.c | 14 ++++++++++++++</span><br><span class="line"> 1 file changed, 14 insertions(+)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 84eab14..05c919b 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -362,6 +362,17 @@</span> int sys_condvar_wait(int cond_id, int mutex_id)</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"> // LAB5: (2) you may need to define function enable_deadlock_detect here</span><br><span class="line"><span class="addition">+int sys_enable_deadlock_detect(int is_enable)</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	if (is_enable != 0 &amp;&amp; is_enable != 1)</span></span><br><span class="line"><span class="addition">+		return -1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	p-&gt;deadlock_detect_enabled = is_enable;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"> </span><br><span class="line"> extern char trap_page[];</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -455,6 +466,9 @@</span> void syscall()</span><br><span class="line"> 		ret = sys_condvar_wait(args[0], args[1]);</span><br><span class="line"> 		break;</span><br><span class="line"> 	// LAB5: (2) you may need to add case SYS_enable_deadlock_detect here</span><br><span class="line"><span class="addition">+	case SYS_enable_deadlock_detect:</span></span><br><span class="line"><span class="addition">+		ret = sys_enable_deadlock_detect(args[0]);</span></span><br><span class="line"><span class="addition">+		break;</span></span><br><span class="line"> 	default:</span><br><span class="line"> 		ret = -1;</span><br><span class="line"> 		errorf("unknown syscall %d", id);</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 448844a705e085d827ef5ece51ef0c64487e6501 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Mon, 11 Aug 2025 23:46:13 +0800</span><br><span class="line">Subject: [PATCH 3/6] Implement deadlock detect algo</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/syscall.c | 53 ++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> 1 file changed, 53 insertions(+)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 05c919b..03610ba 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -248,7 +248,60 @@</span> int sys_waittid(int tid)</span><br><span class="line"> *						const int request[NTHREAD][LOCK_POOL_SIZE])</span><br><span class="line"> *				for both mutex and semaphore detect, you can also</span><br><span class="line"> *				use this idea or just ignore it.</span><br><span class="line"><span class="addition">+*	@thread_cnt:	The total number of threads in the system.</span></span><br><span class="line"><span class="addition">+*	@resource_cnt:	The total number of resource types, this corresponds</span></span><br><span class="line"><span class="addition">+					to the number of currently created mutexes or</span></span><br><span class="line"><span class="addition">+					semaphores (e.g., p-&gt;next_mutex_id).</span></span><br><span class="line"> */</span><br><span class="line"><span class="addition">+int deadlock_detect(int thread_cnt,</span></span><br><span class="line"><span class="addition">+		 int resource_cnt, int *avail,</span></span><br><span class="line"><span class="addition">+		 int alloc[NTHREAD][LOCK_POOL_SIZE],</span></span><br><span class="line"><span class="addition">+		 int req[NTHREAD][LOCK_POOL_SIZE])</span></span><br><span class="line"><span class="addition">+{</span></span><br><span class="line"><span class="addition">+	// Initialize Work and Finish arrays.</span></span><br><span class="line"><span class="addition">+	int work[LOCK_POOL_SIZE], finish[NTHREAD];</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	for (int j = 0; j &lt; resource_cnt; j++)</span></span><br><span class="line"><span class="addition">+		work[j] = avail[j];</span></span><br><span class="line"><span class="addition">+	for (int i = 0; i &lt; thread_cnt; i++)</span></span><br><span class="line"><span class="addition">+		finish[i] = 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Find a thread that can finish and release its resources.</span></span><br><span class="line"><span class="addition">+	while (1) {</span></span><br><span class="line"><span class="addition">+		int found = 0;</span></span><br><span class="line"><span class="addition">+		for (int i = 0; i &lt; thread_cnt; i++) {</span></span><br><span class="line"><span class="addition">+			// Find a thread [i] which is not finished and its request can be satisfied</span></span><br><span class="line"><span class="addition">+			if (finish[i] == 0) {</span></span><br><span class="line"><span class="addition">+				int unsatisfied = 0;</span></span><br><span class="line"><span class="addition">+				for (int j = 0; j &lt; resource_cnt; j++) {</span></span><br><span class="line"><span class="addition">+					if (req[i][j] &gt; work[j]) {</span></span><br><span class="line"><span class="addition">+						unsatisfied = 1;</span></span><br><span class="line"><span class="addition">+						break;</span></span><br><span class="line"><span class="addition">+					}</span></span><br><span class="line"><span class="addition">+				}</span></span><br><span class="line"><span class="addition">+				// If found, pretend to release its resources</span></span><br><span class="line"><span class="addition">+				if (!unsatisfied) {</span></span><br><span class="line"><span class="addition">+					for (int j = 0; j &lt; resource_cnt; j++)</span></span><br><span class="line"><span class="addition">+						work[j] += alloc[i][j];</span></span><br><span class="line"><span class="addition">+					finish[i] = 1;</span></span><br><span class="line"><span class="addition">+					found = 1;</span></span><br><span class="line"><span class="addition">+				}</span></span><br><span class="line"><span class="addition">+			}</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+		// If no such thread was found in a full pass, exit the loop</span></span><br><span class="line"><span class="addition">+		if (!found)</span></span><br><span class="line"><span class="addition">+			break;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Check if all threads are finished.</span></span><br><span class="line"><span class="addition">+	for (int i = 0; i &lt; thread_cnt; i++) {</span></span><br><span class="line"><span class="addition">+		if (finish[i] == 0)</span></span><br><span class="line"><span class="addition">+			// If any thread cannot finish, the system is in an unsafe state, detect deadlock.</span></span><br><span class="line"><span class="addition">+			return 1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	return 0;</span></span><br><span class="line"><span class="addition">+}</span></span><br><span class="line"> </span><br><span class="line"> int sys_mutex_create(int blocking)</span><br><span class="line"> {</span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From fa4e86f787b90e4517d941cc74e3e3131ef7cf68 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Tue, 12 Aug 2025 00:09:59 +0800</span><br><span class="line">Subject: [PATCH 4/6] Maintain deadlock detector and variables for mutex</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/syscall.c | 55 +++++++++++++++++++++++++++++++++++++++++++++++++---</span><br><span class="line"> 1 file changed, 52 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 03610ba..bb2791d 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -311,7 +311,14 @@</span> int sys_mutex_create(int blocking)</span><br><span class="line"> 		return -1;</span><br><span class="line"> 	}</span><br><span class="line"> 	// LAB5: (4-1) You may want to maintain some variables for detect here</span><br><span class="line"><span class="deletion">-	int mutex_id = m - curr_proc()-&gt;mutex_pool;</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	int mutex_id = m - p-&gt;mutex_pool;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// If deadlock detection is enabled, initialize</span></span><br><span class="line"><span class="addition">+	// the state for this new resource.</span></span><br><span class="line"><span class="addition">+	if (p-&gt;deadlock_detect_enabled)</span></span><br><span class="line"><span class="addition">+		p-&gt;mutex_avail[mutex_id] = 1;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	debugf("create mutex %d", mutex_id);</span><br><span class="line"> 	return mutex_id;</span><br><span class="line"> }</span><br><span class="line"><span class="meta">@@ -324,7 +331,37 @@</span> int sys_mutex_lock(int mutex_id)</span><br><span class="line"> 	}</span><br><span class="line"> 	// LAB5: (4-1) You may want to maintain some variables for detect</span><br><span class="line"> 	//       or call your detect algorithm here</span><br><span class="line"><span class="deletion">-	mutex_lock(&amp;curr_proc()-&gt;mutex_pool[mutex_id]);</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	struct thread *t = curr_thread();</span></span><br><span class="line"><span class="addition">+	struct mutex *m = &amp;p-&gt;mutex_pool[mutex_id];</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="addition">+		p-&gt;mutex_req[t-&gt;tid][mutex_id] = 1;</span></span><br><span class="line"><span class="addition">+		// Check for potential deadlock ONLY if the resource is</span></span><br><span class="line"><span class="addition">+		// not immediately available. If the mutex is already</span></span><br><span class="line"><span class="addition">+		// locked, the thread will have to wait. This is a</span></span><br><span class="line"><span class="addition">+		// potential deadlock situation.</span></span><br><span class="line"><span class="addition">+		if (m-&gt;locked) {</span></span><br><span class="line"><span class="addition">+			if (deadlock_detect(NTHREAD, p-&gt;next_mutex_id,</span></span><br><span class="line"><span class="addition">+				 p-&gt;mutex_avail, p-&gt;mutex_alloc, p-&gt;mutex_req)) {</span></span><br><span class="line"><span class="addition">+				p-&gt;mutex_req[t-&gt;tid][mutex_id] = 0;</span></span><br><span class="line"><span class="addition">+				return -0xDEAD;</span></span><br><span class="line"><span class="addition">+			}</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	mutex_lock(m);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Update state matrices after successfully acquiring the lock.</span></span><br><span class="line"><span class="addition">+	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="addition">+		// The request has been fulfilled, clear it now.</span></span><br><span class="line"><span class="addition">+		p-&gt;mutex_req[t-&gt;tid][mutex_id] = 0;</span></span><br><span class="line"><span class="addition">+		// Now the resource is allocated to this thread.</span></span><br><span class="line"><span class="addition">+		p-&gt;mutex_alloc[t-&gt;tid][mutex_id] = 1;</span></span><br><span class="line"><span class="addition">+		// It's unavailable now.</span></span><br><span class="line"><span class="addition">+		p-&gt;mutex_avail[mutex_id] = 0;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -335,7 +372,19 @@</span> int sys_mutex_unlock(int mutex_id)</span><br><span class="line"> 		return -1;</span><br><span class="line"> 	}</span><br><span class="line"> 	// LAB5: (4-1) You may want to maintain some variables for detect here</span><br><span class="line"><span class="deletion">-	mutex_unlock(&amp;curr_proc()-&gt;mutex_pool[mutex_id]);</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	struct thread *t = curr_thread();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Update state matrices to reflect the resource release.</span></span><br><span class="line"><span class="addition">+	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="addition">+		// No longer holds the resource. Clear it.</span></span><br><span class="line"><span class="addition">+		p-&gt;mutex_alloc[t-&gt;tid][mutex_id] = 0;</span></span><br><span class="line"><span class="addition">+		// Now it's available.</span></span><br><span class="line"><span class="addition">+		p-&gt;mutex_avail[mutex_id] = 1;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	mutex_unlock(&amp;p-&gt;mutex_pool[mutex_id]);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From ee4d9d1c584cb450a83256e53d17adeb3ebe2d05 Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Tue, 12 Aug 2025 00:31:44 +0800</span><br><span class="line">Subject: [PATCH 5/6] Maintain deadlock detector and variables for sem</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/syscall.c | 53 +++++++++++++++++++++++++++++++++++++++++++++++++---</span><br><span class="line"> 1 file changed, 50 insertions(+), 3 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index bb2791d..6149a98 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -396,7 +396,14 @@</span> int sys_semaphore_create(int res_count)</span><br><span class="line"> 		return -1;</span><br><span class="line"> 	}</span><br><span class="line"> 	// LAB5: (4-2) You may want to maintain some variables for detect here</span><br><span class="line"><span class="deletion">-	int sem_id = s - curr_proc()-&gt;semaphore_pool;</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	int sem_id = s - p-&gt;semaphore_pool;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// If deadlock detection is enabled,</span></span><br><span class="line"><span class="addition">+	// initialize the state for this new resource.</span></span><br><span class="line"><span class="addition">+	if (p-&gt;deadlock_detect_enabled)</span></span><br><span class="line"><span class="addition">+		p-&gt;sem_avail[sem_id] = res_count;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	debugf("create semaphore %d", sem_id);</span><br><span class="line"> 	return sem_id;</span><br><span class="line"> }</span><br><span class="line"><span class="meta">@@ -409,7 +416,18 @@</span> int sys_semaphore_up(int semaphore_id)</span><br><span class="line"> 		return -1;</span><br><span class="line"> 	}</span><br><span class="line"> 	// LAB5: (4-2) You may want to maintain some variables for detect here</span><br><span class="line"><span class="deletion">-	semaphore_up(&amp;curr_proc()-&gt;semaphore_pool[semaphore_id]);</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	struct thread *t = curr_thread();</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Update state matrices to reflect V operation.</span></span><br><span class="line"><span class="addition">+	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="addition">+		// To release a semaphore, decrease the thread's allocation of this resource.</span></span><br><span class="line"><span class="addition">+		p-&gt;sem_alloc[t-&gt;tid][semaphore_id]--;</span></span><br><span class="line"><span class="addition">+		// Consequently, the number of available instances of this resource increases.</span></span><br><span class="line"><span class="addition">+		p-&gt;sem_avail[semaphore_id]++;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	semaphore_up(&amp;p-&gt;semaphore_pool[semaphore_id]);</span></span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -422,7 +440,36 @@</span> int sys_semaphore_down(int semaphore_id)</span><br><span class="line"> 	}</span><br><span class="line"> 	// LAB5: (4-2) You may want to maintain some variables for detect</span><br><span class="line"> 	//       or call your detect algorithm here</span><br><span class="line"><span class="deletion">-	semaphore_down(&amp;curr_proc()-&gt;semaphore_pool[semaphore_id]);</span></span><br><span class="line"><span class="addition">+	struct proc *p = curr_proc();</span></span><br><span class="line"><span class="addition">+	struct thread *t = curr_thread();</span></span><br><span class="line"><span class="addition">+	struct semaphore *s = &amp;p-&gt;semaphore_pool[semaphore_id];</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="addition">+		p-&gt;sem_req[t-&gt;tid][semaphore_id] = 1;</span></span><br><span class="line"><span class="addition">+		// Check for potential deadlock if the thread might wait.</span></span><br><span class="line"><span class="addition">+		// A thread will wait if the semaphore count is not positive.</span></span><br><span class="line"><span class="addition">+		if (s-&gt;count &lt;= 0) {</span></span><br><span class="line"><span class="addition">+			if (deadlock_detect(NTHREAD, p-&gt;next_semaphore_id,</span></span><br><span class="line"><span class="addition">+					p-&gt;sem_avail, p-&gt;sem_alloc, p-&gt;sem_req)) {</span></span><br><span class="line"><span class="addition">+				// Cancel the request.</span></span><br><span class="line"><span class="addition">+				p-&gt;sem_req[t-&gt;tid][semaphore_id] = 0;</span></span><br><span class="line"><span class="addition">+				return -0xDEAD;</span></span><br><span class="line"><span class="addition">+			}</span></span><br><span class="line"><span class="addition">+		}</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	semaphore_down(s);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	// Update state matrices after successfully acquiring the resource.</span></span><br><span class="line"><span class="addition">+	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="addition">+		// The request has been fulfilled, clear it now.</span></span><br><span class="line"><span class="addition">+		p-&gt;sem_req[t-&gt;tid][semaphore_id] = 0;</span></span><br><span class="line"><span class="addition">+		// Increase the thread's allocation of this resource.</span></span><br><span class="line"><span class="addition">+		p-&gt;sem_alloc[t-&gt;tid][semaphore_id]++;</span></span><br><span class="line"><span class="addition">+		// Decrease the thread's available of this resource.</span></span><br><span class="line"><span class="addition">+		p-&gt;sem_avail[semaphore_id]--;</span></span><br><span class="line"><span class="addition">+	}</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>最后这个提交不是必需的，只是我看 <code>mutex_lock</code> 和
<code>semaphore_down</code>
里面的重复判断有点难受，所以简化了一下实现，<del>感觉好看多了</del>：</p>
<figure class="highlight patch"><table><tbody><tr><td class="code"><pre><span class="line">From 97ef7e592e8118b1a0f1ccf53d320f88d94d196d Mon Sep 17 00:00:00 2001</span><br><span class="line">From: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line">Date: Tue, 12 Aug 2025 01:26:20 +0800</span><br><span class="line">Subject: [PATCH 6/6] refactor mutex_lock and semaphore_down syscall</span><br><span class="line"></span><br><span class="line">Signed-off-by: 0wnerDied &lt;z1281552865@gmail.com&gt;</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"> os/syscall.c | 90 ++++++++++++++++++++++++++++------------------------</span><br><span class="line"> 1 file changed, 49 insertions(+), 41 deletions(-)</span><br><span class="line"></span><br><span class="line"><span class="comment">diff --git a/os/syscall.c b/os/syscall.c</span></span><br><span class="line"><span class="comment">index 6149a98..c38d7c5 100644</span></span><br><span class="line"><span class="comment">--- a/os/syscall.c</span></span><br><span class="line"><span class="comment">+++ b/os/syscall.c</span></span><br><span class="line"><span class="meta">@@ -335,33 +335,37 @@</span> int sys_mutex_lock(int mutex_id)</span><br><span class="line"> 	struct thread *t = curr_thread();</span><br><span class="line"> 	struct mutex *m = &amp;p-&gt;mutex_pool[mutex_id];</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="deletion">-		p-&gt;mutex_req[t-&gt;tid][mutex_id] = 1;</span></span><br><span class="line"><span class="deletion">-		// Check for potential deadlock ONLY if the resource is</span></span><br><span class="line"><span class="deletion">-		// not immediately available. If the mutex is already</span></span><br><span class="line"><span class="deletion">-		// locked, the thread will have to wait. This is a</span></span><br><span class="line"><span class="deletion">-		// potential deadlock situation.</span></span><br><span class="line"><span class="deletion">-		if (m-&gt;locked) {</span></span><br><span class="line"><span class="deletion">-			if (deadlock_detect(NTHREAD, p-&gt;next_mutex_id,</span></span><br><span class="line"><span class="deletion">-				 p-&gt;mutex_avail, p-&gt;mutex_alloc, p-&gt;mutex_req)) {</span></span><br><span class="line"><span class="deletion">-				p-&gt;mutex_req[t-&gt;tid][mutex_id] = 0;</span></span><br><span class="line"><span class="deletion">-				return -0xDEAD;</span></span><br><span class="line"><span class="deletion">-			}</span></span><br><span class="line"><span class="addition">+	if (!p-&gt;deadlock_detect_enabled)</span></span><br><span class="line"><span class="addition">+		goto acquire_lock;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	p-&gt;mutex_req[t-&gt;tid][mutex_id] = 1;</span></span><br><span class="line"><span class="addition">+	// Check for potential deadlock ONLY if the resource is</span></span><br><span class="line"><span class="addition">+	// not immediately available. If the mutex is already</span></span><br><span class="line"><span class="addition">+	// locked, the thread will have to wait. This is a</span></span><br><span class="line"><span class="addition">+	// potential deadlock situation.</span></span><br><span class="line"><span class="addition">+	if (m-&gt;locked) {</span></span><br><span class="line"><span class="addition">+		if (deadlock_detect(NTHREAD, p-&gt;next_mutex_id,</span></span><br><span class="line"><span class="addition">+			 p-&gt;mutex_avail, p-&gt;mutex_alloc, p-&gt;mutex_req)) {</span></span><br><span class="line"><span class="addition">+			p-&gt;mutex_req[t-&gt;tid][mutex_id] = 0;</span></span><br><span class="line"><span class="addition">+			return -0xDEAD;</span></span><br><span class="line"> 		}</span><br><span class="line"> 	}</span><br><span class="line"> </span><br><span class="line"><span class="addition">+acquire_lock:</span></span><br><span class="line"> 	mutex_lock(m);</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-	// Update state matrices after successfully acquiring the lock.</span></span><br><span class="line"><span class="deletion">-	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="deletion">-		// The request has been fulfilled, clear it now.</span></span><br><span class="line"><span class="deletion">-		p-&gt;mutex_req[t-&gt;tid][mutex_id] = 0;</span></span><br><span class="line"><span class="deletion">-		// Now the resource is allocated to this thread.</span></span><br><span class="line"><span class="deletion">-		p-&gt;mutex_alloc[t-&gt;tid][mutex_id] = 1;</span></span><br><span class="line"><span class="deletion">-		// It's unavailable now.</span></span><br><span class="line"><span class="deletion">-		p-&gt;mutex_avail[mutex_id] = 0;</span></span><br><span class="line"><span class="deletion">-	}</span></span><br><span class="line"><span class="addition">+	if (!p-&gt;deadlock_detect_enabled)</span></span><br><span class="line"><span class="addition">+		goto ret;</span></span><br><span class="line"> </span><br><span class="line"><span class="addition">+	// Update state matrices after successfully acquiring the lock.</span></span><br><span class="line"><span class="addition">+	// The request has been fulfilled, clear it now.</span></span><br><span class="line"><span class="addition">+	p-&gt;mutex_req[t-&gt;tid][mutex_id] = 0;</span></span><br><span class="line"><span class="addition">+	// Now the resource is allocated to this thread.</span></span><br><span class="line"><span class="addition">+	p-&gt;mutex_alloc[t-&gt;tid][mutex_id] = 1;</span></span><br><span class="line"><span class="addition">+	// It's unavailable now.</span></span><br><span class="line"><span class="addition">+	p-&gt;mutex_avail[mutex_id] = 0;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+ret:</span></span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="meta">@@ -444,32 +448,36 @@</span> int sys_semaphore_down(int semaphore_id)</span><br><span class="line"> 	struct thread *t = curr_thread();</span><br><span class="line"> 	struct semaphore *s = &amp;p-&gt;semaphore_pool[semaphore_id];</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="deletion">-		p-&gt;sem_req[t-&gt;tid][semaphore_id] = 1;</span></span><br><span class="line"><span class="deletion">-		// Check for potential deadlock if the thread might wait.</span></span><br><span class="line"><span class="deletion">-		// A thread will wait if the semaphore count is not positive.</span></span><br><span class="line"><span class="deletion">-		if (s-&gt;count &lt;= 0) {</span></span><br><span class="line"><span class="deletion">-			if (deadlock_detect(NTHREAD, p-&gt;next_semaphore_id,</span></span><br><span class="line"><span class="deletion">-					p-&gt;sem_avail, p-&gt;sem_alloc, p-&gt;sem_req)) {</span></span><br><span class="line"><span class="deletion">-				// Cancel the request.</span></span><br><span class="line"><span class="deletion">-				p-&gt;sem_req[t-&gt;tid][semaphore_id] = 0;</span></span><br><span class="line"><span class="deletion">-				return -0xDEAD;</span></span><br><span class="line"><span class="deletion">-			}</span></span><br><span class="line"><span class="addition">+	if (!p-&gt;deadlock_detect_enabled)</span></span><br><span class="line"><span class="addition">+		goto acquire_sem;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+	p-&gt;sem_req[t-&gt;tid][semaphore_id] = 1;</span></span><br><span class="line"><span class="addition">+	// Check for potential deadlock if the thread might wait.</span></span><br><span class="line"><span class="addition">+	// A thread will wait if the semaphore count is not positive.</span></span><br><span class="line"><span class="addition">+	if (s-&gt;count &lt;= 0) {</span></span><br><span class="line"><span class="addition">+		if (deadlock_detect(NTHREAD, p-&gt;next_semaphore_id,</span></span><br><span class="line"><span class="addition">+			 p-&gt;sem_avail, p-&gt;sem_alloc, p-&gt;sem_req)) {</span></span><br><span class="line"><span class="addition">+			// Cancel the request.</span></span><br><span class="line"><span class="addition">+			p-&gt;sem_req[t-&gt;tid][semaphore_id] = 0;</span></span><br><span class="line"><span class="addition">+			return -0xDEAD;</span></span><br><span class="line"> 		}</span><br><span class="line"> 	}</span><br><span class="line"> </span><br><span class="line"><span class="addition">+acquire_sem:</span></span><br><span class="line"> 	semaphore_down(s);</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-	// Update state matrices after successfully acquiring the resource.</span></span><br><span class="line"><span class="deletion">-	if (p-&gt;deadlock_detect_enabled) {</span></span><br><span class="line"><span class="deletion">-		// The request has been fulfilled, clear it now.</span></span><br><span class="line"><span class="deletion">-		p-&gt;sem_req[t-&gt;tid][semaphore_id] = 0;</span></span><br><span class="line"><span class="deletion">-		// Increase the thread's allocation of this resource.</span></span><br><span class="line"><span class="deletion">-		p-&gt;sem_alloc[t-&gt;tid][semaphore_id]++;</span></span><br><span class="line"><span class="deletion">-		// Decrease the thread's available of this resource.</span></span><br><span class="line"><span class="deletion">-		p-&gt;sem_avail[semaphore_id]--;</span></span><br><span class="line"><span class="deletion">-	}</span></span><br><span class="line"><span class="addition">+	if (!p-&gt;deadlock_detect_enabled)</span></span><br><span class="line"><span class="addition">+		goto ret;</span></span><br><span class="line"> </span><br><span class="line"><span class="addition">+	// Update state matrices after successfully acquiring the resource.</span></span><br><span class="line"><span class="addition">+	// The request has been fulfilled, clear it now.</span></span><br><span class="line"><span class="addition">+	p-&gt;sem_req[t-&gt;tid][semaphore_id] = 0;</span></span><br><span class="line"><span class="addition">+	// Increase the thread's allocation of this resource.</span></span><br><span class="line"><span class="addition">+	p-&gt;sem_alloc[t-&gt;tid][semaphore_id]++;</span></span><br><span class="line"><span class="addition">+	// Decrease the thread's available of this resource.</span></span><br><span class="line"><span class="addition">+	p-&gt;sem_avail[semaphore_id]--;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+ret:</span></span><br><span class="line"> 	return 0;</span><br><span class="line"> }</span><br><span class="line"> </span><br><span class="line"><span class="deletion">-- </span></span><br><span class="line">2.25.1</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>上面的提交我就不详细解释了，注释都有。</p>
<h2 id="问答作业">问答作业</h2>
<ol type="1">
<li>在我们的多线程实现中，当主线程 (即 0 号线程)
退出时，视为整个进程退出，
此时需要结束该进程管理的所有线程并回收其资源。</li>
</ol>
<ul>
<li>需要回收的资源有哪些？</li>
<li>其他线程的 <code>struct thread</code>
可能在哪些位置被引用，分别是否需要回收，为什么？</li>
</ul>
<ol start="2" type="1">
<li><p>对比以下两种 <code>mutex_unlock</code>
中阻塞锁的实现，二者有什么区别？这些区别可能会导致什么问题？（假设无论哪种实现，对应的
<code>mutex_lock</code> 均正确处理了 <code>m-&gt;locked</code>）</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock_v1</span><span class="params">(<span class="keyword">struct</span> mutex *m)</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (m-&gt;blocking) {</span><br><span class="line">      m-&gt;locked = <span class="number">0</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> =</span> id_to_task(pop_queue(&amp;m-&gt;wait_queue));</span><br><span class="line">      <span class="keyword">if</span> (t != <span class="literal">NULL</span>) {</span><br><span class="line">        t-&gt;state = RUNNABLE;</span><br><span class="line">        add_task(t);</span><br><span class="line">      }</span><br><span class="line">  } <span class="keyword">else</span> ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mutex_unlock_v2(<span class="keyword">struct</span> mutex *m)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (m-&gt;blocking) {</span><br><span class="line">      <span class="keyword">struct</span> thread *t = id_to_task(pop_queue(&amp;m-&gt;wait_queue));</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="literal">NULL</span>) {</span><br><span class="line">        m-&gt;locked = <span class="number">0</span>;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        t-&gt;state = RUNNABLE;</span><br><span class="line">        add_task(t);</span><br><span class="line">      }</span><br><span class="line">  } <span class="keyword">else</span> ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ol>
<h2 id="问答作业答案">问答作业答案</h2>
<ol type="1">
<li>在我们的多线程实现中，当主线程 (即 0 号线程)
退出时，视为整个进程退出，
此时需要结束该进程管理的所有线程并回收其资源。</li>
</ol>
<ul>
<li><p>需要回收的资源有哪些？</p>
<p>当主线程退出导致整个进程终止时，需要回收所有相关资源以防泄漏。主要包括：内存资源，通过
<code>freepagetable</code>
函数释放整个用户地址空间（代码、数据、堆以及所有线程的用户栈），并回收每个线程的内核栈、<code>trapframe</code>
页、页表结构本身以及像管道（Pipe）一样由内核动态分配的内存；进程与线程的控制结构，将全局
pool 数组中的 <code>struct proc</code> 条目和其下所有的
<code>struct thread</code>
条目清理并标记为未使用状态，以供后续分配；文件与设备资源，关闭进程打开的所有文件描述符，并正确处理文件的引用计数；同步与调度资源，包括将进程中所有线程从调度器的就绪队列以及各类同步原语的等待队列中彻底移除。</p></li>
<li><p>其他线程的 <code>struct thread</code>
可能在哪些位置被引用，分别是否需要回收，为什么？</p>
<p>在一个运行的系统中，除了进程自身的 <code>threads</code>
数组，其他线程的 <code>struct thread</code>
引用主要存在于两个关键位置，并且都必须被回收。首先是全局的就绪队列（<code>task_queue</code>），等待调度的线程
ID 会存放在这里。当进程终止时，必须将其所有 <code>RUNNABLE</code>
的线程从这个队列中移除，否则调度器未来可能会尝试运行一个已被销毁的线程，这样就会访问到无效的内存，从而导致系统崩溃。其次是各类同步原语（如互斥锁、信号量）的等待队列中，因阻塞而处于
SLEEPING 状态的线程 ID
会存放在这里，这些也必须被移除，否则这些线程将永远无法被唤醒，造成线程资源永久泄漏，并可能导致其他依赖这些资源的进程产生问题。</p></li>
</ul>
<ol start="2" type="1">
<li><p>对比以下两种 <code>mutex_unlock</code>
中阻塞锁的实现，二者有什么区别？这些区别可能会导致什么问题？（假设无论哪种实现，对应的
<code>mutex_lock</code> 均正确处理了 <code>m-&gt;locked</code>）</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock_v1</span><span class="params">(<span class="keyword">struct</span> mutex *m)</span></span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (m-&gt;blocking) {</span><br><span class="line">      m-&gt;locked = <span class="number">0</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span> =</span> id_to_task(pop_queue(&amp;m-&gt;wait_queue));</span><br><span class="line">      <span class="keyword">if</span> (t != <span class="literal">NULL</span>) {</span><br><span class="line">        t-&gt;state = RUNNABLE;</span><br><span class="line">        add_task(t);</span><br><span class="line">      }</span><br><span class="line">  } <span class="keyword">else</span> ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> mutex_unlock_v2(<span class="keyword">struct</span> mutex *m)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">if</span> (m-&gt;blocking) {</span><br><span class="line">      <span class="keyword">struct</span> thread *t = id_to_task(pop_queue(&amp;m-&gt;wait_queue));</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="literal">NULL</span>) {</span><br><span class="line">        m-&gt;locked = <span class="number">0</span>;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        t-&gt;state = RUNNABLE;</span><br><span class="line">        add_task(t);</span><br><span class="line">      }</span><br><span class="line">  } <span class="keyword">else</span> ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>mutex_unlock_v1</code> 先解锁再唤醒，也就是先将
<code>m-&gt;locked</code> 置为
0，再唤醒等待队列中的线程。这样会导致在锁被释放到等待线程被唤醒之间的微小时间窗口内，如果有更高优先级的线程进入，这个线程会抢先获得锁，导致本应获得锁的等待线程被再次阻塞，引发线程饥饿问题，并因无效的唤醒和上下文切换而带来性能开销。<code>mutex_unlock_v2</code>
就没有这个问题，它先检查等待队列，如果队列不为空，会直接将等待线程置为就绪态，同时保持锁的状态为
<code>locked</code>，也就相当于把锁的所有权直接传递到下一个线程，只有当等待队列为空时，才将锁真正释放。这样就保证了
FIFO 的公平性。</p></li>
</ol>
<h2 id="用到的算法">用到的算法</h2>
<p>最后提一下这个实验里很重要的银行家算法吧，让 Gemini 讲一下：</p>
<p><strong>银行家算法（Banker’s
Algorithm）</strong>是一种在操作系统中用于<strong>避免死锁（Deadlock
Avoidance）</strong>的著名算法，由艾兹格・迪科斯彻（Edsger Dijkstra）在
1965 年为 THE 操作系统设计。</p>
<h3 id="核心思想">核心思想</h3>
<p>银行家算法的名字来源于它模拟了银行家向客户贷款的场景：</p>
<ul>
<li><strong>银行家（操作系统）</strong>：拥有一定数量的资金（系统资源）。</li>
<li><strong>客户（进程）</strong>：有多个客户，每个客户在开始时会声明他完成项目所需的最大资金额（进程所需的最大资源量）。</li>
<li><strong>贷款（资源分配）</strong>：客户可以分批次申请贷款，但总额不能超过他声明的最大值。</li>
<li><strong>还款（资源释放）</strong>：客户完成项目后，会把所有借款一次性还给银行。</li>
</ul>
<p>银行家的策略是：<strong>只有当他确信，即使批准了当前的贷款请求，也存在一种安全的放贷顺序，能让所有客户都最终完成项目并还款，他才会批准这次贷款。</strong>
否则，他会拒绝请求，让客户等待，直到有其他客户还款，资金变得充裕。</p>
<p>通过这种方式，银行（操作系统）永远不会进入一个无法收回所有贷款（无法满足所有进程的资源需求）的 “坏账” 状态，从而避免了死锁。</p>
<h3 id="关键数据结构">关键数据结构</h3>
<p>为了实现这个算法，操作系统需要维护以下几个核心的数据结构（假设有
<code>n</code> 个进程和 <code>m</code> 种资源）：</p>
<ol type="1">
<li><strong><code>Available</code> (可用资源向量)</strong>
<ul>
<li>一个长度为 <code>m</code> 的向量。</li>
<li><code>Available[j] = k</code> 表示系统中当前有 <code>k</code> 个
<code>Rj</code> 类型的可用资源。</li>
</ul></li>
<li><strong><code>Max</code> (最大需求矩阵)</strong>
<ul>
<li>一个 <code>n x m</code> 的矩阵。</li>
<li><code>Max[i][j] = k</code> 表示进程 <code>Pi</code> 最多需要
<code>k</code> 个 <code>Rj</code>
类型的资源。这个值是在进程创建时就声明的。</li>
</ul></li>
<li><strong><code>Allocation</code> (已分配矩阵)</strong>
<ul>
<li>一个 <code>n x m</code> 的矩阵。</li>
<li><code>Allocation[i][j] = k</code> 表示进程 <code>Pi</code>
当前已经被分配了 <code>k</code> 个 <code>Rj</code> 类型的资源。</li>
</ul></li>
<li><strong><code>Need</code> (需求矩阵)</strong>
<ul>
<li>一个 <code>n x m</code> 的矩阵。</li>
<li><code>Need[i][j] = k</code> 表示进程 <code>Pi</code>
<strong>还</strong>需要 <code>k</code> 个 <code>Rj</code>
类型的资源才能完成任务。</li>
<li>这个矩阵不是凭空来的，而是通过计算得出的：
<strong><code>Need[i][j] = Max[i][j] - Allocation[i][j]</code></strong></li>
</ul></li>
</ol>
<h3 id="核心算法">核心算法</h3>
<p>银行家算法主要包含两个部分：<strong>安全性算法</strong>和<strong>资源请求算法</strong>。</p>
<h4 id="安全性算法-safety-algorithm">安全性算法 (Safety Algorithm)</h4>
<p>这个算法用于检查当前系统状态是否是<strong>安全</strong>的。一个状态是安全的，指的是系统能找到一个<strong>安全序列（Safe
Sequence）</strong>。</p>
<p><strong>安全序列</strong>是指一个进程的排列
<code>&lt;P1, P2, ..., Pn&gt;</code>，按照这个顺序为每个进程分配其所需的全部资源，可以保证每个进程都能顺利执行完毕。</p>
<p><strong>算法步骤：</strong></p>
<ol type="1">
<li><strong>初始化</strong>：
<ul>
<li>创建一个工作向量
<code>Work</code>，<code>Work = Available</code>。</li>
<li>创建一个布尔向量 <code>Finish</code>，长度为
<code>n</code>，初始时所有元素都为
<code>false</code>。<code>Finish[i] = false</code> 表示进程
<code>Pi</code> 尚未完成。</li>
</ul></li>
<li><strong>寻找可完成的进程</strong>：
<ul>
<li>在所有进程中，寻找一个满足以下两个条件的进程 <code>Pi</code>：
<ul>
<li><code>Finish[i] == false</code> (该进程还没完成)</li>
<li><code>Need[i] &lt;= Work</code>
(该进程所需资源小于或等于当前系统可用资源)</li>
</ul></li>
<li>如果找不到这样的进程，则跳转到第 4 步。</li>
</ul></li>
<li><strong>模拟执行与释放</strong>：
<ul>
<li>如果找到了这样的进程
<code>Pi</code>，则假定它执行完毕并释放了所有资源。</li>
<li>更新 <code>Work</code>：<code>Work = Work + Allocation[i]</code> (把
<code>Pi</code> 占有的资源加回到可用资源中)</li>
<li>标记 <code>Pi</code> 为完成：<code>Finish[i] = true</code></li>
<li>返回第 2 步，继续寻找下一个可以完成的进程。</li>
</ul></li>
<li><strong>判断结果</strong>：
<ul>
<li>如果 <code>Finish</code> 向量中所有的元素都为
<code>true</code>，则说明系统处于<strong>安全状态</strong>，并且已经找到了一个安全序列。</li>
<li>否则，系统处于<strong>不安全状态</strong>。</li>
</ul></li>
</ol>
<h4 id="资源请求算法-resource-request-algorithm">资源请求算法
(Resource-Request Algorithm)</h4>
<p>当进程 <code>Pi</code>
发出资源请求时，系统按以下步骤操作。假设请求向量为
<code>Request_i</code>，<code>Request_i[j] = k</code> 表示进程
<code>Pi</code> 请求 <code>k</code> 个 <code>Rj</code> 类型的资源。</p>
<ol type="1">
<li><strong>检查请求的合法性</strong>：
<ul>
<li>判断 <code>Request_i &lt;= Need[i]</code> 是否成立。</li>
<li>如果
<code>false</code>，说明进程请求的资源超过了它之前声明的最大需求，这是一个错误，应终止该进程。</li>
</ul></li>
<li><strong>检查系统是否有足够资源</strong>：
<ul>
<li>判断 <code>Request_i &lt;= Available</code> 是否成立。</li>
<li>如果 <code>false</code>，说明系统当前没有足够的资源来满足请求，进程
<code>Pi</code> 必须<strong>等待</strong>。</li>
</ul></li>
<li><strong>尝试分配（假装分配）</strong>：
<ul>
<li>如果前两步都通过，系统会<strong>尝试</strong>将资源分配给
<code>Pi</code>，并更新数据结构：
<ul>
<li><code>Available = Available - Request_i</code></li>
<li><code>Allocation[i] = Allocation[i] + Request_i</code></li>
<li><code>Need[i] = Need[i] - Request_i</code></li>
</ul></li>
</ul></li>
<li><strong>执行安全性检查</strong>：
<ul>
<li>调用<strong>安全性算法</strong>，检查经过第 3
步更新后的系统状态是否仍然是安全的。</li>
<li><strong>如果安全</strong>：正式批准 <code>Pi</code>
的请求，分配完成。</li>
<li><strong>如果不安全</strong>：系统必须<strong>撤销</strong>第 3
步的尝试分配操作（将 <code>Available</code>, <code>Allocation</code>,
<code>Need</code> 恢复原状），并让进程 <code>Pi</code>
<strong>等待</strong>。</li>
</ul></li>
</ol>
<h3 id="优缺点">优缺点</h3>
<ul>
<li><strong>优点</strong>：
<ul>
<li>能够有效地避免死锁的发生。</li>
<li>资源利用率相较于一些更保守的策略（如一次性分配所有资源）要高。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li><strong>需要预知最大资源需求</strong>：这在实际的通用操作系统中很难做到，因为程序的行为是动态的。</li>
<li><strong>进程数量和资源种类必须固定</strong>：算法要求参与者集合是稳定不变的。</li>
<li><strong>开销大</strong>：每次资源请求都需要运行一次安全性算法，其时间复杂度为
O (m * n²)，这在大型系统中可能是无法接受的。</li>
<li><strong>资源释放模型不灵活</strong>：算法要求进程在执行完毕后一次性释放所有资源，而实际情况中进程可能是边执行边释放资源的。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>uCore</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>riscv</tag>
      </tags>
  </entry>
</search>
